# 字符串

### P3370 【模板】字符串哈希

哈希的过程，其实可以看作**对一个串的单向加密过程**，并且需要保证所加的密**不能高概率重复**

对于每个串，**我们通过一个固定的转换方式，将相同的串使其的“密”一定相同，不同的串 \*尽量\* 不同。**

进制哈希的核心便是**给出一个固定进制$base$，将一个串的每一个元素看做一个进制位上的数字，所以这个串就可以看做一个$base$进制的数，那么这个数就是这个串的哈希值；则我们通过比对每个串的的哈希值，即可判断两个串是否相同**

#### 单哈希

```C++
#include <iostream>
#include <algorithm>
#include <string.h>
using namespace std;
typedef unsigned long long ull;
const ull mod=212370440130137957ll;
const int maxn=10010;
char s[10010];
int n,ans=1,prime=233317;
ull a[10010], base = 131;
ull hashe(char *s){
	int len=strlen(s);
	ull ans=0;
	for(register int i=0;i<len;++i){
		ans=(ans*base+(ull)s[i])%mod+prime;
	}
	return ans;
}
int main() {
	scanf("%d",&n);
	register int i;
	for(i=1;i<=n;++i){
		scanf("%s",s);
		a[i]=hashe(s);
	}
	sort(a+1,a+n+1);
	for(i=1;i<n;++i){
		if(a[i]!=a[i+1])ans++;
	}
	printf("%d",ans);
	system("pause");
	return 0;
}
```

#### 无错哈希

我们要记录每一个已经诞生的哈希值，然后对于每一个新的哈希值，我们都可以来判断是否和已有的哈希值冲突，如果冲突，那么可以将这个新的哈希值不断加上一个大质数，直到不再冲突

```C++
for(register int i=1;i<=m;++i){
    cin>>str;
    while(check[hash(str)]) hash[i]+=19260817;
    hash[i]+=hash[str];
}
```

#### 多重哈希

用不同的两种或多种方式哈希，然后分别比对每一种哈希值是否相同——显然是增加了空间和时间，但也确实增加了其正确性。



### P6114 【模板】Lyndon 分解

#### $Lyndon $分解

##### 前后缀

字符串的前缀是指字符串的任意首部。比如字符串“abbc”的前缀有“a”,“ab”,“abb”,“abbc”。同样，字符串的任意尾部是字符串的后缀，“abbc”的后缀有“c”,“bc”,“bbc”,“abbc”。

##### $Lyndon $串

对于一个字符串，若其本身就是其最小后缀，则称它为 $Lyndon $串。

形式化地，对于长度为$ n$的字符串$ s$，若满足对于 $i \in [2,n]$，都有$ s < s[i:n]$，则称其为$ Lyndon $串。

##### 定理

- 如果$ u$和$ v$都是$Lyndon $串并且$ u<v$，则 $uv$也是$Lyndon $串。
- 若字符串$ v$和字符$ c$满足$ vc$是某个$Lyndon $串的前缀，则对于字符$ d>c$有$ vd$是 $Lyndon $串。

##### $Lyndon $分解

任意一个字符串都可以被唯一的分解成若干个字典序非严格递减的$ Lyndon $串。

形式化地，对于长度为$ n$的字符串$ s$，存在唯一的若干个$ Lyndon $串$ t_{1\dots m}$，满足 $s=t_1 + t_2 + \cdots + t_m$且$ t_1 \ge t_2 \ge \cdots \ge t_m$。

##### $Duval$算法

维护三个指针$ i,j,k$，这三个指针将整个字符串分成了四个部分 $s[1:i-1], s[i,k-1], s[j,k-1], s[k,n]$：

- $s[1,i-1]$：这部分的$ Lyndon $分解已经完成。
- $s[i,k-1]$：这部分可以被表示成$ t^c + v$，其中$ t$是一个$ Lyndon $串，$t^c$表示$ t$循环$ c$次，$v$是$ t$的一个可空真前缀。
- $s[j,k-1]$：注意这部分是包含在上一个部分中的，其中$ j = k - |t|$。
- $s[k,n]$：这部分还未处理，此时正在考虑 $k$。

考虑$ k$有三种情况：

- $s_j = s_k$：可以将$ t$继续循环下去，因此$ j$往后移一位，考虑下一个$ k$。
- $s_j < s_k$：可以将$ t^c + v + s_k$合并为一个$ Lyndon $串，因此$ j$设为$ i$，考虑下一个$ k$。
- $s_j > s_k$：可以将$ t$单独作为$ Lyndon $分解中的一个串，然后从$ v$的开头开始重新考虑，因此$ i$设为$ v$的开头，$j,k$对应设为$ i,i+1$。

复杂度分析：$i$只会单调往右移动，同时$ k$每次移动的距离不会超过$ i$移动的距离，所以时间复杂度是$ O(n)$的。

```C++
#include <iostream>
#include <cstring>
using namespace std;
const int maxn = 5e6 + 5;
char s[maxn];
int main() {
    scanf("%s", s + 1);
    int ans = 0, n = strlen(s + 1);
    register int i = 1, j = 0, k = 0;
    while(i <= n){
        j = i, k = i + 1;
        while(k <= n && s[j] <= s[k]) j = s[j] == s[k++] ? j + 1 : i;
        while(i <= j) i += k - j; ans ^= i - 1; // i - 1是Lyndon串的最后一个字符位置
    } 
    printf("%d", ans);
    return 0;
}
```



### P1368 【模板】最小表示法

一个字符串的**最小表示**定义为其所有循环同构中字典序最小的串。

形式化地，对于长度为$ n$的字符串 $s$，若$ p \in [1,n]$满足对于$ i \in [1, n]$，都有$ s[p:n] + s[1:p-1] \le s[i:n] + s[1:i-1]$，则称$ s[p:n] + s[1:p-1]为$ $s$的最小表示。

#### $Lyndon$分解

对于长度为$ n$的字符串$ s$，设$ t = s + s$，对$ t$进行$ Lyndon $分解，找到首字符位置$ \le n$且最大的 $Lyndon $串，这个串的首字符即最小表示法的首字符。

```C++
#include <iostream>
#include <cstring>
using namespace std;
const int maxn = 3e5 + 5;
int n, ans, s[maxn << 1];
int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i) {
		scanf("%d", &s[i]);
		s[n + i] = s[i];
	}
	register int i = 1, j = 0, k = 0;
	while(i <= n << 1){
		j = i, k = i + 1;
		while(k <= n << 1 && s[j] <= s[k]) j = s[j] == s[k++] ? j + 1 : i;
		while(i <= j) {
			i += k - j;
			ans = i <= n ? i : ans;
		} 
	}
	for(i = ans; i < ans + n; ++i) printf("%d ", s[i]);
	system("pause");
	return 0;
}
```

#### 最小表示法

设$S$的长度为$len$

1. 利用两个指针$i,j$。初始化时$i$指向$s[0]$，$j$指向$s[1]$。我们规定i和j在任意时刻都不能相等。
2. 匹配长度$k=0$开始，检验$s[i+k]$和$s[j+k]$是否相等，相等$k++$，一直下去，直到找到第一个不相同的字符（若k试了一个字符串的长度也没找到不同，即整个串都是相同的字符。则那个位置就是最小表示位置，算法终止并返回）该过程中，我们发现$s[i+k]$和$s[j+k]$的关系有三种：
   - $s[i+k]>s[j+k]$, 由于$s[i, i+k-1 ]$都不会是循环字符串的"最小表示"的前缀，i滑动到$i+k+1$处。
   - $s[i+k]<s[j+k]$，同理关系 1)，j滑动到$ j+k+1 $处
   - $s[i+k]==s[j+k]$，则$k++$
3. 若滑动后$i==j$，将正在变化的那个指针在$+1$.直到$i,j$把整个字串都检验完毕，返回两者中小于$len$的值。如果$ k==len$，则返回$ min(i，j)$

```C++
#include <iostream>
using namespace std;
const int maxn = 3e5 + 5;
int n, ans, s[maxn];

int main() {
	scanf("%d", &n);
	register int i, j, k, t;
	for(i = 0; i < n; ++i) scanf("%d", &s[i]);
	i = 0, j = 1, k = 0;
	while(i < n && j < n && k < n){
        t = s[(i + k % n)] - s[(j + k) % n];
		if(t == 0) ++k; //两个位置数值相等，匹配长度k++
		else{
			if(t > 0) i += k + 1;
			else j += k + 1;
			if(i == j) ++i;	 //任何时候都要满足i!=j
			k = 0; //匹配长度k归零
		}
	}
	ans = min(i, j);
	for(i = 0; i < n; ++i) printf("%d ", s[(i + ans) % n]);
	system("pause");
	return 0;
}
```

#### 最大表示法

```C++
#include <iostream>
using namespace std;
const int maxn = 3e5 + 5;
int n, ans, s[maxn];

int main() {
	scanf("%d", &n);
	register int i, j, k, t;
	for(i = 0; i < n; ++i) scanf("%d", &s[i]);
	i = 0, j = 1, k = 0;
	while(i < n && j < n && k < n){
		t = s[(i + k) % n] - s[(j + k) % n];
		if(t == 0) ++k;
		else {
			if(t > 0) j += k + 1;
			else i += k + 1;
			if(i == j) ++i;
			k = 0;
		}
	}
	ans = min(i, j);
	for(i = 0; i < n; ++i) printf("%d ", s[(i + ans) % n]);
	system("pause");
	return 0;
}
```



### P3805 【模板】manacher 算法

#### 预处理

- 由于回文串分为偶回文串和奇回文串，奇偶判断起来比较麻烦，因此我们可以在字符串的首、尾以及各个字符之间添加一些“神奇”字符（不妨使用$），但是要注意字符串的首添加的字符**必须**区别于各个字符之间的字符。
- 不难发现，修改后的字符串都变成了奇字符串。

#### $Manacher$算法

- 定义数组$p[i]$表示以字符$i$为回文中心的最长回文串的半径，不难发现，$p[i]-1$就是字符串中最长回文串的长度
- 定义$r$和$mid$，表示目前找到的回文串的右端的最右是$r$，中心是$mid$。
- 若当前扫描到的位置为$i$，若$mid\le i\le r$，则我们可以找到它的一个对称点$2\times mid - i$
- 可以得到公式$P[i]=min(P[mid<<1-i],r-i+1)$
- 假设原串某个最长回文串长度为`L`，在新串里的长度将会是`2L+1`，回文半径将会是`L+1`，而`L+1=P(max)`那么答案就是`P(max)-1`了

Manacher算法的时间复杂度为$O(n)$，因此是解决回文问题的利器。

```C++
#include <iostream>
using namespace std;
const int maxn = 1.1e7 + 5;
char s[maxn << 1];
int p[maxn << 1], ans;
int main() {
	register int i, r, cnt, mid;
	char c = getchar();
	s[0] = '~', s[cnt = 1] = '|';
	while(c < 'a' || c > 'z') c = getchar();
	while ('a' <= c && c <= 'z'){
		s[++cnt] = c, s[++cnt] = '|', c = getchar();
	}

	for(i = 1, r = 0, mid = 0; i <= cnt; ++i){
		if(i <= r) p[i] = min(p[(mid << 1) - i], r - i + 1);
		//暴力拓展左右两侧,
		// 当t-p[t]==0时，由于data[0]是'~'，自动停止。故不会下标溢出。
		while(s[i - p[i]] == s[i + p[i]]) ++p[i];
		if(p[i] + i > r) r = p[i] + i - 1, mid = i;
		//更新mid和r,保持r是最右的才能保证我们提前确定的部分回文半径尽量多。
		if(p[i] > ans) ans = p[i];
	}
	printf("%d\n", ans - 1);
	return 0;
}
```



### P3375 【模板】KMP字符串匹配

#### 模式串匹配

给定一个需要处理的文本串（理论上应该很长）和一个需要在文本串中搜索的模式串（理论上长度应该远小于文本串），查询在该文本串中，给出的模式串的出现有无、次数、位置等。

#### KMP算法

在模式串$ str1$中，对于每一位$ str1(i),$它的 $kmp$数组应当是记录一个位置 $j, j \leq i$并且满足$ str1(i)=str1(j) $并且在$ j!=1$时理应满足 $str1(1)$至$str1(j-1) $分别与$ str(i-j+1)-str1(i-1$)按位相等

用一个数组next来保存，next[j] = k，表示当T[i] != P[j]时，j指针的下一个位置。

- j已经在最左边了，不可能再移动了，这时候要应该是i指针后移。所以才会有next[0] = -1;这个初始化
- 当$P[k]=P[j]$时，有$next[j+1]=next[j]+1$
- 当$P[k]!=P[j]$时，有$k=next[k]$

时间复杂度为$O(n+m)$

#### 代码

```C++
#include <iostream>
#include <cstring>
#define MAXN 1000010
using namespace std;
char a[MAXN], b[MAXN];
int la, lb, kmp[MAXN];
int main() {
	scanf("%s", a + 1); la = strlen(a + 1);
	scanf("%s", b + 1);	lb = strlen(b + 1);
	register int i, j = 0;
	for(i = 2; i <= lb; ++i){
		while(j && b[i] != b[j + 1]) j = kmp[j];
		if(b[j + 1] == b[i]) ++j;
		kmp[i] = j;
	}
	j = 0;
	for(i = 1; i <= la; ++i){
		while(j && b[j + 1] != a[i]) j = kmp[j];
		if(b[j + 1] == a[i]) ++j;
		if(j == lb) {
			printf("%d\n", i - lb + 1);
			j = kmp[j];
		}
	}
	for(i = 1; i <= lb; ++i){
		printf("%d ", kmp[i]);
	}
	system("pause");
	return 0;
}
```



### P5410 【模板】扩展 KMP（Z 函数）



### P2580 于是他错误的点名开始了

#### 字典树

![img](https://bkimg.cdn.bcebos.com/pic/d62a6059252dd42a745cc2c2033b5bb5c9eab806?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto)

##### 特点：

- Trie的**根节点是空的**
- 除根节点外，每个节点储存一个单词/字母
- 也就是说，从**根节点到每个单词节点的路径上的所有字母连接而成的字符串就是该节点对应的字符串**
- 每个非叶子结点一般都会被多次使用，以节省遍历时的时间效率
- 另外，每个节点下面的数字是他们的编号。在代码中，我们一般把根节点编号为0，然后把其余节点从1开始编号，然后存在一个数组中

```C++
struct Trie{
	int ch[N][26], sz, val[N];
	//val为附加信息
    //这里的ch数组，第二维的大小为26是因为字符串只由小写字母构成，第二维的大小一般是由字符串的组成决定
    //sz即为节点编号 
	Trie(){
		sz = 1; //一开始的时候只有根节点这一个节点 
		memset(ch[0], 0, sizeof ch[0]);
		memset(val, 0, sizeof val);
	}
	//s代表要插入的字符串，v为附加信息
	void insert(char *s, int v){
		int u = 0, len = strlen(s + 1);
		for(register int i = 1; i <= len; ++i){
			int c = s[i] - 'a';
			if(!ch[u][c]){	//如果节点不存在就插入，不然就继续往下遍历
				memset(ch[sz], 0, sizeof ch[sz]);
				ch[u][c] = sz++;	//新建节点 
			}
			u = ch[u][c];	//往下遍历
		}
		val[u] = v; //插入附加信息，注意，我们一般只在叶子节点插入附加信息，中间的节点一般是没有附加信息的，因为一个非叶子结点，在Trie中一般都会被不同的单词使用到（定义）
	}
	//查找
	int search(char *s){
		int u = 0, len = strlen(s + 1);
		for(register int i = 1; i <= len; ++i){
			int c = s[i] - 'a';
			if(!ch[u][c]) return -1;	// 没有找到
			u = ch[u][c];	// 继续向下遍历
		}
		return val[u];	//这个节点存在，返回附加信息。
	}
}tree;
```

#### 代码

```C++
#include <iostream>
#include <cstring>
#define N 500010
using namespace std;
char s[55];
struct Trie
{
	int ch[N][26], sz, val[N];
	Trie(){
		sz = 1; 
		memset(ch[0], 0, sizeof ch[0]);
		memset(val, 0, sizeof val);
	}
	void insert(char *s){
		int u = 0, len = strlen(s + 1);
		for(register int i = 1; i <= len; ++i){
			int pos = s[i] - 'a';
			if(!ch[u][pos]){
				memset(ch[sz], 0, sizeof ch[sz]);
				ch[u][pos] = sz++;				
			}
			u = ch[u][pos];
		}
	}
	int search(char *s){
		int u = 0, len = strlen(s + 1);
		for(register int i = 1; i <= len; ++i){
			int pos = s[i] - 'a';
			if(!ch[u][pos]) return 0;
			u = ch[u][pos];
		}
		if(!val[u]) {
			val[u] = 1;
			return 1;
		}
		else return 2;
	}
}tree;

int main() {
	int n, m; scanf("%d", &n);
	register int i;
	for(i = 1; i <= n; ++i){
		scanf("%s", s + 1);
		tree.insert(s);
	}
	scanf("%d", &m);
	while(m--){
		scanf("%s", s + 1);
		i = tree.search(s);
		if(i == 1) puts("OK");
		else if(i == 2) puts("REPEAT");
		else puts("WRONG");
	}
	system("pause");
	return 0;
}
```



### P3808 【模板】$AC $自动机（简单版）

$AC$自动机用来解决多模式串匹配，也就是给好几个子串，一个很长很长很长很长很长的母串，让你处理一些问题，比如什么子串出现的次数之类的。

给定$n$个模式串和$1$个文本串，求有多少个模式串在文本串里**出现过**。

注意：是出现过，就是出现多次只算一次。

默认这里每一个人都已经会了$Trie$。

我们将$n$个模式串建成一颗$Trie$树，建的方式和建$Trie$完全一样。

![AC自动机](https://i.loli.net/2019/05/02/5ccaaa22cbf29.png)

假如我们现在有文本串ABCDBC。

我们用文本串在Trie上匹配，刚开始会经过2、3、4号点，发现到4，成功地匹配了一个模式串，然后就不能再继续匹配了，这时我们还要重新继续从根开始匹配吗？

不，这样的效率太慢了。这时我们就要借用KMP的思想，从Trie上的某个点继续开始匹配。

明显在这颗Trie上，我们可以继续从7号点开始匹配，然后匹配到8。

那么我们怎么确定从那个点开始匹配呢？我们称i匹配失败后继续从j开始匹配，j是i的Fail（失配指针）。

#### 构建Fail指针

##### Fail的含义

Fail指针的实质含义是什么呢？

如果一个点i的Fail指针指向j。那么root到j的字符串是root到i的字符串的一个后缀。

举个例子：（例子来自上面的图

```cpp
i:4     j:7
root到i的字符串是“ABC”
root到j的字符串是“BC”
“BC”是“ABC”的一个后缀
所以i的Fail指针指向j
```

同时我们发现，“C”也是“ABC”的一个后缀。

所以Fail指针指的j的深度要尽量大。

重申一下Fail指针的含义：((最长的(当前字符串的后缀))在Trie上可以查找到)的末尾编号。

##### 求Fail

首先我们可以确定，每一个点i的Fail指针指向的点的深度一定是比i小的。（Fail指的是后缀啊）

第一层的Fail一定指的是root。（比深度1还浅的只有root了）

**点i的父亲fa的Fail指针指的是fafail，那么如果fafail有和i值相同的儿子j，那么i的Fail就指向j**。这里可能比较难理解一点，不过等会转换成代码就很好理解了。

由于我们在处理i的情况必须要先处理好fa的情况，所以求Fail我们使用BFS来实现。

实现的一些细节：

1、刚开始我们不是要初始化第一层的fail指针为root，其实我们可以建一个虚节点0号节点，将0的所有儿子指向root（编号为1)，然后root的fail指向0就OK了。效果是一样的。

2、如果不存在一个节点i，那么我们可以将那个节点设为fafail的值和i相同的儿子。保证存在性，就算是0也可以成功返回到根，因为0的所有儿子都是根。

3、无论fafail存不存在和i值相同的儿子j，我们都可以将i的fail指向j。因为在处理i的时候j已经处理好了，如果出现这种情况，j的值是第2种情况，也是有实际值的，所以没有问题。

4、实现时不记父亲，我们直接让父亲更新儿子

##### 查询

求出了Fail指针，查询就变得十分简单了。

为了避免重复计算，我们每经过一个点就打个标记为-1，下一次经过就不重复计算了。

同时，如果一个字符串匹配成功，那么他的Fail也肯定可以匹配成功（后缀嘛），于是我们就把Fail再统计答案，同样，Fail的Fail也可以匹配成功，以此类推……经过的点累加flag，标记为-1。

最后主要还是和Trie的查询是一样的。

#### 代码1

```C++
#include <iostream>
#include <cstring>
#define MAXS 1000100
using namespace std;
int n, cnt, q[MAXS];
char tmp[MAXS];
struct node{
    int fail, num;
    int ch[30];
}tr[MAXS];

void build(){   // 建立Trie树
    int len = strlen(tmp), u = 0;
    for(register int i = 0; i < len; ++i){
        int s = tmp[i] - 'a';
        if(tr[u].ch[s] == 0) tr[u].ch[s] = ++cnt;
        u = tr[u].ch[s];
    }
    tr[u].num++;
}

void getFail(){
    int l = 0, r = 0;
    register int i;
    for(i = 0; i < 26; ++i){
        if(tr[0].ch[i] != 0){
            tr[tr[0].ch[i]].fail = 0;
            q[++r] = tr[0].ch[i];
        }
    }
    while(l < r){
        int u = q[++l];
        for(i = 0; i < 26; ++i){
            int v = tr[u].ch[i];
            if(v){
                tr[v].fail = tr[tr[u].fail].ch[i];  // 处理fail指针，是它父亲的fail指针的i儿子
                q[++r] = v;
            }else tr[u].ch[i] = tr[tr[u].fail].ch[i]; //处理所说的“虚指针
        }
    }
}

int AC(){
    int len = strlen(tmp);
    int u = 0, ans = 0;
    for(register int i = 0; i < len; ++i){
        int s = tmp[i] - 'a';
        u = tr[u].ch[s];
        int v = u;
        while(v && ~tr[v].num){
            ans += tr[v].num;
            tr[v].num = -1; //加过了之后就不用再加了
            v = tr[v].fail;
        }
    }
    return ans;
}

int main() {
    scanf("%d", &n);
    for(register int i = 1; i <= n; ++i){
        scanf("%s", tmp);   // 模式串
        build();
    }
    tr[0].fail = 0;
    getFail();
    scanf("%s", tmp);   // 文本串
    printf("%d", AC());
    system("pause");
    return 0;
}
```

#### 代码2

```C++
#include<bits/stdc++.h>
#define maxn 1000001
using namespace std;
struct kkk{
	int son[26],flag,fail;
}trie[maxn];
int n,cnt;
char s[1000001];
queue<int >q;
void insert(char* s){
	int u=1,len=strlen(s);
	for(int i=0;i<len;i++){
		int v=s[i]-'a';
		if(!trie[u].son[v])trie[u].son[v]=++cnt;
		u=trie[u].son[v];
	}
	trie[u].flag++;
}
void getFail(){
	for(int i=0;i<26;i++)trie[0].son[i]=1;			//初始化0的所有儿子都是1
	q.push(1);trie[1].fail=0;				//将根压入队列
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i<26;i++){				//遍历所有儿子
			int v=trie[u].son[i];			//处理u的i儿子的fail，这样就可以不用记父亲了
			int Fail=trie[u].fail;			//就是fafail，trie[Fail].son[i]就是和v值相同的点
			if(!v){trie[u].son[i]=trie[Fail].son[i];continue;}	//不存在该节点，第二种情况
			trie[v].fail=trie[Fail].son[i];	//第三种情况，直接指就可以了
			q.push(v);						//存在实节点才压入队列
		}
	}
}
int query(char* s){
	int u=1,ans=0,len=strlen(s);
	for(int i=0;i<len;i++){
		int v=s[i]-'a';
		int k=trie[u].son[v];		//跳Fail
		while(k>1&&trie[k].flag!=-1){	//经过就不统计了
			ans+=trie[k].flag,trie[k].flag=-1;	//累加上这个位置的模式串个数，标记已经过
			k=trie[k].fail;			//继续跳Fail
		}
		u=trie[u].son[v];			//到下一个儿子
	}
	return ans;
}
int main(){
	cnt=1;scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%s",s);
		insert(s);
	}
	getFail();
	scanf("%s",s);
	printf("%d\n",query(s));
	return 0;
}
```



#### P6216 回文匹配
