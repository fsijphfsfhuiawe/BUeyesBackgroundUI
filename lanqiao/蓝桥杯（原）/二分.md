# 二分

### P2249 【深基13.例1】查找

#### 思想

使用STL中的lower_bound(int* first,int* last,val);方法。

#### 代码

```C++
#include <iostream>
#include <algorithm>
using namespace std;
const int maxn = 1e6 + 5;
int f[maxn], n, m;
int binarySearch(int x){
	int pos = lower_bound(f + 1, f + n + 1, x) - f;
	if(f[pos] == x) return pos;
	else return -1;
}
int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++) scanf("%d", &f[i]);
	while(m--){
		int x; scanf("%d", &x);
		printf("%d ", binarySearch(x));
	}
	system("pause");
	return 0;
}
```

#### 知识点

二分、查找



### P1102 A-B 数对

```C++
#include <iostream>
#include <map>
using namespace std;
typedef long long ll;
map<ll, ll> mp;

int main() {
	int N, C;
	ll res = 0; 
	scanf("%d%d", &N, &C);
	for(int i = 1; i <= N; i++){
		ll tmp; scanf("%lld", &tmp);
		res += mp[tmp];
		mp[tmp + C]++; mp[tmp - C]++;
	}
	printf("%lld", res);
	system("pause");
	return 0;
}
```

#### 知识点

哈希



### P1873 [COCI 2011/2012 #5] EKO / 砍树

```C++
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
const int maxn = 1e6 + 5;
ll f[maxn], N, M, longest;

ll binarySearch(ll M){
	ll left = 1, right = longest;
	ll mid;
	while (left <= right){
		mid = (left + right) >> 1;
		ll res = 0;
		for(register int i = N; i; i--){
			if(f[i] > mid) res += f[i] - mid;
			else break;
		}
		if(res < M) right = mid - 1;
		else left = mid + 1;
	}
	return left - 1;
}

int main() {
	scanf("%lld%lld", &N, &M);
	for(register int i = 1; i <= N; i++) {
		scanf("%lld", &f[i]);
		longest = max(longest, f[i]);
	}
	sort(f + 1, f + N + 1);
	printf("%lld", binarySearch(M));
	system("pause");
	return 0;
}
```

#### 知识点

二分



### P1024 [NOIP2001 提高组] 一元三次方程求解

```C++
#include <iostream>
using namespace std;

int main() {
    double a, b, c, d;
    scanf("%lf%lf%lf%lf", &a, &b, &c, &d);
    for(register double i = -100; i <= 100; i += 0.001){
        double j = i + 0.001;
        double y1=a*i*i*i+b*i*i+c*i+d;
        double y2=a*j*j*j+b*j*j+c*j+d;
        if(y1 >= 0 && y2 <= 0 || y1 <= 0 && y2 >= 0){
            double x = (i + j) / 2;
            printf("%.2lf ", x);
        }
    }
    system("pause");
    return 0;
}
```

