# 蓝桥杯赛前冲刺
## 注意事项
程序处理完一个用例的数据后，立即退出(`return 0`)，千万不要循环等待下一个用例的输入。

对于编程题目，要求选手给出的解答完全符合ANSI C++标准。

`main`函数结尾需要`return 0`;

1. 一般$O(n)$的算法能解决的数据范围在$n\le 10^8$
2. 一般$O(n\log n)$的算法能解决的数据范围在$n\le 10^6$
3. 一般$O(n\sqrt n)$的算法能解决的数据范围在$n\le 10^5$
4. 一般$O(n^2)$的算法能解决的数据范围在$n\le 5000$
5. 一般$O(n^3)$的算法能解决的数据范围在$n\le 300$
6. 一般$O(2^n)$的算法能解决的数据范围在$n\le 25$
7. 一般$O(n!)$的算法能解决的数据范围在$n\le 11$

## 深度优先搜索(dfs)

### 中国象棋

```C++
#include <bits/stdc++.h>
using namespace std;

char s[10][10];
int dir[8][2] = {{2,1}, {1,2}, {-1,2}, {-2,1}, {-2, -1}, {-1, -2}, {1, -2}, {2, -1}};
bool f;
void dfs(int x, int y){
    vis[x][y] = true;
    if(f) return;
    if(s[x][y] == 'T') {
        f = true; return;
    }
    for(int i = 0; i < 8; i++){
        int tx = x + dir[i][0];
        int ty = y + dir[i][1];
        if(in(tx, ty) && s[tx][ty] != '#' && !vis[tx][ty]){
            dfs(tx, ty);
        }
    }
    vis[x][y] = false;
}
int main(){
    int x, y;
    for(int i = 0; i < 10; i++){
        scanf("%s", s[i]);
    }
    for(int i = 0; i < 10; i++{
        for(int j = 9; j < 9; j++){
            if(S[i][j] == 'S') x = i, y = j;
        }
    }
    dfs(x, y);
    printf(f ? "Yes" : "No");
    return 0;
}
```

### 踏青

```C++
#include <bits/stdc++.h>
using namespace std;
char mp[105][105];
bool vis[105][105];
int n, m;

void dfs(int x, int y){
	if(x < 0 || x >= n || y < 0 || y >= m || mp[x][y] == '.'){
		return;
	}	
	vis[x][y] = true;
	dfs(x - 1, y);
	dfs(x + 1, y);
	dfs(x, y - 1);
	dfs(x, y + 1);
}

int main(){
	int cnt = 0;
	scanf("%d%d", &n, &m);
	for(int i = 0; i < n; i++) scanf("%s", mp[i]);
	for(int i = 0; i < n; i++){
		for(int j = 0; j < m; j++){
			if(!vis[i][j] && mp[i][j] == '#'){
				dfs(i, j);
				cnt++;
			}
		}
	}
	printf("%d\n", cnt);
} 
```

### 找出迷宫的所有路径数目

```C++
#include <bits/stdc++.h>
using namespace std;
int n, m, cnt = 0;
bool vis[15][15]
char mp[15][15];

void dfs(int x, int y){
	if(x < 0 || x >= n || y < 0 || y >= m || vis[x][y] || mp[x][y] == '#'){
		return;
	}
	if(mp[x][y] == 'e') cnt++;
	vis[x][y] = true;
	dfs(x + 1, y);
	dfs(x - 1, y);
	dfs(x, y + 1);
	dfs(x, y - 1);
}
int main(){
	int x, y;
	scanf("%d%d", &n, &m);
	for(int i = 0; i < n; i++){
		scanf("%s", mp[i]);
	}
	for(int i = 0; i < n; i++){
		for(int j = 0; j < m; j++){
			if(mp[i][j] == 's') x = i, y = j;
		}
	}
	dfs(x, y);
	printf("%d", cnt);
} 
```

### 最大蛋糕数

```C++
#include <bits/stdc++.h>
using namespace std;
int n, m, cnt, ans;
char mp[1005][1005];
bool vis[1005][1005];

void dfs(int x, int y){
	if(x < 0 || x >= n || y < 0 || y >= m || mp[x][y] == '.') return;
	vis[x][y] = true;
	cnt++;
	dfs(x + 1, y);
	dfs(x - 1, y);
	dfs(x, y + 1);
	dfs(x, y - 1);
}

int main(){
	scanf("%d%d", &n, &m);
	for(int i = 0; i < n; i++) scanf("%s", mp[i]);
	for(int i = 0; i < n; i++){
		for(int j = 0; j < m; j++){
			if(!vis[i][j] && mp[i][j] == '#'){
				cnt = 0;
				dfs(i, j);
				ans = max(ans, cnt);
			}
		}
	} 
	dfs(x, y);
	printf("%d", res);
} 
```

### 直系后代

```C++
#include <bits/stdc++.h>
using namespace std;
vector<int> son[100005];
int ans[100005];
bool f[100005];

int dfs(int u){
	int res = 0;
	for(int i = 0; i < son[u].size(); i++){
		res += dfs(son[u][i]);
	}
	ans[u] = res;
	return res + 1;
}
int main(){
	int n, x, y, root;
	scanf("%d", &n);
	for(int i = 1; i <= n; i++){
		scanf("%d%d", &x, &y);
		son[x].push_back(y);
		f[y] = true;
	}
	for(int i = 1; i <= n; i++){
		if(!f[i]) root = i, break;
	}
	dfs(root);
	for(int i = 1; i <= n; i++){
		printf("%d\n", ans[i]);
	}
	return 0;
} 
```

### 王子救公主

```C++
#include <bits/stdc++.h>
using namespace std;
int n, m;
char mp[105][105];
bool vis[105][105][2];
// 看王子可以到达的点和公主可以到达的点是否有重复的
// 如果有重复，说明可以救出
 
void dfs(int x, int y, int d){ // 0表示王子 
	if(x < 0 || x >= n || y < 0 || y >= m || vis[x][y][d] || mp[x][y] == '#'){
		return;
	}
	vis[x][y][d] = true;
	dfs(x - (2 - d), y);
	dfs(x + (2 - d), y);
	dfs(x, y - (2 - d));
	dfs(x, y + (2 - d));
}
int main(){
	int x1, y1, x2, y2;
	scanf("%d%d", &n, &m);
	for(int i = 0; i < n; i++){
		scanf("%s", mp[i]);
	}
	for(int i = 0; i < n; i++){
		for(int j = 0; j < m; j++){
			if(mp[i][j] == 'w') x1 = i, y1 = j;
			if(mp[i][j] == 'g') x2 = i, y2 = j;
		}
	}
	
	dfs(x1, y1, 0);
	dfs(x2, y2, 1);
	
	for(int i = 0; i < n; i++){
		for(int j = 0; j < m; j++){
			if(vis[i][j][0] == vis[i][j][1]) {
				printf("yes");
				return 0;
			}
		}
	}
	printf("no");
	return 0;
} 
```

### 时间分配

```C++
#include <bits/stdc++.h>
using namespace std;
int task[15][15], n, ans = 200000;
bool used[15];

void dfs(int x, int t){
	if(x == n){
		if(t < ans) ans = t;
		return;
	}
	for(int i = 0; i < n; i++){
		if(!used[i]){
			used[i] = true;
			dfs(x + 1, t + task[x][i]);
			used[i] = false;
		}
	}
}

int main(){
	scanf("%d", &n);
	for(int i = 0; i < n; i++){
		for(int j = 0; j < n; j++){
			scanf("%d", &task[i][j]);
		}
	}
	dfs(0, 0);
	printf("%d\n", ans);
	return 0;
} 
```

## 抽象深度优先搜索

### 从n个数中选k个数使得和为sum，求所有选法的数目

```C++
#include <bits/stdc++.h>
using namespace std;
int n, k, sum, ans;
int a[40];
void dfs(int i, int cnt, int s){
	if(i == n){
		if(cnt == k && s == sum) ans++;
		return;
	}
	dfs(i + 1, cnt, s);	// 不选 
	dfs(i + 1, cnt + 1, s + a[i]); //选 
}

int main(){
	scanf("%d%d%d", &n, &k, &sum);
	for(int i = 0; i < n; i++){
		scanf("%d", &a[i]);
	}
	dfs(0, 0, 0);
	printf("%d", ans);
	return 0;
}
```

```C++
#include <iostream>
using namespace std;
int n, k, sum, ans;
int a[40];
bool selected[40];
void dfs(int s, int cnt){
	if(s == sum && cnt == k) ans++;
	for(int i = 0; i < n; i++){
		if(!selected[i]){
			selected[i] = true;
			dfs(s + a[i], cnt + 1);
			selected[i] = false;
		}
	}
}

int main(){
	// 输入数据
	scanf("%d%d%d", &n, &k, &sum);
	for(int i = 0; i < n; i++) scanf("%d", &a[i]);
	ans = 0;
	dfs(0, 0);
	printf("%d", ans); 
	return 0;
} 
```

### 等边三角形

```C++
#include <bits/stdc++.h>
using namespace std;
int p[15];
int n, sum = 0; 
bool f, vis[15];
void dfs(int cnt, int s, int st){
	if(f) return;
	if(cnt == 3) f = true; return;
	if(s == sum / 3) dfs(cnt + 1, 0, 0); return;
	for(int i = st; i < n; i++){
		if(!vis[i]){
			vis[i] = true;
			dfs(cnt, s + p[i], i + 1);
			vis[i] = false;
		}
	}
}

int main(){
	scanf("%d", &n);
	for(int i = 0; i < n; i++) {
		scanf("%d", &p[i]);
		sum += p[i];
	}
	if(sum % 3 != 0){
		printf("no\n");
	}else{
		dfs(0, 0, 0);
		if(f) printf("yes\n");
		else printf("no\n");
	}
	
	return 0;
}
```

### 8皇后问题

```C++
#include <bits/stdc++.h>
using namespace std;
int ans = 0;
bool col[10], x1[20], x2[20];
bool check(int r, int i){
	return !col[i] && !x1[r + i] && !x2[r + i - 8];
}
void dfs(int r){
	if(r == 8){
		ans++;
		return;
	}
	for(int i = 0; i , 8++){
		if(check(r, i)){
			col[i] = x1[r + i] = x2[r - i + 8] = true;
			dfs(r + 1);
			col[i] = x1[r + i] = x2[r - i + 8] = false;
		}
	}
}

int main(){
	dfs(0);
	printf("%d", ans);
	return 0;
}
```

### n元高次方程组

```C++
#include <bits/stdc++.h>
using namespace std;
int k[5], p[5];
int n, M, ans;
void dfs(int x, int s){
	if(x == n){
		if(s == 0) ans++;
		return;
	}
	for(int i = 1; i <= M; i++){
		dfs(x + 1, s + k[x] * pow(x, p[x]));
	}
}
int main(){
	scanf("%d%d", &n, &M);
	for(int i = 0; i < n; i++) scanf("%d%d", &k[i], &p[i]);
	dfs(0, 0);
	printf("%d", ans);
	return 0;
}
```

### 数独

```C++
#include <bits/stdc++.h>
using namespace std;
bool f;
char s[10][10];
bool vx[10][10], vy[10][10], vv[10][10];
void dfs(int x, int y){
	if(f) return;
	if(x == 9){
		f = true;
		for(int i == 0; i < 9; i++){
			for(int j = 0; j < 9; j++){
				if(j != 8) printf("%c " s[i][j]);
				else printf("%c\n", s[i][j]);
			}
		}
		return;
	}
	if(y == 9){
		dfs(x + 1， 0)； return; 
	}
	if(s[x][y] != '*'){
		dfs(x, y + 1);
	}
	for(int i = 1; i < 9; i++){
		if(!vs[x][i] && !vy[y][i] && !vv[x / 3 * 3 + y / 3][i]){
			s[x][y] = '0' + i;
			vx[x][i] = vy[y][i] = vv[x / 3 * 3+ y / 3][i] = true;
			dfs(x, y + 1);
			vx[x][i] = vy[y][i] = vv[x / 3 * 3 + y / 3][i] = false;
			s[x][y] = '*';
		}
	}
}
int main(){
	for(int i = 0; i < 9; i++){
		scanf("%s", s[i]);
	}
	for(int i = 0; i < 9; i++){
		for(int j = 0; j < 9; j++){
			if(s[i][j] != '*'){
				vx[i][s[i][j] - '0'] = false;
				vy[j][s[i][j] - '0'] = false;
				vv[i / 3  * 3+ j / 3][s[i][j] - '0'] = true;
			}
		}
	}
	dfs(0, 0);
	return 0;
}
```

### 2n皇后问题

```C++
#include <bits/stdc++.h>
using namespace std;
char s[1005][1005];
bool vx[1005], vy[1005];
int n, m, cnt; 
void dfs(int x, int y){
	s[x][y] = '0';
	if(!vx[x]){
		vx[x] = true;
		for(int i = 0; i < m; i++){
			if(mp[x][i] == '1') dfs(x, i); 
		}
	}
	if(!vy[y]){
		vy[y] = true;
		for(int i = 0; i < n; i++){
			if(mp[i][y] == '1') dfs(i, y);
		}
	}
}
int main(){
	scanf("%d%d", &n, &m);
	for(int i = 0; i < n; i++){
		scanf("%s", s[i]);
	}
	for(int i = 0; i < n; i++){
		for(int j = 0; j < m; j++){
			if(s[i][j] == '1') {
				cnt++;
				dfs(i, j);
			}
		}
	}
	return 0;
}
```

## 深度优先搜索的剪枝

### 可行性剪枝

```C++
#include <bits/stdc++.h>
using namespace std;
int n, k, sum, ans;
int a[40];
void dfs(int i, int cnt, int s){
	if(cnt > k) return;
	if(s > sum) return;
	if(i == n){
		if(cnt == k && s == sum) ans++;
		return;
	}
	dfs(i + 1, cnt, s);	// 不选 
	dfs(i + 1, cnt + 1, s + a[i]); //选 
}

int main(){
	scanf("%d%d%d", &n, &k, &sum);
	for(int i = 0; i < n; i++){
		scanf("%d", &a[i]);
	}
	dfs(0, 0, 0);
	printf("%d", ans);
	return 0;
}
```

### 最优性剪枝

在搜索是否有可行解时，一旦找到一组可行解，后面所有的搜索都不必再进行。使用bool变量来实现。

```C++
#include <bits/stdc++.h>
using namespace std;
int n, m, ans = 100000;
string maze[110];
bool vis[110][100];
int dir[4][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}}; // 一般按照逆时针 
bool in(int x, int y){
	return 0 <= x && x < n && 0 <= y && y < m;
} 
void dfs(int x, int y, int step){
	if(step >= ans) return;
	if(maze[x][y] == 'T'){
		ans = step;
		return;
	}
	vis[x][y] = 1;
	for(int i = 0; i < 4; i++){
		int tx = x + dir[i][0];
		int ty = y + dir[i][1];
		if(in(tx, ty) && maze[tx][ty] != '*' & !vis[tx][ty]){
			dfs(tx, ty, step + 1);
		}
	}
	vis[x][y] = 0;
}
int main(){
	int x, y;
	scanf("%d%d", &n, &m);
	for(int i = 0; i < n; i++){
		for(int j = 0; j < m; j++){
			if(maze[i][j] == 'S'){
				x = i, y = j;
			}
		}
	}
	dfs(x, y, 0);
	printf("%d", ans);
	return 0;
} 
```

### 重复性剪枝

对于一些特定的搜索方式，一个方案可能会被搜索很多次，这是没有必要的。
我们规定选出来的数的位置是递增的，在搜索的时候，用一个参数来记录上一次选取的数的位置，那么此次选择我们从这个数之后开始选取，那么最后选出来的方案就不会重复。

```C++
#include <bits/stdc++.h>
using namespace std;
int n, k, sum, ans;
int a[40];
bool vis[40];
void dfs(int cnt, int s, int pos){
	if(cnt > k || s > sum) return;
	if(i == n){
		if(cnt == k && s == sum) ans++;
		return;
	}
	for(int i = pos; i < n; i++){
		if(!vis[i]){
			vis[i] = 1;
			dfs(cnt + 1, s + a[i], i + 1);
			vis[i] = 0;
		}
	}
}

int main(){
	scanf("%d%d%d", &n, &k, &sum);
	for(int i = 0; i < n; i++){
		scanf("%d", &a[i]);
	}
	dfs(0, 0, 0);
	printf("%d", ans);
	return 0;
}
```

### 奇偶性剪枝

[](图片/奇偶性剪枝.png)

```C++
#include<bits/stdc++.h>
using namespace std;
const int N = 20;
int n, m, T;
char mat[N][N];
bool vis[N][N];
int dx[4] = {0, 0, -1, 1};
int dy[4] = {1, -1, 0, 0};
bool ok;

void dfs(int x, int y, int t){
	if(ok) return;
	if(t == T){
		if(mat[x][y] == 'D') ok = true;
		return;
	}
	vis[x][y] = true;
	for(int i = 0; i < 4; i++){
		int tx = x + dx[i];
		int ty = y + dy[i];
		if(tx < 0 || tx >= n || ty < 0 || ty >= m || mat[tx][ty] == 'X' || vis[tx][ty]){
			dfs(tx, ty, t + 1);
		}
	}
	vis[x][y] = false;
}
int main(){
	scanf("%d%d%d", &n, &m, &T);
	for(int i = 0; i < n; i++) scanf("%s", mat[i]);
	int sx, sy, ex, ey;
	for(int i = 0; i < n; i++){
		for(int j = 0; j < m; j++){
			if(mat[i][j] == 'S') sx = i, sy = j;
			if(mat[i][j] == 'D') ex = i, ey = j;
		}
	}
	if((sx + sy + ex + ey + T) % 2 != 0) printf("no\n"); return 0; // 奇偶性剪枝 
	
	dfs(sx, sy, 0);
	if(ok) printf("yes\n");
	else printf("no\n");
	return 0;
}
```

### 找数字

```C++
#include<bits/stdc++.h>
using namespace std;
int n;
bool ok;
void dfs(long long x, int cnt){
	if(cnt >= 19) return;
	if(ok) return;
	if(x % n == 0) ok = true; printf("%lld", x); return;
	dfs(x * 10, cnt + 1);
	dfs(x * 10 + 1, cnt + 1);
}
int main(){
	scanf("%d", &n);
	dfs(1, 0);
	return 0;
} 
```

### 全排列

```C++
#include <bits/stdc++.h>
using namespace std;
int n;
bool vis[20];
void dfs(int cnt, int num){
	if(cnt == n){
		printf("%d", num);
		return;
	}
	for(int i = 1; i <= n; i++){
		if(!vis[i]){
			vis[i] = true;
			dfs(cnt + 1, num * 10 + i);
			vis[i] = false;
		}
	}
}
int main(){
	scanf("%d", &n);
	int ans = 1;
	for(int i = 1; i <= n; i++) ans *= i;
	printf("%d", ans);
	dfs(0, 0);
	return 0;
}
```

### 旅游计划

```C++
#include <bits/stdc++.h>
using namespace std;
int G[20][20];
bool vis[20];
int ans = 10000000000;
int n;
void dfs(int u, int cnt, int sum){
	if(sum >= ans) return;
	if(cnt == n) {
		cnt = min(ans, sum + G[u][1]);
		return;
	}
	vis[u] = 1;
	for(int i = 1; i <= n; i++){
		if(!vis[i]){
			dfs(i, cnt + 1, sum + G[u][i]);
		}
	}
	vis[u] = 0;
}
int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= n; j++){
			scanf("%d", &G[i][j]);
		}
	}
	printf("%d", ans);
	return 0;
} 
```

## 广度优先搜索

#### bfs的过程

1. 初始时把起始点放到队列中，并标记起点访问。
2. 如果队列不为空，取队首元素x，标记访问.
3. 将x的所有未访问相邻点放入队列中
4. 重复以上过程，直到队列为空。

#### 一维坐标移动

#### 密码

#include<bits/stdc++.h>
using namespace std;
struct node{
	int num[4], step;
}first, last;
int vis[11][11][11][11];
void bfs(){
	int i;
	node a, next;
	a = first;
	a.step = 0;
	q.push(a);
	vis[a.num[0]][a.num[1]][a.num[2]][a.num[3]] = 1;
	while(!q.empty()){
		a = q.front();
		q.pop();
		// bfs
		if(a.num[0] == last.num[0] && a.num[1] == last.num[1] && a.num[2] == last.num[2] && a.num[3] == last.num[3]){
			printf("%d\n", a.step);
		}
		for(i = 0; i < 4; i++){
			next = a;
			next.num[i]++;
			if(next.num[i] == 10){
				next.num[i] = 1;
			}
			if(!vis[next.num[0]][next.num[1]][next.num[2]][next.num[3]]){
				vis[next.num[0]][next.num[1]][next.num[2]][next.num[3]] = 1;
				next.step++;
				q.push(next);
			}
		}
		for(i = 0; i < 4; i++){
			next = a;
			next.num[i]--;
			if(next.num[i] == 0){
				next.num[i] = 9;
			}
			if(!vis[next.num[0]][next.num[1]][next.num[2]][next.num[3]]){
				vis[next.num[0]][next.num[1]][next.num[2]][next.num[3]] = 1;
				next.step++;
				q.push(next);
			}
		}
		for(i = 0; i < 3; i++){
			next = a;
			next.num[i] = a.num[i + 1];
			next.num[i + 1] = a.num[i];
			if(!vis[next.num[0]][next.num[1]][next.num[2]][next.num[3]]){
				vis[next.num[0]][next.num[1]][next.num[2]][next.num[3]] = 1; // 先标记后放入 
				next.step++;
				q.push(next);
			}
		}
	}
}
int main(){
	int i, j, t;
	char s1[10], s2[10];
	scanf("%s%s", s1, s2);
	for(i = 0; i < 4; i++){
		first.num[i] = s1[i] - '0';
		last.num[i] = s2[i] - '0';
	}
	bfs();
	return 0;
} 

#include <bits/stdc++.h>
using namespace std;
queue<pair<int, int>> q;
bool vis[5005];
int main(){
	int n, A, B, now, step;
	scanf("%d%d%d", &n, &A, &B);
	q.push(make_pair(A, 0));
	vis[A] = true;
	while(!q.empty()){
		now = q.front().first;
		step = q.front().second;
		q.pop();
		if(now == B){
			printf("%d\n", step);
			break;
		}
		if(now + 1 <= n && !vis[now + 1]){
			q.push(make_pair(now + 1, step + 1));
			vis[now + 1] = true;
		}
		if(now - 1 >= 0 && !vis[now - 1]){
			q.push(make_pair(now - 1, step + 1));
			vis[now - 1] = true;
		}
		if(now * 2 <= n && !vis[now * 2]){
			q.push(make_pair(now * 2, step + 1));
			vis[now * 2] = true;
		}
	}
	return 0;
} 

## 图与树的基本算法

#### 存储方式

1. 邻接矩阵
```C++
const int maxn = 1000; // 顶点最大数
int G[maxn][maxn];
memset(G, 0, sizeof G);
G[u][v] = 1; 	// 插入一条(u, v)有向边
G[u][v] = G[v][u] = 1; 	// 插入一条(u,v)无向边
```
2. 邻接表
```C++
const int maxn = 1000; // 顶点最大数
vector<int> G[maxn];	// 邻接表，其中G[i]存储i能够达到的点
```
3. 链式前向星
```C++
#include <bits/stdc++.h>
using namespace std;
const int M = 110;	// M为边的数目
int e[M], ne[M], h[M], W[M], idx; // 若不存储权值可以不需要w
int n, m;

void add(int a, int b, int w){	// 模板 
	e[idx] = b;  // idx为边的编号，idx边的终点是e[idx] ;
	W[idx] = w;		// idx边的权值是w[idx] 
	ne[idx] = h[a]; 	// idx边同起点的下一条边的编号是ne[idx] 
	h[a] = idx++; 	// a顶点的第一条边的编号是h[a]
} 

int main(){
	int a, b, c;
	scanf("%d%d", &n, &m);
	memset(h, -1, sizeof h);	// h要初始化为-1
	for(int i = 0; i < m; i++){
		scanf("%d%d%d", &a, &b, &c);
		add(a, b, c);
	} 
	// 链式前向星的遍历
	for(int i = 1; i <= n; i++){
		for(int k = h[i]; ~k; k = ne[k]){
			cout << i << " " << e[k] << " "<< w[k] << endl;
		}
	} 
	return 0;
}
```

## 最短路径算法

### 单源最短路问题
在带权图G=(V,E)中，每条边都有一个权值$w_i$，即边的长度。路径的长度为路径上所有边权之和。单源最短路问题是指：求源点s到其余各顶点的最短路径。

1. Dijkstra是解决无负边权的图的单源最短路问题，经常使用邻接表存储。不优化的时间复杂度为$O(V^2+E)$
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1101;
const int M = 10001;
int e[2 * M], ne[2 * M], h[2 * M], W[2 * M];
int dis[N], vis[N]; 	
// dis数组表示从源点到i的最短路的长度
// vis表示 i点是否被标记。 
int n, m, idx;

void insert_edge(int u, int v, int w){
	e[idx] = v;
	W[idx] = w;
	ne[idx] = h[u];
	h[u] = idx++;
}

void insert(int u, int v, int w){
	insert_edge(u, v, w);
	insert_edge(v, u, w);
}

void dijkstra(int u){
	memset(vis, false, sizeof vis);
	memset(dis, 0x3f, sizeof dis);
	dis[u] = 0;
	for(int i = 0; i < n; i++){
		int mind = 1000000000, minj = -1;
		for(int j = 1; j <= n; j++){ // 顶点编号从1开始 
			if(!vis[j] && dis[j] < mind){
				minj = j;
				mind = dis[j];
			}
		}
		if(minj == -1){
			return;
		}
		vis[minj] = true;
		for(int j = h[minj]; ~j; j = ne[j]){ // ~j 等价于j不等于负1 
			int v = e[j], w = W[j];
			if(!vis[v] && dis[v] > dis[minj] + w){
				dis[v] = dis[minj] + w;
			}
		}
	} 
}

int main(){
	memset(h, -1, sizeof h);
	int u, v, w;
	scanf("%d%d", &n, &m);
	while(m--){
		scanf("%d%d%d", &u, &v, &w);
		insert(u, v, w);
	}
	dijkstra(1);
	printf("%d", dis[n]);
	return 0;
}
```

2. SPFA(Shortest Path Faster Algorithm)算法是单源最短路径的一种算法，通常被认为是Bellman-ford算法的队列优化，在代码形式上接近于宽度优先搜索BFS，是一个在实践中非常高效的单源最短路算法。可以运用于有负权图，但不能有负环。复杂度为$O(|V||E|).spfa算法可以判断是否存在负环
	2.1 初始队列中仅包含源点，且源点s的$d_s=0$
	2.2 取出队列头节点u，扫描从顶点u出发的每条边，设每条边的另一端为v，边<u,v>权值为w,若$d_u+w<d_v$，则
		> 将$d_v$修改为$d_u+w$
		> 若v不在队列中，则
	2.3 SPFA判断负环只能用在有向图上，如果一个顶点的入队次数大于n，则存在负环。
```C++
#include <bits/stdc++.h>
using namespace std;
const int M = 1e4 + 9;
const int N = 1e3 + 9;
const int inf = 0x3f3f3f3f;
int e[M << 1], ne[M << 1], h[M << 1], W[M << 1];
int dis[N], vis[N], in[N]; // in数组表示每个数的入队次数
int n, m, idx;

void insert_edge(int u, int v, int w){
	e[idx] = v;
	W[idx] = w;
	ne[idx] = h[u];
	h[u] = idx++;
}

void insert(int u, int v, int w){
	insert_edge(u, v, w);
	insert_edge(v, u, w);
}

void spfa(int u){
	memset(vis, false, sizeof vis);
	vis[u] = true;
	memset(dis, 0x3f, sizeof dis);
	dis[u] = 0;
	queue<int> q;
	q.push(u);
	while(!q.empty()){
		u = q.front(); q.pop();
		vis[u] = false;
		for(int j = h[u]; ~j; j = ne[j]){
			int v = e[j], w = W[j];
			if(dis[v] > dis[u] + w){
				dis[v] = dis[u] + w; 
				if(!vis[v]){
					q.push(v);
					vis[v] = true;
				}
			}
		}
	}
}

bool spfa(int u){	// 判断是否存在负环 
	memset(vis, false, sizeof vis);
	vis[u] = true;
	memset(dis, 0x3f, sizeof dis);
	dis[u] = 0;
	in[u] = 1
	queue<int> q;
	q.push(u);
	while(!q.empty()){
		u = q.front(); q.pop();
		vis[u] = false;
		for(int j = h[u]; ~j; j = ne[j]){
			int v = e[j], w = W[j];
			if(dis[v] > dis[u] + w){ // 松弛操作 
				dis[v] = dis[u] + w; 
				if(!vis[v]){
					q.push(v);
					vis[v] = true;
					++in[v];
					if(in[v] > n) return true;
				}
			}
		}
	}
	return false;
}

int main(){
	memset(h, -1, sizeof h);
	int u, v, w;
	scanf("%d%d", &n, &m);
	while(m--){
		scanf("%d%d%d", &u, &v, &w);
		insert(u, v, w);
	}
	spfa(1);
	printf("%d", dis[n]);
	return 0;
}
```

## 不带权图

### 拓扑排序
对一个有向无环图DAG进行拓扑排序：
1. 选择一个入度为0的顶点并将它输出
2. 删除图中从顶点连出的所有边
3. 重复上面步骤，直到不存在入度为0的顶点为止
注意：循环结束，若输出的顶点数小于图中的顶点数，则表示图中存在回路。
```C++
#include <bits/stdc++.h>
using namespace std;
const int MAX_M = 10000;
const int MAX_N = 200;
struct edge{
	int v, next;
	int len;
}E[MAX_M];
int h[MAX_N], eid, n, m;
int indegree[MAX_N];	// 表示每个节点的入度 

void init(){
	memset(h, -1, sizeof h);
	eid = 0;
	memset(indegree, 0, sizeof indegree);
}

void insert(int u, int v){
	E[eid].v = v;
	E[eid].next = h[u];
	h[u] = eid++;
}

bool topology(){	// 拓扑排序需要使用队列 
	queue<int> q;
	for(int i = 1; i <= n; i++){
		if(!indegree[i]) q.push(i);
	}
	while(!q.empty()){
		int now = h.front(); h.pop();
		for(int i = h[now]; ~i; i = e[i].next){
			int v = E[i].v;
			indegree[v]--;
			if(!indegree[v]) q.push(v);
		}
	}
	for(int i = 1; i <= n; i++) {
		if(indegree[i]) return false; // 不存在拓扑排序 
	}
	return true;
}

int main(){
	scanf("%d%d", &n, &m);
	for(int i = 0; i < m; i++){
		int u, v;
		scanf("%d%d", &u, &v);
		indegree[v]++;
		insert(u, v);
	}
	return 0;
}
```

### 欧拉回路和欧拉路径

#### 判断

若图G中存在这样一条路径，使得它恰好通过G中每条边一次，则称该路径为欧拉路径。若该路径为一个环路，则称为欧拉回路。
1. 具有欧拉回路的图称为欧拉图。欧拉图是所有顶点入度和出度相等的有向弱连通图；没有奇度顶点的连通图
2. 只有欧拉路径但不具有欧拉回路的图称为半欧拉图。半欧拉图性质：有且仅有两个奇度顶点的无向连通图
```C++
// 判断无向图中是否存在欧拉路径和欧拉回路
#include <bits/stdc++.h>
using namespace std;
const int MAX_M = 10000;
const int MAX_N = 200;
struct edge{
	int v, next;
	int len;
}E[MAX_M];
int p[MAX_N], eid, n, m;
int degree[MAX_N];	// 表示每个节点的入度 

void init(){
	memset(p, -1, sizeof p);
	eid = 0;
	memset(degree, 0, sizeof degree);
}

void insert(int u, int v){
	E[eid].v = v;
	E[eid].next = p[u];
	p[u] = eid++;
}

// 判断无向图是否是连通图
int cnt;
bool vis[MAX_N];
void dfs(int u){
	vis[u] = true;
	cnt++;
	for(int i = p[u]; ~i; i = E[i].next){
		int v = E[i].v;
		if(!vis[v]) dfs(v);
	}
}

// 判断欧拉路
void euler(){
	dfs(1);
	if(cnt != n) {
		printf("不是连通图");
		return; 
	}
	int cntodd = 0;
	for(int i = 1; i <= n; i++){
		for(degree[i] % 2) cntodd++;
	}
	if(cntodd == 0) printf("Euler Circuit!\n");
	else if(cntodd == 2) printf("Euler path!\n");
	else printf("不是欧拉半图\n"); 
}
 
int main(){
	init();
	scanf("%d%d", &n, &m);
	for(int i = 0; i < m; i++){
		int u, v;
		scanf("%d%d", &u, &v);
		degree[v]++;
		degree[u]++;
		insert(u, v);
		insert(v, u);
	}
	return 0;
}
```

```C++
// 判断有向图是否有欧拉路和欧拉回路
#include <bits/stdc++.h>
using namespace std;
const int MAX_M = 10000;
const int MAX_N = 200;
struct edge{
	int v, next;
	int len;
}E[MAX_M];
int p[MAX_N], eid, n, m;
int degree[MAX_N];	// 表示每个节点的入度 

void init(){
	memset(p, -1, sizeof p);
	eid = 0;
	memset(degree, 0, sizeof degree);
}

void insert(int u, int v){
	E[eid].v = v;
	E[eid].next = p[u];
	p[u] = eid++;
}

// 判断欧拉路
int euler(){
	int first = 0, last = 0;
	for(int i = 1; i <= n; i++){
		if(degree[i] < -1 || degree[i] > 1) {
			printf("没有欧拉路径");
			return 0;
		}
		else if(degree[i] == -1){
			if(first != 0){
				printf("没有欧拉路径");
				return 0;
			}else{
				first = i;
			}
		}else if(degree[i] == 1){
			if(last != 0){
				printf("没有欧拉路径");
				return 0;
			}else{
				last = i;
			}
		}
	}
	if(first == 0 && last == 0){ // 所有顶点的出度和入度相等 
		printf("It has an euler circuit\n");
		return 1;
	}else if(first != 0 && last != 0){ // 至多有两个顶点的入度和出度绝对值差1（若有两个这样的顶点，则必须其中一个出度大于入度，另一个入度大于出度）,其他顶点的入度与出度相等
		printf("It has an euler path\n");
		return 1;
	}else{
		printf("It has no euler path\n");
		return 0;
	}
}
 
int main(){
	init();
	scanf("%d%d", &n, &m);
	for(int i = 0; i < m; i++){
		int u, v;
		scanf("%d%d", &u, &v);
		degree[v]++;
		degree[u]--;
		insert(u, v);
	}
	return 0;
}
```

#### 求解
找到一个合适的顶点出发进行dfs时。当搜到一个顶点u时：
1. 如果此时没有顶点与该顶点相连，就将u加入路径中并回溯
2. 如果有顶点v与顶点u相连，那么就删除无向边<u, v>，并继续搜索顶点v。将所有和u相邻的顶点遍历完后将u加入到路径中。

## 状态压缩

## 二分法

## 基础数论

### 最大公约数和最小公倍数

$ lcm(a, b) = \frac{ab}{gcd(a, b)} $

欧几里得算法:$gcd(a, b) = gcd(b, a mod b)$
```C++
int gcd(int a, int b){
	return gcd(b, a % b);
}

int lcm(int a, int b){
	return a / gcd(a, b) * b;
}
```
```C++
__gcd(a, b) //头文件<algorithm>中的库函数
```

### Eratosthenes筛选
```C++
for(int i = 2; i <= n; i++) is_prime[i] = true;
for(int i = 2; i * i <= n; i++){
	if(is_prime[i]){
		for(int j = i * i; j <= n; j += i){
			is_prime[j] = false;
		}
	}
}
```

### 欧拉函数

积性函数满足如下性质：$f(mn)=f(m)\times f(n), gcd(m, n)=1$
欧拉函数$\verphi(n)$：小于等于n的所有数中与n互质的数的个数，欧拉函数是积性函数。
```C++
int res = n;
for(int i = 2; i * i <= n; i++){
	if(n % i == 0){
		res = res / i * (i - 1);
		while(n % i == 0) n /= i;
	}
}
if(n > 1) res = res / n * (n - 1);
printf("%d", res);
```

### 矩阵乘法
```C++
#include <bits/stdc++.h>
using namespace std;
struct matrix{
	int a[100][100];
	int n, m
};

matrix matrix_mul(matrix A, matrix B){
	matrix ret;
	ret.n = A.n;
	ret.m = B.m;
	for(int i = 0; i < ret.n; i++){
		for(int j = 0; j < ret.m; j++){
			ret.a[i][j] = 0;
		}
	}
	for(int i = 0; i < ret.n; i++){
		for(int j = 0; j < ret.m; j++){
			for(int k = 0; k < A.m; k++){
				ret.a[i][j] += A.a[i][k] * B.a[k][j];
			} 
		}
	}
	return ret;
}
int main(){
	matrix A, B;
	cin >> A.n >> B.m;
	for(int i = 0; i < A.n; i++){
		for(int j = 0; j < A.m; j++){
			cin >> A.a[i][j];
		}
	}
	cin >> B.n >> B.m;
	for(int i = 0; i < B.n; i++){
		for(int j = 0; j < B.m; j++){
			cin >> B.a[i][j];
		}
	}
	if(A.m != B.n) printf("NO"); return 0;
	else{
		matrix C = matrix_mul(A, B);
	}
	return 0;
}
```

### 矩阵快速幂
```C++
matrix matrix_mul(matrix A, matrix B, int mod){
	matrix ret;
	ret.n = A.n;
	ret.m = B.m;
	
	for(int i = 0; i < ret.n; i++){
		for(int j = 0; j < ret.m; j++){
			ret.a[i][j] = 0;
			for(int k = 0; k < A.m; k++){
				ret.a[i][j] = (ret.a[i][j] + A.a[i][k] * B.a[k][j] % mod) % mod;
			} 
		}
	}
	return ret;
}

matrix unit(int n){
	matrix res;
	for(int i = 0; i < n; i++){
		for(int j = 0; j < n; j++){
			if(i == j) res.a[i][j] = 1;
			else res.a[i][j] = 0;
		}
	}
}

matrix matrix_pow(matrix A, int n, int mod){
	matrix res = unit(), temp = A;
	for(; n; n /= 2){
		if(n & 1){
			res = matrix_mul(res, temp, mod);
		}
		A = matrix_mul(A, A, mod);
	}
	return res;
}
```


## 线段树与树状数组

#### 有一类区间问题可以抽象成以下模型

给定包括n个数的数组$a_1,a_2,a_3,...,a_n$，有两种操作：
1. 查询区间[l, r]最小的数
2. 修改$a_i$为x

### 线段树

对于一个节点，如果其表示的区间为[l, r]。 如果l=r，那么这个是一个叶子节点。否则令$mid=(l + r) /2$, 左儿子对应的区间为[l, mid]，右儿子对应的区间为[mid + 1, r]，这一思想有点类似二分。线段树总共有2 * n节点， 但数组一定是数组大小的四倍。

比如要维护区间最小值问题，我们用一个额外的数组minv记录每个节点对应区间的最小值。对于叶子节点，最小值就是一个数。而对于非叶子节点，区间的最小值就是左儿子的最小值和右儿子最小值中的最小值。

1. 线段树的构建：构建线段树的过程是一个递归的过程，父节点的信息需要用子节点去更新，所以我们需要先递归地构建好左右子树，如下:
```C++
const int maxn = 10010; // maxn表示数的个数
int minv[4 * maxn], a[maxn]; // 4 * maxn表示需要节点编号数
// id表示节点编号，l,r表示左右区间，建树的时间复杂度为O(n)
void build(int id, int l, int r){
	if(l == r){
		minv[id] = a[l];
	}
	int mid = (l + r) >> 1;
	build(id << 1, l, mid);
	build(id << 1 | 1, mid + 1, r);
	minv[id] = min(minv[id << 1], minv[id << 1 | 1]);
}

2. 单点更新：一般我们可以认为线段树的最大深度为$\log n$，所以这条链的最大长度也是$\log n$，所以一次更新的时间复杂度是$O(\log n)$
```C++
// 把x位置的值更改为v
void update(int id, int l, int r, int x, int v){
	if(l == r){
		minv[id] = v;
		return;
	}
	int mid = (l + r) >> 1;
	if(x <= mid){
		update(id << 1, l, mid, x, v);
	}else{
		update(id << 1 | 1, mid, r, x, v);
	}
	minv[id] = min(minv[id << 1], minv[id << 1 | 1]);
}
```

3. 单点查询：和单点更新一样，一直沿着链走到叶子节点就可以了，时间复杂度为
```C++
int query(int id, int l, int r, int x){
	if(l == r){
		return minv[id];
	}	
	int mid = (l + r) >> 1;
	if(x <= mid){
		return query(id << 1, l, mid, x);
		return query(id << 1 | 1, mid + 1, r, x);
	}
}
```

4. 区间查询：对于查询的区间[x,y]我们可以划分为线段树上的节点，这些节点的区间合并起来就可以得到所需的信息。一次区间查询的复杂度也是$O(\log n)$
```C++
int query(int id, int l, int r, int x, int y){
	if(x <= l && r <= y){
		return minv[id];
	}	
	int mid = (l + r) >> 1;
	int ans = INT_MAX;
	if(x <= mid){
		ans = min(ans, query(id << 1, l, mid, x, y));
	}
	if(y > mid){
		ans = min(ans, query(id << 1 | 1, mid + 1, r, x, y));
	}
	return ans;
}
```

5. 完整程序代码
```C++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 110;
int minv[4 * maxn], a[maxn];

void pushup(int id){
	minv[id] = min(minv[id << 1], minv[id << 1 | 1]);
}

void build(int id, int l, int r){
	if(l == r){
		minv[id] = a[l];
		return;
	}
	int mid = (l + r) >> 1;
	build(id << 1, l, mid);
	build(id << 1 | 1, mid + 1, r);
	pushup(id);
}

void update(int id, int l, int r, int x, int v){
	if(l == r){
		minv[id] = v;
	}
	int mid = (l + r) >> 1;
	if(x <= mid){
		update(id << 1, l, mid, x, v);
	}else{
		update(id << 1 | 1, mid + 1, r, x, v);
	}
	pushup(id);
}

int query(int id, int l, int r, int x){
	if(l == r){
		return minv[id];
	}	
	int mid = (l + r) >> 1;
	if(x <= mid){
		return query(id << 1, l, mid, x);
		return query(id << 1 | 1, mid + 1, r, x);
	}
}

int query(int id, int l, int r, int x, int y){
	if(x <= l && r <= y){
		return minv[id];
	}	
	int mid = (l + r) >> 1;
	int ans = INT_MAX;
	if(x <= mid){
		ans = min(ans, query(id << 1, l, mid, x, y));
	}
	if(y > mid){
		ans = min(ans, query(id << 1 | 1, mid + 1, r, x, y));
	}
	return ans;
}

int main(){
	int n; scanf("%d", &n);
	for(int i = 1; i <= n; i++){
		scanf("%d", &a[i]);
	}
	build(1, 1, n);
	int q; scanf("%d", &q);
	for(int i = 0; i < q; i++){
		int x, v;
		scanf("%d%d", &x, &v);
		update(1, 1, n, x, v);
	}
	int p; scanf("%d", &p);
	for(int i = 0; i < p; i++){
		int l, r;
		scanf("%d%d", &l, &r);
		printf("%d\n", query(1, 1, n, l, r));
	}
	return 0;
}
```

### 树状数组

对原始的问题进行修改，改成求和：

给定包括n个数的数组$a_1,a_2,a_3,...,a_n$，有两种操作：
1. 查询区间[l, r]数的和
2. 把$a_i$增加x

树状数组的一个节点表示的区间可以根据节点标号计算出来，对于节点i，其表示的区间为[i - lowbit(i) + 1, i],然后我们再用一个数组C表示每个节点对应的区间内的数的和：

$C_i=a_{i-lowbit(i)+1}+a_{i-lowbit(i)+2}+...+a_i$

1. 查询：要查询区间[l, r]的和值，我们可以先求出[1, r]的和值，然后减去[1, l - 1]的和值。
	1.1 令sum = 0
	1.2 加上区间[x - lowbit(x) + 1, x]的和值
	1.3 然后令x = x - lowbit(x)
	1.4 如果x = 0则退出，否则重复步骤1.1
	1.5 x = x - lowbit(x) 等价于将x的二进制的最后一个1减去。而x的二进制里最多有$\log x$个1
```C++
int C[maxn], n;

int lowerbit(x){
	return x & (-x);
}

int getSum(int x){
	int res = 0;
	for(int i = x; i > 0; i -= lowerbit(x)){
		res += C[i];
	}
	return res;
}
```

2. 更新:如果让$a_x$增加v，那么只有对于包含位置x的区间的和值才会收到影响。而求出哪些区间受影响有一个巧妙的操作，那就是令$x=x+lowerbit(x)$，直到x > n。
```C++
void update(int x, int v){
	for(int i = x; i <= n; i += lowerbit(x)){
		C[i] += v;
	}
}
```

### 差分

看下面的问题：
每次操作把区间[l, r]的数加上v,最后求出数列每个位置的数。

对于差分序列，我们可以实现区间加和单点查询，如果区间加和单点查询混合在一起需要使用树状数组。但是无法做区间查询。

### 例题

#### 斑点🐍
```C++ 
// 线段树也可以求[l, r]区间内的和
void update(int o, int l, int r, int x, int v){ 
	if(x <= l && r <= x){
		c[o] += v;
		return
	}
	int mid = (l + r) >> 1;
	if(x <= mid) update(o << 1, l, mid, x, v);
	else update(o << 1 | 1, mid + 1, r, x, v);
	c[o] = c[o << 1] + c[o << 1 | 1];
}

int query(int o, int l, int r, int x, int y){
	if(x <= l && r <= y) return c[o];
	int mid = (l + r) >> 1;
	int res = 0;
	if(x <= mid) res += (o << 1, l, mid, x, y);
	if(mid < y) res += (o << 1 | 1, mid + 1, r, x, y);
	return res;
}
```

## Tarjan算法

### 求解无向图的割点与桥

割点：若从图中删除节点 x 以及所有与 x 关联的边之后，图将被分成两个或两个以上的不相连的子图，那么称 x 为图的割点。

桥：若从图中删除边 e 之后，图将分裂成两个不相连的子图，那么称 e 为图的桥或割边。

1. 时间戳：时间戳是用来标记图中每个节点在进行深度优先搜索时被访问的时间顺序，当然，你可以理解成一个序号（这个序号由小到大），用 dfn[x] 来表示。
2. 搜索树：在无向图中，我们以某一个节点 x 出发进行深度优先搜索，每一个节点只访问一次，所有被访问过的节点与边构成一棵树，我们可以称之为“无向连通图的搜索树”。
3. 追溯值：追溯值用来表示从当前节点 x 作为搜索树的根节点出发，能够访问到的所有节点中，时间戳最小的值 —— low[x]。那么，我们要限定下什么是“能够访问到的所有节点”？，其需要满足下面的条件之一即可：
	3.1 以 x 为根的搜索树的所有节点
	3.2 通过一条非搜索树上的边，能够到达搜索树的所有节点
4. 在一张无向图中，判断边e(其对应的两个节点分别为u与v是否为桥，需要满足如下条件:dfn[u] < low[v]， 并且u是割点。
```C++
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2000, MAXM = 4000;
struct Edge{
	int to, nxt;
}e[MAXM];
int head[MAXN], cnt, id;
int dfn[MAXN], low[MAXN], cut[MAXN];

void add(int x, int y){
	e[++cnt].to = y;
	e[cnt].nxt = head[x];
	head[x] = cnt;
}

void tarjan(int u, int fa){ // fa代表父亲节点 
	dfn[u] = low[u] = ++id;	// id代表时间戳
	int child = 0;	// child代表子树数目 
	for(int i = head[u]; i; i = e[i].nxt){
		int to = e[i].to;
		if(!dfn[to]){ // 顶点to没有被访问过 
			tarjan(to, fa);
			low[u] = min(low[u], low[to]); // 回溯时更新low数组的值
			if(low[to] >= dfn[u] && u != fa){ 
				cut[u] = 1; // 标记为割点 
			}
			if(u == fa){
				child++; // 字数数目++ 
			}
		}
		low[u] = min(low[u], dfn[to]); 
	}
	if(child >= 2 && u == fa){
		cut[u] = 1; // 根节点也是割点 
	}
}

int main(){
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= m; i++){
		int x, y;
		scanf("%d%d", &x, &y);
		add(x, y), add(y, x);
	}
	for(int i = 1; i <= n; i++){
		if(!dfn[i]) tarjan(i, i);
	}
	for(int i = 1; i <= n; i++){
		if(cut[i]) ans++; // 更新割点数目 
	} 
	return 0;
}
```

### 求解BCC

在一个无向图中，若任意两点间至少存在两条“点不重复”的路径，则说这个图是点双连通的（简称双连通,biconnected）

在一个无向图中，点双连通的极大子图称为点双连通分量（简称双连通分量,Biconnected Component,BCC）

算法：在Tarjan过程中维护一个栈，每次Tarjan到一个结点就将该结点入栈，回溯时若目标结点low值不小于当前结点dfn值就出栈直到目标结点（目标结点也出栈），将出栈结点和当前结点存入BCC

对于每个BCC，它在DFS树中最先被发现的点一定是割点或DFS树的树根
```C++
#include <bits/stdc++.h>
using namespace std;
struct edge{
	int to, pre;
}edges[1000001];
int head[1000001], dfn[1000001], dfs_clock, tot;
int num; 	// BCC数量
int stack[1000001], top;	// 栈
vector<int> bcc[1000001];

int add(int x, int y){
	edges[++tot].to = y;
	edges[tot].pre = head[x];
	head[x] = tot;
}

int tarjan(int u, int fa){
	int lowu = dfn[u] = ++dfs_clock;
	for(int i = head[u]; i; i = edges[i].pre){
		if(!dfn[edges[i].to]){
			stack[++top] = edges[i].to;
			int lowv = targin(edges[i].to, u);
			if(lowv > dfn[u]) // 是割点或者根
			{
				num++;
				while(stack[top] != edges[i].to){
					bcc[num].push_back(stack[top--]);
				}
				bcc[num].push_back(stack[top--]);
				bcc[num].push_back(u);
			} 
		}else if(edges[i].to != fa){
			lowu = min(lowu, dfn[edges[i].to]);
		}
	}
	return lowu;
}

int main(){
	int n, m;
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= m; i++){
		int x, y;
		scanf("%d%d", &x, &y);
		add(x, y); add(y, x);
	}
	for(int i = 1; i <= n; i++){
		if(!dfn[i]){
			stack[top = 1] = i;
			tarjan(i, i);
		}
	}
	for(int i = 1; i <= num; i++){
		printf("BCC#%d: ", i);
		for(int j = 0; j < bcc[i].size(); j++){
			printf("%d ", bcc[i][j]);
		}
		printf("\n");
	}
	return 0;
} 
```

### 求解强连通分量SCC

算法：从一个点出发, 开始遍历并跟新dfn和low, 如果一个点u无路可走了, 那么若dfn[u] == low[u], 就弹出栈顶到u的元素, 这些元素是属于一个强连通分量内的。

```C++

```