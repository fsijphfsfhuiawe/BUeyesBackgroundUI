# 蓝桥杯

## 一、入门级别

### 1.序列求和

###### 题目描述

求1+2+3+...+n的值。  

###### 输入解释

输入包括一个整数n。  

###### 输出解释

输出一行，包括一个整数，表示1+2+3+...+n的值。

###### 数据规模与约定  

1 <= n <= 1,000,000,000。

###### 代码

```C++
#include <iostream>
using namespace std;

int main(){
    // Todo
    long long n; scanf("%lld", &n);
    long long res;
    if(n % 2 == 0) res = (n / 2) * (n + 1);
    else res = (n + 1) / 2 * n;
    printf("%lld\n", res);
    return 0;
}
```

###### 注意点

int的范围为$[-2^{31},2^{31}-1]，即-2,147,483,648到2,147,483,647$

long long的范围为$[-2^{63},2^{63}-1]$

### 2.Fibonacci数列

###### 题目描述

Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。

当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。

###### 输入解释

输入包含一个整数n。

###### 输出解释

输出一行，包含一个整数，表示Fn除以10007的余数。

###### 数据规模与约定

1 <= n <= 1,000,000。

###### 代码

```C++
#include <iostream>
using namespace std;
    
int main(){
    // Todo
    int f1 = 1, f2 = 1, n, res = 1;
    scanf("%d", &n);
    for(int i = 3; i <= n; i++){
        res = (f1 + f2) % 10007;
        f1 = f2;
        f2 = res;
    }
    printf("%d\n", res);
    return 0;
}
```

### 3.圆的面积

###### 题目描述

给定圆的半径r，求圆的面积。

###### 输入解释

输入包含一个整数r，表示圆的半径。

###### 输出解释

输出一行，包含一个实数，四舍五入保留小数点后7位，表示圆的面积。

###### 数据规模与约定

1 <= r <= 10000。

###### 代码

```C++
#include <iostream>
#include <math.h>
    
int main(){
    // Todo
    int r; scanf("%d", &r);
    double square = M_PI * r * r;
    printf("%.7f\n", square);
    return 0;
}
```

### 4.十进制转十六进制

###### 题目描述

十六进制数是在程序设计时经常要使用到的一种整数的表示方式。它有0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F共16个符号，分别表示十进制数的0至15。十六进制的计数方法是满16进1，所以十进制数16在十六进制中是10，而十进制的17在十六进制中是11，以此类推，十进制的3在十六进制中是1E。
给出一个非负整数，将它表示成十六进制的形式。

###### 输入解释

输入包含一个非负整数a，表示要转换的数。0<=a<=2147483647

###### 输出解释

输出这个整数的16进制表示

###### 代码

```C++
#include <iostream>
using namespace std;
    
int main(){
    // Todo
    int a; scanf("%d", &a);
    char f[6] = {'A', 'B', 'C', 'D', 'E', 'F'};
    string res;
    while(a >= 16){
        int temp = a % 16;
        if(temp >= 10) res += f[temp - 10];
        else res += '0' + temp;
        a = a / 16;
    }
    if(a >= 10) res += f[a - 10];
    else res += '0' + a;
    for(int i = res.size() - 1; i >= 0; i--) printf("%c", res[i]);
    printf("\n");
    return 0;
}
```

###### 注意点：

注意这里的整数转化为字符的方法

### 5.闰年判断

###### 题目描述

给定一个年份，判断这一年是不是闰年。

当以下情况之一满足时，这一年是闰年：

1. 年份是4的倍数而不是100的倍数；

2. 年份是400的倍数。

其他的年份都不是闰年。

###### 输入解释

输入包含一个整数y，表示当前的年份。

###### 输出解释

输出一行，如果给定的年份是闰年，则输出yes，否则输出no。

###### 数据规模与约定

1990 <= y <= 2050。

###### 代码

```C++
#include <iostream>
using namespace std;
    
int main(){
    // Todo
    int y; scanf("%d", &y);
    if((y % 4 == 0 && y % 100 != 0) || y % 400 == 0) printf("yes\n");
    else printf("no\n");
    return 0;
}
```

### 6.01字符串

###### 题目描述

对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。请按从小到大的顺序输出这32种01串。

###### 输出解释

输出32行，按从小到大的顺序每行一个长度为5的01串。

###### 代码

```C++
#include <iostream>
#include <bitset>
using namespace std;

int main(){
    // Todo
    for(int i = 0; i <= 31; i++){
        bitset<5> b(i);
        cout << b << endl;
    }
    return 0;
}
```

###### 注意点

$bitset$的使用可以简便运算。

### 7.字母图形

###### 题目描述

利用字母可以组成一些美丽的图形，下面给出了一个例子：

ABCDEFG

BABCDEF

CBABCDE

DCBABCD

EDCBABC

这是一个5行7列的图形，请找出这个图形的规律，并输出一个n行m列的图形。

###### 输入解释

输入一行，包含两个整数n和m，分别表示你要输出的图形的行数的列数。

###### 输出解释

输出n行，每个m个字符，为你的图形。

###### 数据规模与约定

1 <= n, m <= 26。

###### 代码

```C++
#include <iostream>
using namespace std;
    
int main(){
    // Todo
    int n, m; 
    scanf("%d%d", &n, &m);
    string res = "";
    for(int i = 0; i < m; i++) res += char('A' + i);
    printf("%s\n", res.c_str());
    for(int i = 1; i < n; i++){
        res = char('A' + i) + res.substr(0, res.size() - 1);
        printf("%s\n", res.c_str());
    }

    return 0;
}
```

### 8.数列特征

###### 题目描述

给出n个数，找出这n个数的最大值，最小值，和。

###### 输入解释

第一行为整数n，表示数的个数。

第二行有n个数，为给定的n个数，每个数的绝对值都小于10000。

###### 输出解释

输出三行，每行一个整数。第一行表示这些数中的最大值，第二行表示这些数中的最小值，第三行表示这些数的和。

###### 数据规模与约定

1 <= n <= 10000。

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
    
int main(){
    // Todo
    int n; scanf("%d", &n);
    int maxv = INT_MIN, minv = INT_MAX, sum = 0;
    for(int i = 1; i <= n; i++){
        int temp; scanf("%d", &temp);
        sum += temp;
        maxv = max(maxv, temp);
        minv = min(minv, temp);
    }
    printf("%d\n%d\n%d\n", maxv, minv, sum);
    return 0;
}
```

###### 注意点：

INT_MIN和INT_MAX定义在<limit.h>中

### 9.回文数

###### 题目描述

1221是一个非常特殊的数，它从左边读和从右边读是一样的，编程求所有这样的四位十进制数。

###### 输出解释

按从小到大的顺序输出满足条件的四位十进制数。

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
    
int main(){
    // Todo
    for(int i = 1001; i <= 9999; i++){
        string temp = to_string(i);
        if(temp[0] == temp[3] && temp[1] == temp[2]) printf("%d\n", i);
    }
    return 0;
}
```

###### 注意点：

将整数转化为字符串的函数为to_string(long)

### 10.特殊的回文数

###### 题目描述

123321是一个非常特殊的数，它从左边读和从右边读是一样的。
输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。

###### 输入解释

输入一行，包含一个正整数n。

###### 输出解释

按从小到大的顺序输出满足条件的整数，每个整数占一行。

###### 数据规模和约定

1<=n<=54。

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

int a0, a1, a2, a3, a4, a5, sum, n;
void process1(){
    for(int i = 10001; i <= 99999; i++){
                a0 = i % 10;
                a1 = (i / 10) % 10;
                a2 = (i / 100) % 10;
                a3 = (i / 1000) % 10;
                a4 = (i / 10000) % 10;
                sum = a0 + a1 + a2 + a3 + a4;
                if(sum == n && a0 == a4 && a1 == a3) printf("%d\n", i);
     }    
}

void process2(){
    for(int i = 100001; i <= 999999; i++){
            a0 = i % 10;
            a1 = (i / 10) % 10;
            a2 = (i / 100) % 10;
            a3 = (i / 1000) % 10;
            a4 = (i / 10000) % 10;
            a5 = (i / 100000) % 10;
            sum = a0 + a1 + a2 + a3 + a4 + a5;
            if(sum == n && a0 == a5 && a1 == a4 && a2 == a3) printf("%d\n", i);
    }
}
int main(){
    // Todo
    scanf("%d", &n);

    if(n > 45){
        process2();
    }else{
        process1();
        process2();
    }

    return 0;
}
```

### 11.十六进制转十进制

###### 题目描述

从键盘输入一个不超过8位的正的十六进制数字符串，将它转换为正的十进制数后输出。
注：十六进制数中的10~15分别用大写的英文字母A、B、C、D、E、F表示。

###### 输入解释

十六进制数字符串

###### 输出解释

十进制数

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
    
int main(){
    // Todo
    string s;
    cin >> s;
    long long res = 0;
    for(int i = s.size() - 1; i >= 0; i--){
        if(s[i] <= '9') res += (s[i] - '0') * pow(16, s.size() - i - 1);
        else res += (s[i] - 'A' + 10) * pow(16, s.size() - i - 1);
    }
    printf("%lld\n", res); 
    return 0;
}
```

###### 注意点：

注意数表示用long long

### 12.十六进制转八进制

###### 题目描述

给定n个十六进制正整数，输出它们对应的八进制数。

###### 输入解释

输入的第一行为一个正整数n （1<=n<=10）。
接下来n行，每行一个由0~9、大写字母A~F组成的字符串，表示要转换的十六进制正整数，每个十六进制数长度不超过100000。

###### 输出解释

输出n行，每行为输入对应的八进制正整数。

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
    

int main(){
    // Todo
    int n; scanf("%d", &n);
    string s;
    string f[] = {"0000", "0001", "0010", "0011", 
                  "0100", "0101", "0110", "0111", 
                  "1000", "1001", "1010", "1011",
                  "1100", "1101", "1110", "1111"};
    
    while(n--){
        cin >> s;
        string temp, res;
        int i;
        for(i = 0; i < s.size(); i++){
            if(s[i] <= '9') temp += f[s[i] - '0'];
            else temp += f[s[i] - 'A' + 10];
        }

        for(i = temp.size() - 1; i >= 0; i-= 3){
            int sum = temp[i] - '0';
            if(i >= 2){
                sum += (temp[i - 1] - '0') * 2 + (temp[i - 2] - '0') * 4;
            }else if(i >= 1) sum += (temp[i - 1] - '0') * 2;
            res += to_string(sum);
        }

        for(i = res.size() - 1; i >= 0; i--){
            if(res[i] != '0') break;
        }

        for(; i >= 0; i--) printf("%c", res[i]);
        
        printf("\n");
    }
    return 0;
}
```

###### 注意点：

先将十六进制数转换成某进制数，再由某进制数转换成八进制。

### 13.字符串对比

###### 题目描述

给定两个仅由大写字母或小写字母组成的字符串(长度介于1到10之间)，它们之间的关
系是以下4中情况之一：
1：两个字符串长度不等。比如 Beijing 和 Hebei
2：两个字符串不仅长度相等，而且相应位置上的字符完全一致(区分大小写)，比如 

Beijing 和 Beijing
3：两个字符串长度相等，相应位置上的字符仅在不区分大小写的前提下才能达到完

全一致（也就是说，它并不满足情况2）。比如 beijing 和 BEIjing
4：两个字符串长度相等，但是即使是不区分大小写也不能使这两个字符串一致。比

如 Beijing 和 Nanjing
编程判断输入的两个字符串之间的关系属于这四类中的哪一类，给出所属的类的编号。

###### 输入解释

包括两行，每行都是一个字符串

###### 输出解释

仅有一个数字，表明这两个字符串的关系编号

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
    
int main(){
    // Todo
    char s1[15], s2[15];
    gets(s1);
    gets(s2);
    int len1 = strlen(s1), len2 = strlen(s2);
    if(len1 != len2) printf("1\n");
    else{
        bool case1 = true, case3 = false;
        for(int i = 0; i < len2; i++){
            if(tolower(s1[i]) != tolower(s2[i])){
                case3 = true;
                break;
            }else if(s1[i] != s2[i]){
                case1 = false;
            }
        }
        if(case3) printf("4\n");
        else if(case1) printf("2\n");
        else printf("3\n");
    }
    return 0;
}
```

### 14.分解质因数

###### 题目描述

求出区间$[a,b]$中所有整数的质因数分解。  

###### 输入解释

输入两个整数$a，b$。  

###### 输出解释

每行输出一个数的分解，形如k=$a1*a2*a3.$..(a1<=a2<=a3...，k也是从小到大的)

###### 数据规模和约定

$2\le a\le b\le 10000$​

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

vector<int> v;
string dp[10001];

void init(){
    for(int i = 2; i <= 9997; i++){
        bool flag = true;
        for(int j = 2; j < i; j++){
            if(i % j == 0) {
                flag = false;
                break;
            }
        }
        if(flag) v.push_back(i);
    }
}

void process(){
    dp[1] = "";
    for(int i = 2; i <= 10000; i++){
        string temp;
        int j;
        for(j = 0; j < (int)v.size(); j++){
            if(i % v[j] == 0){
                temp += to_string(v[j]);
                break;
            }
        }
        if(dp[i / v[j]] != "") temp += "*" + dp[i / v[j]];
        dp[i] = temp; 
    }
}

int main(){
    // Todo
    int a, b;
    scanf("%d %d", &a, &b);
    init();
    process();
    for(int i = a; i <= b; i++) printf("%d=%s\n", i, dp[i].c_str());
    return 0;
}
```

### 15.带分数

###### 题目描述

100 可以表示为带分数的形式：100 = 3 + 69258 / 714。

还可以表示为：100 = 82 + 3546 / 197。

注意特征：带分数中，数字1~9分别出现且只出现一次（不包含0）。

类似这样的带分数，100 有 11 种表示法。

###### 输入解释

从标准输入读入一个正整数N (N<1000*1000)

###### 输出解释

程序输出该数字用数码1~9不重复不遗漏地组成带分数表示的全部种数。

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

int sum, n, a[9] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; 

void f()
{
	int i, j, k, sum1=0, sum2, sum3;
	for(i = 0; i < 7; i++)
	{
		sum1 = sum1 * 10 + a[i];
		if(sum1 > n)
			break;
		sum2 = 0;
		for(j = i + 1; j < 8; j++)
		{
			sum2 = sum2 * 10 + a[j];
			sum3 = 0;
			for(k = j + 1; k < 9; k++)
			{ 
				sum3 = sum3 * 10 + a[k];
				if(sum3 > sum2)
					break;
			}
			if(n == (sum1 + sum2 / sum3) && sum2 % sum3 == 0)
				sum++;
		}
	}
}

int main(){
    // Todo
    scanf("%d", &n);
    do{
       f();
    }while(next_permutation(a, a + 9));
    printf("%d\n", sum);
    return 0;
}
```

### 16.错误票据

###### 题目描述

某涉密单位下发了某种票据，并要在年终全部收回。

每张票据有唯一的ID号。全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。 

因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。 

你的任务是通过编程，找出断号的ID和重号的ID。 假设断号不可能发生在最大和最小号。

###### 输入解释

要求程序首先输入一个整数N(N<100)表示后面数据行数。 

接着读入N行数据。

 每行数据长度不等，是用空格分开的若干个（不大于100个）正整数（不大于100000），请注意行内和行末可能有多余的空格，你的程序需要能处理这些空格。

 每个整数代表一个ID号。

###### 输出解释

要求程序输出1行，含两个整数m n，用空格分隔。

其中，m表示断号ID，n表示重号ID

###### 代码

```

```

### 17.数组对乘积和最大

###### 问题描述

给两组数，各n个。请调整每组数的排列顺序，使得两组数据相同下标元素对应相乘，然后相加的和最小。要求程序输出这个最小值。

###### 输入形式

第一行包括一个整数，代表整数的个数。

第二行是第一组数，用空格分开。

第三行是第二组数，用空格分开。

###### 输出形式

输出乘积的和

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){ 
    int n, f[1005], g[1005], sum = 0;
    scanf("%d", &n);
    for(int i = 0; 1 < n; i++) scanf("%d", &f[i]);
    for(int i = 0; i < n; i++) scanf("%d", &g[i]);
    sort(f, f + n);
    sort(g, g + n, greater<int>());
    for(int i = 0; i < n; i++) sum += f[i] * g[i];
    printf("%d\n", sum);
    return 0;
}
```

###### 注意点：排序不等式

若 ![[公式]](https://www.zhihu.com/equation?tex=a_%7B1%7D%5Cleq%7Ba_%7B2%7D%7D%5Cleq...%5Cleq%7Ba_%7Bn%7D%7D%3Bb_%7B1%7D%5Cleq%7Bb_%7B2%7D%7D%5Cleq...%5Cleq%7Bb_%7Bn%7D%7D) 为实数，对于 ![[公式]](https://www.zhihu.com/equation?tex=%EF%BC%88a_%7B1%7D%2Ca_%7B2%7D%2C...%2Ca_%7Bn%7D%29)
的任何轮换 ![[公式]](https://www.zhihu.com/equation?tex=%28x_%7B1%7D%2Cx_%7B2%7D%2C...%2Cx_%7Bn%7D%29) ,都有下列不等式：

![[公式]](https://www.zhihu.com/equation?tex=a_%7B1%7Db_%7B1%7D%2Ba_%7B2%7Db_%7B2%7D%2B...%2Ba_%7Bn%7Db_%7Bn%7D%5Cgeq%7Bx_%7B1%7Db_%7B1%7D%2Bx_%7B2%7Db_%7B2%7D%2B...%2Bx_%7Bn%7Db_%7Bn%7D%7D%5Cgeq%7Ba_%7Bn%7Db_%7B1%7D%2Ba_%7Bn-1%7Db_%7B2%7D%2B...%2Ba_%7B1%7Db_%7Bn%7D%7D+) 

其中， ![[公式]](https://www.zhihu.com/equation?tex=a_%7B1%7Db_%7B1%7D%2Ba_%7B2%7Db_%7B2%7D%2B...%2Ba_%7Bn%7Db_%7Bn%7D) 称正序和

推论：若 ![[公式]](https://www.zhihu.com/equation?tex=a_%7B1%7D%2Ca_%7B2%7D%2C...%2Ca_%7Bn%7D) 为实数，设 ![[公式]](https://www.zhihu.com/equation?tex=%28x_%7B1%7D%2Cx_%7B2%7D%2C...%2Cx_%7Bn%7D%29) 为 ![[公式]](https://www.zhihu.com/equation?tex=%EF%BC%88a_%7B1%7D%2Ca_%7B2%7D%2C...%2Ca_%7Bn%7D%EF%BC%89)

的一个排序，则：

![[公式]](https://www.zhihu.com/equation?tex=a_%7B1%7D%5E2%2Ba_%7B2%7D%5E2%2B...%2Ba_%7Bn%7D%5E2%5Cgeq%7Ba_%7B1%7Dx_%7B1%7D%2Ba_%7B2%7Dx_%7B2%7D%2B...%2Ba_%7Bn%7Dx_%7Bn%7D%7D)

### 18.找两个数乘积最大

###### 问题描述

输入一串整数，找出两个数使其乘积最大。

###### 输入形式

一行输入n,代表一共有n个整数的个数。

第二行是这一串整数，用空格分开。

###### 输出形式

N M，其中N代表可能的组合（相同的为一种可能，如果有3个30 ，那么30*30=900只能是一种） M代表乘积结果

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n, f[1005], res, ans = 1;
    scanf("%d", &n);
    for(int i = 0; i < n; i++) scanf("%d", &f[i]);
    sort(f, f + n);
    if(f[0] * f[1] == f[n - 1] * f[n - 2] && f[0] != f[n - 2]) ans = 2;
    res = max(f[0] * f[1], f[n - 1] * f[n - 2]);
    printf("%d %d", ans, res);
    return 0;
}
```

### 19.最优灌溉

###### 问题描述

雷雷承包了很多片麦田，为了灌溉这些麦田，雷雷在第一个麦田挖了一口很深的水井，所有的麦田都从这口井来引水灌溉。为了灌溉，雷雷需要建立一些水渠，以连接水井和麦田，雷雷也可以利用部分麦田作为“中转站”，利用水渠连接不同的麦田，这样只要一片麦田能被灌溉，则与其连接的麦田也能被灌溉。 
现在雷雷知道哪些麦田之间可以建设水渠和建设每个水渠所需要的费用（注意不是所有麦田之间都可以建立水渠）。请问灌溉所有麦田最少需要多少费用来修建水渠。

###### 输入形式

输入的第一行包含两个正整数n, m，分别表示麦田的片数和雷雷可以建立的水渠的数量。麦田使用1, 2, 3, ……依次标号。 
接下来m行，每行包含三个整数ai, bi, ci，表示第ai片麦田与第bi片麦田之间可以建立一条水渠，所需要的费用为ci。

###### 输出形式

输出一行，包含一个整数，表示灌溉所有麦田所需要的最小费用。 

###### 评测用例规模与约定

前20%的评测用例满足：n≤5。 
前40%的评测用例满足：n≤20。 
前60%的评测用例满足：n≤100。 
所有评测用例都满足：1≤n≤1000，1≤m≤100,000，1≤ci≤10,000。 

###### 代码

```C++
#include<bits/stdc++.h>
using namespace std;

const int maxx = 100010;
int n, m, ans, tot, father[maxx];

struct node{
	int u, v, w;
}e[maxx];

int find(int x){ 
	if(x != father[x]) father[x] = find(father[x]);
	return father[x];
}

void unionn(int a,int b){
	int fa = find(a);
	int fb = find(b);
	father[fa] = fb;
}

bool cmp(const node &a, const node &b){
	return a.w < b.w;
}

int main(){
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= m; i++) scanf("%d%d%d", &e[i].u, &e[i].v, &e[i].w);
	for(int i = 1; i <= n; i++) father[i] = i;
	sort(e + 1, e + m + 1, cmp);
	for(int i = 1; i <= m; i++){
		if(find(e[i].u) != find(e[i].v)){
			unionn(e[i].u, e[i].v);
			tot++;
			ans += e[i].w;
		}
		if(tot == n - 1) break;
	}
    printf("%d\n", ans);
	return 0;
}
```

###### 注意点：并查集的使用（Krustal算法）

### 20.化学方程式

###### 问题描述

化学方程式，也称为化学反应方程式，是用化学式表示化学反应的式子。给出一组化学方程式，请你编写程序判断每个方程式是否配平（也就是方程式中等号左右两边的元素种类和对应的原子个数是否相同）。
本题给出的化学方程式由大小写字母、数字和符号（包括等号=、加号+、左圆括号和右圆括号）组成，不会出现其他字符（包括空白字符，如空格、制表符等），化学方程式的格式与化学课本中的形式基本相同（化学式中表示元素原子个数的下标用正常文本，如H2O写成H2O），用自然语言描述如下：

  化学方程式由左右两个表达式组成，中间用一个等号三连接，如2H2+O2=2H2O；
  表达式由若干部分组成，每部分由系数和化学式构成，部分之间用加号+连接，如2H2+O2、2H2O；
  系数是整数或空串，如为空串表示系数为1；
  整数由一个或多个数字构成；
  化学式由若干部分组成，每部分由项和系数构成，部分之间直接连接，如H2O、CO2、Ca(OH)2、Ba3(PO4)2；
  项是元素或用左右圆括号括起来的化学式，如H、Ca、(OH)、(P04)；
  元素可以是一个大写字母，也可以是一个大写字母跟着一个小写字母，如H、O、Ca。

###### 输入形式

从标准输入读入数据。
输入的第一行包含一个正整数n，表示输入的化学方程式个数。
接下来n行，每行是一个符合定义的化学方程式。

###### 输出形式

输出到标准输出。
输出共n行，每行是一个大写字母Y或N，回答输入中相应的化学方程式是否配平。

###### 代码

```C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <stack>

using namespace std;

map<string, int> buff;

struct node {
	string c;
	int n;
	node(string cc, int nn) {
		c = cc, n = nn;
	}
};
//这里是从后向前找的，因为这样统计元素个数比较方便
void mysplit(string x, int sign) {
	int pre = 1, k = 0;
	if (isdigit(x[k])) {
		pre = 0;
		while (isdigit(x[k])) {
			pre = pre * 10 + x[k] - 48;
			++k;
		}
	}
	string element = "";
	stack<int> before;//存储每一层次对应的系数
	//suff是层次对应的系数，tmp是单个或这个层次元素的系数
	int j = x.size() - 1, suff = 1, tmp = 1;
	while (j >= k) {
		if (isdigit(x[j])) {
			int times = 0;
			tmp = 0;
			while (isdigit(x[j])) {
				tmp += (x[j] - 48) * pow(10, times);
				++times, --j;
			}
			++j;
		}
		else if (x[j] == ')') {
			before.push(suff);
			suff *= tmp;
			tmp = 1;
		}
		else if (x[j] == '(') {
			suff = before.top();
			before.pop();
		}
		else if (islower(x[j])) element.insert(element.begin(), x[j]);
		else if (isupper(x[j])) {
			element.insert(element.begin(), x[j]);
			if (sign == 0) buff[element] += tmp * suff * pre;
			else if (sign == 1) buff[element] -= tmp * suff * pre;
			tmp = 1;
			element = "";
		}
		--j;
	}
}

void deal(string part,int sign) {
	vector<string> box;
	string tmp = "";
	for (int i = 0; i < part.size(); ++i) {
		if (part[i] == '+') {
			box.push_back(tmp);
			tmp = "";
		}
		else tmp.push_back(part[i]);
	}
	box.push_back(tmp);
	for (int i = 0; i < box.size(); ++i) mysplit(box[i], sign);
}

int main()
{
	int n;
	cin >> n;
	while (n--) {
		buff.clear();
		string equation;
		cin >> equation;
		int k = 0;
		while (equation[k] != '=') ++k;
		string l = equation.substr(0, k);
		string r = equation.substr(k + 1, equation.size() - k - 1);
		deal(l, 0);
		deal(r, 1);
		map<string, int>::iterator it;
		int sign = 0;
		for (it = buff.begin(); it != buff.end(); ++it) {
			if (it->second != 0) {
				sign = 1;
				break;
			}
		}
		if (sign) cout << "N" << endl;
		else cout << "Y" << endl;
	}
	return 0;
}
```

### 21.高速公路

###### 问题描述

某国有n个城市，为了使得城市间的交通更便利，该国国王打算在城市之间修一些高速公路，由于经费限制，国王打算第一阶段先在部分城市之间修一些单向的高速公路。
现在，大臣们帮国王拟了一个修高速公路的计划。看了计划后，国王发现，有些城市之间可以通过高速公路直接（不经过其他城市）或间接（经过一个或多个其他城市）到达，而有的却不能。如果城市A可以通过高速公路到达城市B，而且城市B也可以通过高速公路到达城市A，则这两个城市被称为便利城市对。
国王想知道，在大臣们给他的计划中，有多少个便利城市对。

###### 输入形式

输入的第一行包含两个整数n, m，分别表示城市和单向高速公路的数量。
接下来m行，每行两个整数a, b，表示城市a有一条单向的高速公路连向城市b。

###### 输出形式

输出一行，包含一个整数，表示便利城市对的数量。

###### 评测用例规模与约定

前30%的评测用例满足1 ≤ n ≤ 100, 1 ≤ m ≤ 1000；
前60%的评测用例满足1 ≤ n ≤ 1000, 1 ≤ m ≤ 10000；
所有评测用例满足1 ≤ n ≤ 10000, 1 ≤ m ≤ 100000。

###### 代码1($Kosaraju$算法)

```C++
#include <bits/stdc++.h>
#define MAXN 10010
#define INF 0x7ffffff
#define ll long long
using namespace std;

int n, m, c[MAXN], scc_num[MAXN], dfn[MAXN], dcnt, scnt;
bool vis[MAXN];
vector<int> G1[MAXN], G2[MAXN];

void dfs1(int x){
    vis[x] = 1;
    for(auto y : G1[x]) {
        if(!vis[y]) dfs1(y);
    }
    dfn[++dcnt] = x;
}

void dfs2(int x){
    c[x] = scnt;
    scc_num[scnt]++;
    for(auto y : G2[x]){
        if(!c[y]) dfs2(y);
    }
}

void kosaraju(){
    for(int i = 1; i <= n; i++){
        if(!vis[i]) dfs1(i); //原图的后序遍历
    }
    for(int i = n; i >= 1; i--){
        if(!c[dfn[i]]) {
            ++scnt;
            dfs2(dfn[i]);
        }
    }
    ll ans = 0;
    for(int i = 1; i <= scnt; i++){
        ans += (ll)scc_num[i] * (scc_num[i] - 1) / 2;
    }
    printf("%d\n", ans);
}

int main(){
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= m; i++){
        int u, v;
        scanf("%d%d", &u, &v);
        G1[u].push_back(v); //原图
        G2[v].push_back(u); //反图
    }
    kosaraju();
    return 0;
}
```

###### 代码2($Tarjan$​算法)

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 10010, M = 100010;
int dfs_num, dfn[N], low[N]i, h[N], stk[N], e[M], ne[M];
int n, m, timestamp, top, idx, ans;
bool in_stk[N];

void Tarjan(int u){
    dfn[u] = low[u] = ++timestamp;
    stk[++top] = u, in_stk[u] = true;
    for(int i = h[u]; ~i; i = ne[i]){
        int j = e[i];
        if(!dfn[j]){
            tarjan(j);
            low[u] = min(low[u], low[j]);
		}else if(in_stk[j]){
            low[u] = min(low[u], dfn[j]);
        }
    }
    if(dfn[u] == low[u]){
        int y, cnt = 0;
        do{
            y = stk[top--];
            in_stk[y] = false;
            cnt++;
        }while(y != u);
        ans += (cnt - 1) * cnt / 2;
    }
}

int main(){
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= m; i++){
        int u, v;
        scanf("%d%d", &u, &v);
        e[idx] = b, ne[idx] = h[a], h[a] = idx++;
    }
    for(int i = 1; i <= n; i++){
        if(!dfn[i]) tarjan(i);
    }
    printf("%d\n", ans);
	return 0;
}
```

###### 注意点：强连通算法的运用($Kosaraju$算法、$tarjan$算法)

连通分量：在无向图中，即为连通子图。

强连通分量：有向图中，尽可能多的若干顶点组成的子图中，这些顶点都是相互可到达的，则这些顶点成为一个强连通分量。

1. $Kosaraju$算法(详见[https://www.cnblogs.com/nullzx/p/6437926.html](https://www.cnblogs.com/nullzx/p/6437926.html)。)：
   - 对原图进行DFS遍历，求得该图得逆后序遍历顺序；
     - DFS的逆后序遍历是指：如果当前顶点未访问，先遍历完与当前顶点相连的且未被访问的所有其它顶点，然后将当前顶点加入栈中，最后栈中从栈顶到栈底的顺序就是我们需要的顶点顺序。
   - 将原图取反，按照第一步取得得遍历顺序对图进行DFS遍历，每次DFS遍历中得结点即属于一个强连通分量。
2. $tarjan$算法(详见http://blog.csdn.net/xinghongduo/article/details/6195337)
   - DFN[]作为这个点搜索的次序编号（时间戳），简单来说就是第几个被搜索到的。每个点的时间戳都不一样
   - LOW[]作为每个点在这颗树中的，最小的子树的根，每次保证最小。每次找到一个新点，这个点LOW[]＝DFN[].
   - 每次一个新节点出现，就进栈，如果这个点有出度就继续往下找。直到找到底，每次返回上来都看一看子节点与这个节点的LOW值，谁小就取谁，保证最小的子树根。如果找到DFN[]＝＝LOW[]就说明这个节点是这个强连通分量的根节点最后找到强连通分量的节点后，就将这个栈里，比此节点后进来的节点全部出栈，它们就组成一个全新的强连通分量。

### 22.瓷砖铺放

###### 题目描述

有一长度为N(1<=Ｎ<=10)的地板，给定两种不同瓷砖：一种长度为1，另一种长度为2，数目不限。要将这个长度为N的地板铺满，一共有多少种不同的铺法？
　　例如，长度为4的地面一共有如下5种铺法：
　　4=1+1+1+1
　　4=2+1+1
　　4=1+2+1
　　4=1+1+2
　　4=2+2
　　编程用递归的方法求解上述问题。

###### 输入形式

只有一个数N，代表地板的长度

###### 输出形式

输出一个数，代表所有不同的瓷砖铺放方法的总数

###### 代码

```C++
#include <iostream>
using namespace std;

int main() {
	int N, f[11]; 
	scanf("%d", &N);
	f[1] = 1;
	f[2] = 2;
	for (int i = 3; i <= 10; i++) {
		f[i] = f[i - 2] + f[i - 1];
	}
	printf("%d\n", f[N]);
	return 0;
}
```

### 23.幂方分解

###### 题目描述

任何一个正整数都可以用2的幂次方表示。例如：
　　137=27+23+20
　　同时约定方次用括号来表示，即ab 可表示为a（b）。
　　由此可知，137可表示为：
　　2（7）+2（3）+2（0）
　　进一步：7= 22+2+20 （21用2表示）
　　3=2+20
　　所以最后137可表示为：
　　2（2（2）+2+2（0））+2（2+2（0））+2（0）
　　又如：
　　1315=210 +28 +25 +2+1
　　所以1315最后可表示为：
　　2（2（2+2（0））+2）+2（2（2+2（0）））+2（2（2）+2（0））+2+2（0）

###### 输入形式

输入包含一个正整数N（N<=20000），为要求分解的整数。

###### 输出形式

程序输出包含一行字符串，为符合约定的n的0，2表示（在表示中不能有空格）

###### 代码

```C++
#include <iostream>
#include <string>
#include <algorithm>
#include <bitset>
#include <map>
using namespace std;

map<int, string> mp;

void init() {
	mp[1] = "2(0)"; mp[2] = "2"; mp[3] = "2+2(0)";
	mp[4] = "2(2)"; mp[5] = mp[4] + "+" + mp[1]; mp[6] = "2(2)+2";
	mp[7] = mp[4] + "+" + mp[3]; mp[8] = "2(2+2(0))"; mp[9] = mp[8] + "+" + mp[1];
	mp[10] = mp[8] + "+" + mp[2]; mp[11] = mp[8] + "+" + mp[3]; mp[12] = mp[8] + "+" + mp[4];
	mp[13] = mp[8] + "+" + mp[5]; mp[14] = mp[8] + "+" + mp[6];
}

string process(int N) {
	if (N <= 14) return mp[N];
	string res;
	bitset<15> b(N);
	for (int i = b.size() - 1; i >= 0; i--) {
		if (b[i]) {
			if (i > 1) res += "2(" + mp[i] + ")+";
			else if (i == 1) res += mp[2] + "+";
			else res += mp[1];
		}
	}
	if (res[res.size() - 1] == '+') res = res.substr(0, res.size() - 1);
	return res;
}

int main() {
	int N; scanf("%d", &N);
	init();
	printf("%s\n", process(N).c_str());
	return 0;
}
```

### 24.操作格子

###### 题目描述

有n个格子，从左到右放成一排，编号为1-n。
共有m次操作，有3种操作类型：
1.修改一个格子的权值，
2.求连续一段格子权值和，
3.求连续一段格子的最大值。
对于每个2、3操作输出你所求出的结果。

###### 输入

第一行2个整数n，m。
接下来一行n个整数表示n个格子的初始权值。
接下来m行，每行3个整数p,x,y，p表示操作类型，p=1时表示修改格子x的权值为y，p=2时表示求区间[x,y]内格子权值和，p=3时表示求区间[x,y]内格子最大的权值。

###### 输出

有若干行，行数等于p=2或3的操作总数。
每行1个整数，对应了每个p=2或3操作的结果

###### 数据规模与约定

对于20%的数据n <= 100，m <= 200。

对于50%的数据n <= 5000，m <= 5000。

对于100%的数据1 <= n <= 100000，m <= 100000，0 <= 格子权值 <= 10000。

###### 代码

```C++
#include <iostream>
using namespace std;

int f[100005];

int main() {
	int n, m;
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", &f[i]);
	while (m--) {
		int p, x, y;
		scanf("%d%d%d", &p, &x, &y);
		if (p == 1) f[x] = y;
		else if (p == 2) {
			int sum = 0;
			for (int i = x; i <= y; i++) sum += f[i];
			printf("%d\n", sum);
		}
		else {
			int maxv = 0;
			for (int i = x; i <= y; i++) maxv = max(maxv, f[i]);
			printf("%d\n", maxv);
		}
	}
	return 0;
}
```

### 25.企业奖金发放

###### 题目描述：

企业发放的奖金根据利润提成。利润低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万元到60万元之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%；高于100万元时，超过100万元的部分按1%提成。从键盘输入当月利润，求应发放奖金总数？（保留两位小数）利润的大小在double以内。

###### 代码

```C++
#include <iostream>
using namespace std;

int main() {
	double a;
	cin >> a;
	double b = 0;
	int s[6] = { 1000000, 600000, 400000, 200000, 100000, 0 };
	double t[6] = { 0.01, 0.015, 0.03, 0.05, 0.075, 0.1 };
	for (int i = 0; i < 6; i++) {
		if (a - s[i] >= 0) {
			b += (a - s[i]) * t[i];
			a = s[i];
		}
	}
	printf("%.2f", b);
	return 0;
}
```

### 26.入学考试

###### 题目描述

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”如果你是辰辰，你能完成这个任务吗？

###### 输入形式

　第一行有两个整数T（1 <= T <= 1000）和M（1 <= M <= 100），用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到100之间（包括1和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。

###### 输出形式

包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。

###### 数据规模和约定

对于30%的数据，M <= 10；
对于全部的数据，M <= 100

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

int t, m, dp[m + 1][t + 1];
int main(){
    scanf("%d%d", &t, &m);
    memset(dp, 0, sizeof dp);
    int w[m + 1], v[m + 1], i, j;
    for(i = 1; i <= m; i++){
        scanf("%d%d", &w[i], &v[i]);
    }
    for(i = 1; i <= m + 1; i++){
        for(j = 1; j <= t + 1; j++){
            dp[i][j] = dp[i - 1][j];
            if(j >= w[i] && dp[i][j] < dp[i - 1][j - w[i]] + v[i]){
                dp[i][j] = dp[i - 1][j - w[i]] + v[i];
            }
        }
    }
    printf("%d\n", dp[m][t]);
    return 0;
}
```

### 27.最大最小公倍数

###### 题目描述

已知一个正整数N，问从1~N中任选出三个数，他们的最小公倍数最大可以为多少。

###### 输入形式

输入一个正整数N。

###### 输出形式

输出一个整数，表示你找到的最小公倍数。

###### 数据规模

1 <= N <= 106。

###### 代码

```C++
#include<iostream>
using namespace std;
int main() {
	long long n;//定义范围 因为要选出三个数，所以n>=3;
	long long ans;//用int的话可能会超出范围 
	scanf("%lld", &n);
	if (n == 1) ans = 1;
	if (n == 2) ans = 2;
	if (n == 3) ans = 6;
	if (n % 2 != 0)
	{
		ans = n * (n - 1) * (n - 2);
	}
	else
	{
		if (n % 3)
			ans = n * (n - 1) * (n - 3);
		else
			ans = (n - 1) * (n - 2) * (n - 3);
	}
	printf("%lld\n", ans);
    return 0;
}
```

### 28.一元三次方程求解

###### 题目描述

有形如：$ax^3+bx^2+cx+d=0$ 这样的一个一元三次方程。给出该方程中各项的系数(a，b，c，d 均为实数)，并约定该方程存在三个不同实根(根的范围在-100至100之间)，且根与根之差的绝对值>=1。要求三个实根。

###### 输入形式

四个实数：a, b, c, d

###### 输出形式

由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后2位

###### 代码

```C++ 
#include <bits/stdc++.h>
using namespace std;

int main() {
	double a, b, c, d;
	scanf("%lf%lf%lf%lf", &a, &b, &c, &d);
	double A = b * b - 3 * a * c;
	double B = b * c - 9 * a * d;
	double T = (2 * A * b - 3 * a * B) / (2 * sqrt(A * A * A));
	double theta = acos(T);
	double X1 = (-b - 2 * sqrt(A) * cos(theta / 3)) / (3 * a);
	double X2 = (-b + sqrt(A) * (cos(theta / 3) + sqrt(3) * sin(theta / 3))) / (3 * a);
	double X3 = (-b + sqrt(A) * (cos(theta / 3) - sqrt(3) * sin(theta / 3))) / (3 * a);
	if (X1 > max(X2, X3)) {
		if (X2 > X3) printf("%.2f %.2f %.2f\n", X3, X2, X1);
		else printf("%.2f %.2f %.2f\n", X2, X3, X1);
	}
	else if(X2 > X3){
		if(X1 > X3) printf("%.2f %.2f %.2f\n", X3, X1, X2);
		else printf("%.2f %.2f %.2f\n", X1, X3, X2);
	}
	else {
		if(X2 > X1) printf("%.2f %.2f %.2f\n", X1, X2, X3);
		else printf("%.2f %.2f %.2f\n", X2, X1, X3);
	}
	return 0;
}
```

### 29.$GXXXXX$删除

###### 题目描述

对于多数 RPG 游戏来说，除了剧情就是打怪升级。本题的任务是用最短的时间取得所有战斗的胜利。这些战斗必须按照特定的顺序进行，每打赢一场，都可能会获得一些补药，用来提升力量。本题只有两种补药：“加 1 药”和“乘 2 药”，分别让你的力量值加 1 和乘以 2。 

战斗时间取决于你的力量。每场战斗可以用 6 个参数描述：p1, p2, t1, t2, w1, w2。如果你的力量小于 p1，你将输掉战斗；如果你的力量大于 p2，需要 t2秒赢得战斗；如果力量位于 p1和p2（包括 p1和 p2），战斗时间从 t1线性递减到 t2。比如 p1=50，p2=75，t1=40，t2=15，你的力量为 55，则战斗获胜需要 35 秒。注意，战斗时间可能不是整数。最后两个参数 w1和 w2分别表示战斗胜利后获得的“加 1 药”和“乘 2 药”的数量。注意，你不一定要立刻使用这些补药，可以在需要的时候再用，但不能在战斗中使用补药。 

按顺序给出每场战斗的参数，输出赢得所有战斗所需的最短总时间。战斗必须按顺序进行，且不能跳过任何一场战斗。 

###### 输入形式

输入最多包含 25 组测试数据。每组数据第一行为两个整数 n 和 p（1<=n<=1000, 1<=p<=100），即战斗的场数和你的初始力量值。以下 n 行每行 6 个整数 p1, p2, t1,t2,w1,w2（1<=p1<p2<=100,1<=t2<t1<=100,0<=w1,w2<=10），按顺序给出各场战斗的参数。输入结束标志为n=p=0。

###### 输出形式

对于每组数据，输出最短总时间（单位：秒），保留两位小数。如果无解，输出“Impossible”（不含引号）。

###### 代码

```C++
#include <bits/stdc++.h>
#define imax 1000000005
using namespace std;

int n;
double res;

struct node{
    int p1, p2, t1, t2, w1, w2;
}a[10005];

int cheng(int s){
    return pow(2, s);
}

void dfs(int i, int eng, double time, int sum){
    if(time > res) return;
    eng += a[i].w1;
    int j = 0;
    if(eng < a[i].p1){
        for(j = 1; j <= a[i].w2 + sum; j++){
            eng = eng * 2;
            if(eng >= a[i].p1) break;
        }
        if(eng < a[i].p1) return;
    }
    sum += a[i].w2 - j;
    double ttime;
    if(i == n - 1){
        eng *= cheng(sum);
        if(eng >= a[i].p2) ttime = a[i].t2;
        else ttime = (a[i].t1 - a[i].t2) * (eng - a[i].p1) / (1.0 * (a[i].p1 - a[i].p2)) + a[i].t1;
        if(ttime + time < res) res = time + ttime;
        return;
    }
    if(eng >= a[i].p2) dfs(i + 1, eng, time + a[i].t2, sum);
    else{
		int teng = eng;
        for(int j = 0; j <= sum; j++){
            if(teng >= a[i].p2){
                dfs(i + 1, teng, time + a[i].t2, sum - j);
                break;
			}
            ttime = (a[i].t1 - a[i].t2) * (teng - a[i].p1) / (1.0 * (a[i].p1 - a[i].p2)) + a[i].t1;
            dfs(i + 1, teng, ttime + time, sum - j);
            teng *
        }
    }
}

int main(){
    int enge;
    while(scanf("%d%d", &n, &enge) && n){
        for(int i = 0; i < n; i++){
            scanf("%d%d%d%d%d%d", &a[i].p1, &a[i].p2, &a[i].t1, &a[i].t2, &a[i + 1].w1, &a[i + 1].w2);
        }
        a[0].w1 = a[0].w2 = 0, res = imax;
        dfs(0, enge, 0, 0);
        if(res == imax) printf("Impossible\n");
        else printf(".2lf\n", res);
    }
    return 0;
}
```

### 30.翻硬币

###### 题目描述

小明正在玩一个“翻硬币”的游戏。

桌上放着排成一排的若干硬币。我们用\*表示正面，用 o 表示反面（是小写字母，不是零）。

比如，可能情形是：\*\*oo\*\*\*oooo

如果同时翻转左边的两个硬币，则变为：oooo\*\*\*oooo

现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？

我们约定：把翻动相邻的两个硬币叫做一步操作，那么要求：

###### 输入解释

两行等长的字符串，分别表示初始状态和要达到的目标状态。每行的长度<1000

###### 输出解释

一个整数，表示最小操作步数。

###### 代码

```C++ 
#include <bits/stdc++.h>
using namespace std;

char c1[1005], c2[1005];   
int main(){
    // Todo
    int res = 0;
    gets(c1), gets(c2);
    for(int i = 0; i < strlen(c1); i++){
        if(c1[i] != c2[i]){
            c1[i + 1] = (c1[i + 1] == '*' ? 'o' : '*');
            res++;
        }
    }
    printf("%d\n", res);
    return 0;
}
```

###### 注意：贪心算法

### 31.又见皇后

###### 题目描述：

国际象棋中，皇后能攻击同一横线、同一竖线、同一斜线（45度）的敌人。 众所周知，有一个非常著名的算法问题，是求在一个$n\times n$​的国际象棋棋盘中最多能摆放多少个皇后，使其不能相互攻击。 今天我们暂且不要让问题如此理想化。假设棋盘上有一些障碍物，皇后不能摆在障碍物上，同时也不能穿过障碍物攻击别人。在此条件之下，棋盘上最多又能放多少个皇后？

###### 输入：

输入包含多组数据。 每组数据的第一行是一个整数$n(1≤n≤8)$​​，表示棋盘的边长。之后的n行将描述棋盘，其中’X’表示该单元格有障碍物，’.’则表示没有。$ n=0$表示输入结束。

###### 输出：

对于每组数据，请输出一个整数表示最多能在棋盘上放几个皇后，使它们相互不能攻击。 每个答案占一行。

###### 代码：

```C++ 
#include <bits/stdc++.h>
#define N 10
using namespace std;

int res, n, m, vis[N][N];
char maps[N][N];

bool judge(int x, int y){
    for(int i = y - 1; i >= 0 && maps[x][i] == '.'; i--){
        if(vis[x][i]) return false;
    }
    for(int i = x - 1; i >= 0 && maps[i][y] == '.'; i--){
        if(vis[i][y]) return false;
    }
    for(int i = x - 1, j = y - 1; i >= 0 && maps[i][j] == '.' && j >= 0; i--, j--){
        if(vis[i][j]) return false;
    }
    for(int i = x - 1, j = y + 1; i >= 0 && maps[i][j] == '.' && j < n; i--, j++){
        if(vis[i][j]) return false;
	}
}

void dfs(int pos, int tmp){ //pos显示皇后所在的位置，tmp表示已经摆放的皇后数
    if(pos >= m) return;
    if(res < tmp) res = tmp;
    if(maps[pos / n][pos % n] == '.' && judge(pos / n, pos % n)){
        vis[pos / n][pos % n] = 1;
        dfs(pos + 1, tmp + 1);
        vis[pos / n][pos % n] = 0;
    }
    dfs(pos , tmp);
}

int main(){
    while(scanf("%d", &n), n){
        res = 0;
        memset(vis, 0, sizeof(vis));
        for(int i = 0; i < n; i++){
            scanf("%s", maps[i]);
		}
        m = n * n;
        dfs(0, 0);
        printf("%d\n", res);
    }
    return 0;
}
```

### 32.连号区间数

###### 题目描述

小明这些天一直在思考这样一个奇怪而有趣的问题：

在1~N的某个全排列中有多少个连号区间呢？这里所说的连号区间的定义是：

如果区间[L, R] 里的所有元素（即此排列的第L个到第R个元素）递增排序后能得到一个长度为R-L+1的“连续”数列，则称这个区间连号区间。

当N很小的时候，小明可以很快地算出答案，但是当N变大的时候，问题就不是那么简单了，现在小明需要你的帮助。

###### 输入解释

第一行是一个正整数N (1 <= N <= 50000), 表示全排列的规模。

第二行是N个不同的数字Pi(1 <= Pi <= N)， 表示这N个数字的某一全排列。

###### 输出解释

输出一个整数，表示不同连号区间的数目。

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

int N, P[50005], dp[50005];
int process(int i){
    int res = 1, maxv = P[i], minv = P[i];
    for(int k = i - 1; k >= 1; k--){
        maxv = max(maxv, P[k]);
        minv = min(minv, P[k]);
        if((maxv - minv) == i - k) res++;
    }
    return res;
}
int main(){
    // Todo
    scanf("%d", &N);
    for(int i = 1; i <= N; i++) scanf("%d", &P[i]);
    dp[1] = 1;
    for(int i = 2; i <= N; i++){
        dp[i] = dp[i - 1] + process(i);
    }
    printf("%d\n", dp[N]);
    return 0;
}
```

### 33.买不到的数目

###### 题目描述

小明开了一家糖果店。他别出心裁：把水果糖包成4颗一包和7颗一包的两种。糖果不能拆包卖。
小朋友来买糖的时候，他就用这两种包装来组合。当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。

你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。大于17的任何数字都可以用4和7组合出来。

本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。

###### 输入解释

两个正整数，表示每种包装中糖的颗数(都不多于1000)

###### 输出解释

一个正整数，表示最大不能买到的糖数

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

const int MAX = 1000000;
int a[MAX] = {0};

int main(){
    // Todo
    int n, m, i = 1, j = 1, res;
    scanf("%d%d", &n, &m);
    a[0] = 1;
    for(int i = 1; i <= MAX; i++){
        if(i >= n && a[i - n]) a[i] = 1;
        else if(i >= m && a[i - m]) a[i] = 1;
    }
    for(int i = MAX; i >= 0; i--){
        if(!a[i]) {
            res = i;
            break;
        }
    }
    printf("%d\n", res);
    return 0;
}
```

### 34.小朋友排队

###### 题目描述

n 个小朋友站成一排。现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。
每个小朋友都有一个不高兴的程度。开始的时候，所有小朋友的不高兴程度都是0。
如果某个小朋友第一次被要求交换，则他的不高兴程度增加1，如果第二次要求他交换，则他的不高兴程度增加2（即不高兴程度为3），依次类推。当要求某个小朋友第k次交换时，他的不高兴程度增加k。
请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。
如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。

###### 输入解释

输入的第一行包含一个整数n，表示小朋友的个数。
第二行包含 n 个整数 H1 H2 … Hn，分别表示每个小朋友的身高。

###### 输出解释

输出一行，包含一个整数，表示小朋友的不高兴程度和的最小值。

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

const int MAX = 1000010, N = 100010;
int C1[MAX], C2[MAX], b[MAX], num[MAX];
long long total[N], ans;

int lowerbit(int x){return x & -x;}
void add(int pos, int num, int *C){
    while(pos <= MAX){
        C[pos] += num;
        pos += lowerbit(pos);
    }
}
int sum(int pos, int *C){
    int sum = 0;
    while(pos){
        sum += C[pos];
        pos -= lowerbit(pos);
    }
    return sum;
}
void init(){
    for(int i = 1; i <= N; i++) total[i] = total[i - 1] + i; 
}
int main(){
    int i, n; init();
    scanf("%d", &n);
    for(i = 0; i < n; i++){
        scanf("%d", &num[i]);
        add(num[i] + 1, 1, C1);
        b[i] = i - sum(num[i] + 1, C1) + 1;
    }
    for(i = n - 1; i >= 0; i--){
        add(num[i] + 1, 1, C2);
        b[i] += sum(num[i], C2);
    }
    ans = 0;
    for(i = 0; i < n; i++) ans += total[b[i]];
    printf("%lld\n", ans);
    return 0;
}
```

###### 注意点：

1. 逆序对：**这个数前面比它大的数+后面比它小的数**

2. 树状数组(BIT)：是一个查询和修改复杂度都为log(n)的数据结构。主要用于**查询任意两位之间的所有元素之和，但是每次只能修改一个元素的值**；经过简单修改可以在log(n)的复杂度下进行范围修改，但是这时只能查询其中一个元素的值(如果加入多个辅助数组则可以实现区间修改与区间查询)。

3. 演示：假设数组a[1..n]，那么查询a[1]+...+a[n]的时间是log级别的，而且是一个在线的数据结构，支持随时修改某个元素的值，复杂度也为log级别。

   
   ![img](https://img-blog.csdn.net/20130820135411406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGpkNDMwNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

   令这棵树的结点编号为C1，C2...Cn。令每个结点的值为这棵树的值的总和，则有

   C1 = A1

   C2 = A1 + A2

   C3 = A3

   C4 = A1 + A2 + A3 + A4

   C5 = A5

   C6 = A5 + A6

   C7 = A7

   C8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8

   ...

   C16 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8 + A9 + A10 + A11 + A12 + A13 + A14 + A15 + A16

   很明显有$C_n = A_{(n – 2^k + 1)} + ... + A_n$​(k为n二进制末尾0的个数)

   ```C++
   //求2^k的快捷办法
   int lowerbit(int x){return x & -x;}
   int lowerbit(int x){return x & (x ^ (x - 1))}
   //求Cn的函数
   int C(int n){
       int sum = 0;
       for(int i = n - lowerbit(n) + 1; i <= n; i++) sum += A[i];
   }
   ```

   ```C++
   //求a[n]的和
   int sum(n){
   	int sum = 0;
       while(n){
           sum += C(n);
           n -= lowerbit(n);
       }
       return sum;
   }
   ```

   ```C++
   void modify(int i, int x){
       while(i <= n){
           C(i) += x;
           i += lowerbit(i);
       }
   }
   ```

### 34.1树状数组的模拟题

###### 题目描述：

天文学家经常检查星图，其中星星由平面上的点代表，每个星都有笛卡尔坐标。星星的level定义为不高于并且不在该星星右边的满足条件的星星数目。天文学家想知道星星level的分布。

您要编写一个程序，这些程序将在给定地图上计算每个level的星星的数量。

###### 输入

输入文件的第一行包含多个恒星n（1 <= n <= 15000）。以下n行描述了恒星的坐标（由空格分隔的两个整数x和y，0 <= x，y <= 32000）。平面的一个点只能有一颗星。恒星按Y坐标的升序列出， Y坐标相等时，按照X坐标的升序列出。

###### 输出

输出应包含n行，每行一个数字。第一行输出level=0的恒星数目，第二行输出level=1的恒星数目，最后一行输出level=n-1的恒星数目。

###### 代码

```C++
#include <iostream>
using namespace std;

const int MAXN = 32005;
const int MINN = 15005;
int tree[MAXN], level[MINN];

void add(int k, int num){
    while(k <= MAXN){
        tree[k] += num;
        k += k & -k;
    }
}

int read(int k){ //1 ~ k的区间和
    int sum = 0;
    while(k){
        sum += tree[k];
        k -= k & -k;
    }
    return sum;
}

int main(){
    int n, x, y, i;
    memset(tree, 0, sizeof(tree));
    memset(level, 0, sizeof(level));
    while(scanf("%d", &n) != EOF){
        for(i = 1; i <= n; i++){
            scanf("%d%d", &x, &y);
            int temp = read(x + 1);
            level[temp]++;
            add(x + 1, 1);
        }
        for(i = 0; i < n; i++) printf("%d\n", level[i]);
	}
    return 0;
}
```

35.

###### 注意点：

线段树：线段树就是完全二叉树，一定条件下成为满二叉树。线段树的图的表示

![img](https://img-blog.csdn.net/20180807181644807?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l3dHNfMjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- 线段树的基本操作——建树：

  ```C++
  #define MAX 2333
  int tree[4 * MAX];
  void init(){memset(tree, 0, sizeof(tree))};
  void build(int node, int l, int r){
      if(l == r){ //到达叶子节点，赋值
          scanf("%d", tree[node]);
          return;
      }
      int mid = (l + r) >> 1;
      build(node * 2, l, mid);
      build(node * 2 + 1, mid + 1, r);
      tree[node] = tree[node * 2] + tree[node * 2 + 1];
  }
  ```

- 线段树基本操作——单点修改

  ```C++
  // 单点更新，n为更新值，index为更新点，lr为更新范围
  void update(int n, int index, int l, int r, int node){
      if(l == r){
          tree[node] += n;
          return;
      }
      int mid = (l + r) >> 1;
  	// push_down(node,mid-l+1,r-mid); 若既有点更新又有区间更新，需要这句
      if(index <= mid) update(n, index, l, mid, node * 2);
      else update(n, index, mid + 1, r, node * 2 + 1);
      tree[node] = tree[node * 2] + tree[node * 2 + 1];// 回溯过程，需要将线段树上层数据更新
  }
  ```

- 懒惰标记：可以先对修改的数据进行储存，只有在使用的时候才更新线段树。

  - 修改数据的时候，每次递归到某节点，修改数据以后将数据的变化添加到数组中。
  - 当使用到这个节点的时候，发现对应的懒惰标记存在，那么就应该更新该节点，以及以下的所有节点的数据，方便使用。

  ```C++
  void push_down(int node,int l,int r){
  	if(lz[node]){
  		int mid = (l+r) / 2;
  		lz[node*2] += lz[node];
  		lz[node*2 + 1] += lz[node];
          // 注意线段树的数据更新方式要一致
  		tree[node*2] += 1LL*(mid - l + 1)*lz[node];
  		tree[node*2 + 1] += 1LL*(r - mid)*lz[node];
  		lz[node] = 0;
  	}
  }
  ```

- 线段树基本操作——区间更新：

  ```C++
  // 区间更新，lr为更新范围，LR为线段树范围，add为更新值
  void update_range(int node,int l,int r,int L,int R,int add){
  	if(l <= L && r >= R){
  		lz[node] += 1LL*add;
  		tree[node] += 1LL*(R - L + 1)*add; // 更新方式
  		return;
  	}
  	push_down(node,L,R);
  	int mid = (L+R) / 2;
  	if(mid >= l) update_range(node*2,l,r,L,mid,add);
  	if(mid < r) update_range(node*2 + 1,l,r,mid+1,R,add);
  	tree[node] = tree[node*2] + tree[node*2 + 1];
  }
  ```

  由于懒惰标记，所以很多数据是没有变化的。如果在一次区间更新后就需要调用真实数据，那么应该先向下更新全部数据后再调用。否则得到的数据是未更新的错误数据。这样，我们也能理解单点操作的那一行注释的代码了，其实就是下推懒惰标记。因为只要使用了区间操作，就有可能有懒惰标记产生。所以需要使用push_down()来下推。

- 线段树基本操作——区间查找：

  ```C++
  // 区间查找
  LL query_range(int node,int L,int R,int l,int r){
  	if(l <= L && r >= R) return tree[node];
  	push_down(node,L,R);
  	int mid = (L+R) / 2;
  	LL sum = 0;
  	if(mid >= l) sum += query_range(node*2,L,mid,l,r);
  	if(mid < r) sum += query_range(node*2 + 1,mid+1,R,l,r);
  	return sum;
  }
  ```

  需要一个sum来储存收集到的区间数据，同时最后return。这样在递归完成以后最后返回的就是区间和了。

- 脱离lazy数组

  ```C++
  boolean cleck(int node,int l,int r){
      // 剪枝条件
  }
   
  void update_range(int node, int l, int r, int L, int R) {
      if (L == R) {
          tree[node] = 1; // 更新方式
          return;
      }
      int mid = (L + R) / 2;
      if (mid >= l && cleck(node*2,L,mid)) update_range(node * 2, l, r, L, mid);
      if (mid < r && cleck(node*2+1,mid+1,R)) update_range(node * 2 + 1, l, r, mid + 1, R);
      tree[node] = tree[node * 2] + tree[node * 2 + 1];
  }
  ```

   lazy数组的使用在很大程度将降低了解决问题所耗费的时间，但是也增加了对模板的修改难度。如果我们抛弃lazy数组，直接每次都更新到叶子结点，同时考虑剪枝，速度也并不慢。所以，在区间操作不平衡，同时可以剪枝的情况下，完全可以抛弃lazy数组

- 线段树的模板代码：

  ```C++
  #include<iostream>
  #include<string>
  #define LL long long
  #define MAX 1001
   
  using namespace std;
   
  int tree[MAX]; // 线段树
  int lz[MAX]; // 延迟标记
   
  void init(){
  	memset(tree,0,sizeof(tree));
  	memset(lz,0,sizeof(lz));
  }
  
  // 创建线段树
  void build(int node,int l,int r){
  	if(l == r){
  		cin >> tree[node];
  		return;
  	}
  	int mid = (l+r) / 2;
  	build(node*2, l, mid);
  	build(node*2+1, mid+1, r);
  	tree[node] = tree[node*2] + tree[node*2 + 1];
  }
   
  // 单点更新，n为更新值，index为更新点，lr为更新范围
  void update(int n,int index,int l,int r,int node){
  	if(l == r) {
  		tree[node] = n; // 更新方式，可以自由改动
  		return;
  	}
  	int mid = (l+r) / 2;
  	// push_down(node,mid-l+1,r-mid); 若既有点更新又有区间更新，需要这句话
  	if(index <= mid){
  		update(n,index,l,mid,node*2);
  	}else{
  		update(n,index,mid+1,r,node*2+1);
  	}
  	tree[node] = tree[node*2] + tree[node*2 + 1];
  }
  
  void push_down(int node,int l,int r){
  	if(lz[node]){
  		int mid = (l+r) / 2;
  		lz[node*2] += lz[node];
  		lz[node*2 + 1] += lz[node];
  		tree[node*2] += 1LL*(mid - l + 1)*lz[node];
  		tree[node*2 + 1] += 1LL*(r - mid)*lz[node];
  		lz[node] = 0;
  	}
  }
   
  // 区间更新，lr为更新范围，LR为线段树范围，add为更新值
  void update_range(int node,int l,int r,int L,int R,int add){
  	if(l <= L && r >= R){
  		lz[node] += 1LL*add;
  		tree[node] += 1LL*(R - L + 1)*add; // 更新方式
  		return;
  	}
  	push_down(node,L,R);
  	int mid = (L+R) / 2;
  	if(mid >= l) update_range(node*2,l,r,L,mid,add);
  	if(mid < r) update_range(node*2 + 1,l,r,mid+1,R,add);
  	tree[node] = tree[node*2] + tree[node*2 + 1];
  }
   
  // 区间查找
  LL query_range(int node,int L,int R,int l,int r){
  	if(l <= L && r >= R) return tree[node];
  	push_down(node,L,R);
  	int mid = (L+R) / 2;
  	LL sum = 0;
  	if(mid >= l) sum += query_range(node*2, L, mid, l, r);
  	if(mid < r) sum += query_range(node*2 + 1, mid + 1, R, l, r);
  	return sum;
  }
   
  int main() {
  	init();
  	build(1,1,8);
   
  	system("pause");
  	return 0;
  }
  ```

### 35.公式求值$(java)$

###### 题目描述

　　输入n, m, k，输出下面公式的值。

![img](https://acmore.cc/upload/image/20160303/20160303185245_59790.png)

其中C_n^m是组合数，表示在n个人的集合中选出m个人组成一个集合的方案数。组合数的计算公式如下。
![img](https://acmore.cc/upload/image/20160303/20160303185252_67012.png)

###### 输入解释

　　输入的第一行包含一个整数n；第二行包含一个整数m，第三行包含一个整数k。

###### 输出解释

　　计算上面公式的值，由于答案非常大，请输出这个值除以999101的余数。

###### 代码

```C++

```

###### 数据规模和约定

对于10%的数据，n≤10，k≤3；
对于20%的数据，n≤20，k≤3；
对于30%的数据，n≤1000，k≤5；
对于40%的数据，n≤10^7，k≤10；
对于60%的数据，n≤10^15，k ≤100；
对于70%的数据，n≤10^100，k≤200；
对于80%的数据，n≤10^500，k ≤500；
对于100%的数据，n在十进制下不超过1000位，即1≤n<10^1000，1≤k≤1000，同时0≤m≤n，k≤n。

###### 提示

999101是一个质数；当n位数比较多时，绝大多数情况下答案都是0，但评测的时候会选取一些答案不是0的数据；

###### 思路：

根据二项式定理：
$$
(1+x)^n=\sum^n_{i=0}C^i_nx^i
$$
两边对x求导后再同时乘x得：
$$
nx(1+x)^{n-1}=\sum^n_{i=0}C^i_nix^i
$$
在i次两边对x求导再同时乘x后，令$dp[i][j]$为$x^j(1+x)^{n-j}$​​的系数。
$$
\sum^n_{i=0}C^i_ni^kx^i=\sum^k_{j=0}dp[k][j]x^j(1+x)^{n-j}
$$
最后令x=1得到
$$
\sum^n_{i=0}C^i_ni^k=\sum^k_{j=0}dp[k][j]2^{n-j}
$$
则
$$
\sum^n_{i=0}C^i_nC_n^mi^k=C^m_n\sum^k_{j=0}dp[k][j]2^{n-j}
$$
$Lucas$定义计算$C^m_n$对质数p求模
$$
C_n^m=C_{n\%p}^{m\%p}C^{m/p}_{n/p}\pmod{p}
$$
费马小定理：
$$
a^{p-1}\equiv1\pmod{p}
$$

### 36.危险系数

###### 题目描述

抗日战争时期，冀中平原的地道战曾发挥重要作用。

地道的多个站点间有通道连接，形成了庞大的网络。但也有隐患，当敌人发现了某个站点后，其它站点间可能因此会失去联系。

我们来定义一个危险系数DF(x,y)：

对于两个站点x和y (x != y), 如果能找到一个站点z，当z被敌人破坏后，x和y不连通，那么我们称z为关于x,y的关键点。相应的，对于任意一对站点x和y，危险系数$DF(x,y)$就表示为这两点之间的关键点个数。

本题的任务是：已知网络结构，求两站点之间的危险系数。

###### 输入解释

输入数据第一行包含2个整数n(2 <= n <= 1000), m(0 <= m <= 2000),分别代表站点数，通道数；

接下来m行，每行两个整数 u,v (1 <= u, v <= n; u != v)代表一条通道；

最后1行，两个数u,v，代表询问两点之间的危险系数$DF(u, v)。$

###### 输出解释

一个整数，如果询问的两点不连通则输出-1.

###### 代码1

```C++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 2010;
struct edge{
    int v, next;
}vec[maxn];
int head[maxn], mark[maxn], vis[maxn], way[maxn], tot, n, m, s, e, ans;

void dfs(int id, int x){
    way[id] = x;
    if(x == e){
        ans++;
        for(int i = 0; i <= id; i++){
            mark[way[i]]++;//标记路径中的点出现的次数
            return;
        }
    }else{
        int v;
        for(int i = head[x]; i != -1; i = vec[i].next){
            v = vec[i].v;
            if(!vis[v]){
                vis[v] = 1;
                dfs(id + 1, v);
                vis[v] = 0;
            }
        }
	}
}

void add(int u, int v){
    vec[tot].v = v;
    vec[tot].next = head[u];
    head[u] = tot++;
}

int main(){
    scanf("%d%d", &n, &m);
    int a, b;
    memset(head, -1, sizeof(head));
    for(int i = 0; i < m; i++){
        scanf("%d%d", &a, &b);
        add(a, b); add(b, a);
    }
    scanf("%d%d", &s, &e);
    vis[s] = 1;
    dfs(0, s);
    int res = 0;
    for(int i = 1; i <= n; i++){
        if(mark[i] == ans) res++;
    }
    printf("%d\n", res - 2); //减去起点和终点
    return 0;
}
```

###### 代码2

```C++
#include <bits/stdc++.h>
using namespace std;

const int maxe = 2e3 + 5; // 最大边数
const int maxn = 1e3 + 5; // 最大点数
struct Edge{
    int from, to;
    bool destroy = false;
}es[maxe];
bool vis[maxn] = {false};
int n, m, st, en, ans = 0;

bool bfs(int st, int en){
	queue<int> QNode;
    QNode.push(st);
    while(!QNode.empty()){
        int cur_node = QNode.front(); QNode.pop();
        vis[cur_node] = true;
        for(int i = 1; i <= 2 * m; i++){
            if(es[i].from == cur_node && !vis[es[i].to] && !es[i].destroy){
                if(es[i].to == en) return true;
                QNode.push(es[i].to);
                vis[es[i].to] = true;
            }
        }
    }
    return false;
}

int main(){
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= 2 * m; i += 2){
        scanf("%d%d", &es[i].from, &es[i].to);
        es[i + 1].from = es[i].to;
        es[i + 1].to = es[i].from;
    }
    scanf("%d%d", &st, &en);
    if(!bfs(st, en)) printf("-1\n");
    else{
        for(int i = 1; i <= n; i++){
            if(i != st && i != en){
                for(int j = 1; j <= 2 * m; j++){
                    if(es[j].from == i || es[j].to == i)
                        es[j].destroy = true;
                }
                memset(vis, false, sizeof(vis));
                if(bfs(st, en) == false) ans++;
                for(int j = 1; j <= 2 * m; j++)
                    es[j].destroy = false;
            }
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

###### 思路：

求图内两点之间割点数。

dfs完所有路径后，在所有路径中如果一个点在每条路径中都出现，那么他就是割点

### 37.网格寻路

###### 题目描述

X 国的一个网络使用若干条线路连接若干个节点。节点间的通信是双向的。某重要数据包，为了安全起见，必须恰好被转发两次到达目的地。该包可能在任意一个节点产生，我们需要知道该网络中一共有多少种不同的转发路径。

源地址和目标地址可以相同，但中间节点必须不同。

如下图所示的网络。

![img](https://acmore.cc/upload/image/20160304/20160304193000_14431.jpg)
1 -> 2 -> 3 -> 1 是允许的

1 -> 2 -> 1 -> 2 或者 1 -> 2 -> 3 -> 2 都是非法的。

###### 输入解释

输入数据的第一行为两个整数N M，分别表示节点个数和连接线路的条数(1<=N<=10000; 0<=M<=100000)。

接下去有M行，每行为两个整数 u 和 v，表示节点u 和 v 联通(1<=u,v<=N , u!=v)。

输入数据保证任意两点最多只有一条边连接，并且没有自己连自己的边，即不存在重边和自环。

###### 输出解释

输出一个整数，表示满足要求的路径条数。

###### 代码1

```C++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 10010;
vector<int> map[maxn];
int n,m;
int u,v;
int main()
{
    while(scanf("%d%d", &n, &m)!= EOF)
    {
        for(int i = 0; i < m; i++)
        {
            scanf("%d%d", &u, &v);
            map[u].push_back(v); //实现双向连通
            map[v].push_back(u);
        }
        int count = 0;
        for(int i = 1; i <= n; i++) //表示i个点
            for(int j = 0; j < map[i].size(); j++) //map[i]是第一个点，现在找第二个点
                for(int k = 0; k < map[map[i][j]].size(); k++)  //map[i][j]是第二个点，现在找第三个点 
                    if(map[map[i][j]][k] != i) //如果第三个点不等于第一个点，就不构成回路，则继续寻找第四个点
                    {
                        int d = map[map[i][j]][k]; //第三个点
                        for(int z = 0; z < map[d].size(); z++) //找第四个点
                            if(map[i][j] != map[d][z]) count++;
                    }
        printf("%d\n", count);
    }
    return 0;
}
```

###### 代码2

```C++
#include <bits/stdc++.h>
using namespace std;

struct edge{
    int x, y, next; // x, y为始末两点
}edges[20010];
int vexs[10005]; // 点表，值是由此点出发的第一条边
int vexNum = 0, edgeNum = 0, ans = 0, tot = 0;

void Add(int x, int y){
    int head = vexs[x];
    tot++;
    edges[tot].x = x; edges[tot].y = y; edges[tot].next = head;
    vexs[x] = tot;
}
void dfs(int x, int pre, int num){ // x为当前节点， pre为前一个节点
    if(num == 3) {ans++; return;}
    else{
        for(int i = vexs[x]; i; i = edges[i].next){
            int next = edges[i].y;
            if(next != pre) dfs(next, x, num + 1);
        }
    }
}
int main(){
    int x, y, i;
    scanf("%d%d", &vexNum, &edgeNum);
    for(i = 1; i <= edgeNum; i++){
        scanf("%d%d", &x, &y);
        Add(x, y); Add(y, x);
    }
    for(i = 1; i <= vexNum; i++) dfs(i, 0, 0);
    printf("%d\n", ans);
    return 0;
}
```

###### 代码3

```C++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 10007;
int N, M;
long long ans;
bool vis[maxn] = {false};
vector<int> G[maxn];

void dfs(int start, int step, int score){
    if(step == 3){
        for(int i = 0; i < G[start].size(); i++){
            int v = G[start][i];
            if(!vis[v] || v == score) ans++;
		}
        return;
    }else{
        for(int i = 0; i < G[start].size(); i++){
            int v = G[start][i];
            if(!vis[v]){
                vis[v] = true;
                dfs(v, step + 1, score);
                vis[v] = false;
            }
        }
	}

}
int main(){
    scanf("%d%d", &N, &M);
    for(int i = 0; i < M; i++){
        int u, v; scanf("%d%d", &u, &v);
        G[u].push_back(v); G[v].push_back(u);
    }
    for(int i = 1; i < N + 1; i++){
        vis[i] = true;
        dfs(i, 1, i);
        vis[i] = false;
    }
    printf("%d\n", ans);
    return 0;
}
```

### 38.黄金数

###### 问题描述

小明发现一个有趣的现象，对于一个各位数字不相同的四位正整数，重新组合各位数字，用最大值减去最小值得到结果d，对d重复上面过程，经过若干步一定可以得到一个特定的数，他把这个数称为黄金数.输入一个整数m,输出得到该黄金数经过的步数。

###### 输入形式

输入一个四位各位数字不同的正整数

###### 输出形式

步骤数

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

int process(int n){
	int a[4], i = 0, maxv = 0, minv = 0;
	while(n){
		a[i++] = n % 10;
		n /= 10;
	}
	sort(a, a + i);
	for(int j = 0; j < i; j++) {
		minv = minv * 10 + a[j];
		maxv = maxv * 10 + a[i - j - 1];
	}
	return maxv - minv;
}

int main(){
	int n, pre, after, step = 0;
	scanf("%d", &n);
	pre = n; 
	while(true){
		after = process(pre);
		if(pre == after) break;
		step++;
		pre = after;
	}
	printf("%d\n", step);
	return 0;
} 
```

### 39.送礼物

###### 问题描述

给定一个整数数组，依次调出三个数使得这三个数依次减小，输出可能的挑选方法。

例如[13，12，9，10，11] ,结果是[13,12,9],[13,12,10],[13,12,11]。挑选方案等于3.

###### 输入形式

输入两行，第一行为数组中元素的个数，第二行为数组中元素，用逗号分开。

5

13，12，9，10，11

###### 输出形式

 输出挑选方案的总数，题目中的例子3。

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

long long num[10000];
typedef struct V{
	int i, j, k;
	bool operator<(const V &t) const{
		return i < t.i || (i == t.i && j < t.j) || (i == t.i && j == t.j && k < t.k);
	}
}V;
set<V> s;

int main(){
	long long n;
	int begin = 0, j = 0;
	long long res = 0; 
	scanf("%lld", &n);
	string temp; cin >> temp;
	for(int i = 0; i < temp.size(); i++){
		if(temp[i] == ',') {
			string a = temp.substr(begin, i);
			num[j++] = stoi(a);
			begin = i + 1;
		}
	}
	num[j] = stoi(temp.substr(begin, temp.size()));
	for(int i = 0; i <= j; i++){
		V v;
		v.i = num[i];
		for(int k = i + 1; k <= j; k++){
			if(num[i] > num[k]){
				v.k = num[k];
				for(int m = k + 1; m <= j; m++){
					if(num[k] > num[m]) {
						v.k = m;
					}
					if(!s.count(v)){
						res++;
					}
				}
			}
		}
	}
	printf("%lld\n", res);
	return 0;
}
```

### 40.买酱油

###### 问题描述

小明带着*N*元钱去买酱油。酱油10块钱一瓶，商家进行促销，每买3瓶送1瓶，或者每买5瓶送2瓶。请问小明最多可以得到多少瓶酱油。

###### 输入形式

输入的第一行包含一个整数*N*，表示小明可用于买酱油的钱数。*N*是10的整数倍，*N*不超过300。

###### 输出形式

输出一个整数，表示小明最多可以得到多少瓶酱油。

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
	int N, res = 0;
	scanf("%d", &N);
		res = (N / 50) * 7 + ((N - (N / 50) * 50) / 30) * 4 + ((N - (N / 50) * 50) - ((N - (N / 50) * 50) / 30) * 30) / 10;
	printf("%d\n", res);
	return 0;
}
```

### 41.字符串匹配

###### 问题描述

给出一个字符串和多行文字，在这些文字中找到字符串出现的那些行。你的程序还需支持大小写敏感选项：当选项打开时，表示同一个字母的大写和小写看作不同的字符；当选项关闭时，表示同一个字母的大写和小写看作相同的字符。 

###### 输入形式

　　输入的第一行包含一个字符串S，由大小写英文字母组成。 
　　第二行包含一个数字，表示大小写敏感的选项，当数字为0时表示大小写不敏感，当数字为1时表示大小写敏感。 
　　第三行包含一个整数n，表示给出的文字的行数。 
　　接下来n行，每行包含一个字符串，字符串由大小写英文字母组成，不含空格和其他字符。

###### 输出形式

　　输出多行，每行包含一个字符串，按出现的顺序依次给出那些包含了字符串S的行。 

###### 样例输入

　　$Hello $​
　　$1 $​
　　$5 $​
　　$HelloWorld $​
　　$HiHiHelloHiHi $​
　　$GrepIsAGreatTool $​
　　$HELLO $
　　$HELLOisNOTHello $​

###### 样例输出

　　$HelloWorld $​
　　$HiHiHelloHiHi $​
　　$HELLOisNOTHello $

###### 样例说明

　　在上面的样例中，第四个字符串虽然也是$Hello$，但是大小写不正确。如果将输入的第二行改为0，则第四个字符串应该输出。 

###### 用例规模与约定

　　1<=n<=100，每个字符串的长度不超过100。

###### 代码

```C++
#include <iostream>
#include <algorithm>
using namespace std;

int main(){
	string S, temp;
	int m, n;
	cin >> S;
	scanf("%d", &m);
	scanf("%d", &n);
	if (m) {
		for (int i = 0; i < n; i++) {
			cin >> temp;
			if (temp.find(S) != -1) {
				printf("%s\n", temp.c_str());
			}
		}
		
	}
	else {
		for (int i = 0; i < n; i++) {
			cin >> temp;
			string temp2 = temp;
			transform(temp.begin(), temp.end(), temp.begin(), ::tolower);
			transform(S.begin(), S.end(), S.begin(), ::tolower);
			if (temp.find(S) != -1) printf("%s\n", temp2.c_str());
		}
	}
	return 0;
}
```

### 42.拦截导弹

###### 题目描述

​	某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

　　输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

###### 输入形式

一行，为导弹依次飞来的高度

###### 输出形式

两行，分别是最多能拦截的导弹数与要拦截所有导弹最少要配备的系统数

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
int D[1010], Maxhigh[1010], Maxhigh2[1010];

int main(){
    int n, index=0, ans=0, ans2=0;
    while(scanf("%d", &n) == 1) {
        D[index] = n;
        Maxhigh[index] = 1, Maxhigh2[index++] = 1;
    }
    for(int i = 0; i < index; i++){
    	for(int j = 0; j < i; j++) {
        	//小于等于时更新最长非升子序列，大于时更新最长上升子序列
        	if(D[i] <= D[j]) Maxhigh[i] = max(Maxhigh[i], Maxhigh[j] + 1); 
        	else Maxhigh2[i] = max(Maxhigh2[i], Maxhigh2[j] + 1);
      	}
      	ans = max(ans, Maxhigh[i]); //找以哪个点为子序列结束点时序列长度最长
      	ans2 = max(ans2, Maxhigh2[i]);
    }
    printf("%d\n%d\n", ans, ans2);
    return 0;
}
```

### 43.装饰珠

###### 题目描述

在怪物猎人这一款游戏中，玩家可以通过给装备镶嵌不同的装饰珠来获取 相应的技能，以提升自己的战斗能力。

已知猎人身上一共有$ 6 $件装备，每件装备可能有若干个装饰孔，每个装饰孔有各自的等级，可以镶嵌一颗小于等于自身等级的装饰珠 (也可以选择不镶嵌)。

装饰珠有 $M$​种，编号 1 至 $M$，分别对应 $M$​种技能，第$ i$种装饰珠的等级为 $L_i$，只能镶嵌在等级大于等于 $L_i$的装饰孔中。

对第$ i $种技能来说，当装备相应技能的装饰珠数量达到$ K_i$个时，会产生 $W_i(K_i)$​的价值。镶嵌同类技能的数量越多，产生的价值越大，即 $W_i(K_i − 1) < W_i(K_i)$。但每个技能都有上限 $P_i(1 \leq P_i \leq 7)$，当装备的珠子数量超过 $P_i$时，只会产生 $W_i(P_i)$的价值。

对于给定的装备和装饰珠数据，求解如何镶嵌装饰珠，使得$ 6 $件装备能得到的总价值达到最大。

###### 输入描述

输入的第$ 1 $至$ 6 $行，包含$ 6 $件装备的描述。其中第$ i$行的第一个整数$ N_i$表示第 $i$件装备的装饰孔数量。后面紧接着 $N_i$个整数，分别表示该装备上每个装饰孔的等级$ L\ (1 \leq L \leq 4)$。

第$ 7 $行包含一个正整数 $M$，表示装饰珠 (技能) 种类数量。

第$ 8 $至 $M+ 7 $行，每行描述一种装饰珠 (技能) 的情况。每行的前两个整数$ L_j\ (1 \leq L_j \leq 4) $和 $P_j\ (1 \leq P_i \leq 7)$分别表示第$ j$种装饰珠的等级和上限。接下来 $P_j$个整数，其中第$ k$个数表示该装备中装饰珠数量为 $k$时的价值$ W_j(k)$​。

其中，$1 \leq N_i \leq 50, 1 \leq M \leq 10^4, 1 \leq W_j(k) \leq 10^4$。

###### 输出描述

输出一行包含一个整数，表示能够得到的最大价值。

###### 代码

```C++

```

### 44.作物杂交

###### 题目描述

作物杂交是作物栽培中重要的一步。已知有 N种作物 (编号 1 至 N)，第 i种作物从播种到成熟的时间为 $T_i$。作物之间两两可以进行杂交，杂交时间取两种中时间较长的一方。如作物 A 种植时间为 5 天，作物 B 种植时间为 7 天，则 AB 杂交花费的时间为 7 天。作物杂交会产生固定的作物，新产生的作物仍然属于 N种作物中的一种。

初始时，拥有其中 M种作物的种子 (数量无限，可以支持多次杂交)。同时可以进行多个杂交过程。求问对于给定的目标种子，最少需要多少天能够得到。

如存在 4 种作物 ABCD，各自的成熟时间为 5 天、7 天、3 天、8 天。初始拥有 AB 两种作物的种子，目标种子为 D，已知杂交情况为 A × B → C，A × C → D。则最短的杂交过程为：

第 1 天到第 7 天 (作物 B 的时间)，A × B → C。

第 8 天到第 12 天 (作物 A 的时间)，A × C → D。

花费 12 天得到作物 D 的种子。

###### 输入描述

输入的第 1 行包含 4 个整数$ N, M, K, T，N$表示作物种类总数 (编号 1至 N)，M表示初始拥有的作物种子类型数量，K表示可以杂交的方案数，T表示目标种子的编号。

第 2 行包含$ N$个整数，其中第 i个整数表示第 i*i* 种作物的种植时间$ T_i\ (1 \leq T_i \leq 100)$​。

第 3 行包含 $M$个整数，分别表示已拥有的种子类型 $K_j\ (1 \leq K_j \leq M)，K_j$​两两不同。

第 4 至$ K+ 3 $行，每行包含 3 个整数 A, B,C，表示第 A类作物和第 B类作物杂交可以获得第 C*C* 类作物的种子。

其中，$1 \leq N \leq 2000, 2 \leq M \leq N, 1 \leq K \leq 10^5, 1 \leq T \leq N$, 保证目标种子一定可以通过杂交得到。

###### 输出描述

输出一个整数，表示得到目标种子的最短杂交时间。

###### 代码

```C++

```

### 45.饮料换购

###### 题目描述

乐羊羊饮料厂正在举办一次促销优惠活动。乐羊羊 C 型饮料，凭 3 个瓶盖可以再换一瓶 C 型饮料，并且可以一直循环下去(但不允许暂借或赊账)。

请你计算一下，如果小明不浪费瓶盖，尽量地参加活动，那么，对于他初始买入的 n 瓶饮料，最后他一共能喝到多少瓶饮料。

###### 输入描述

输入一个整数 n(0<n<1000)，表示开始购买的饮料数量。

###### 输出描述

输出一个整数，表示实际得到的饮料数

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main()
{
  // 请在此输入您的代码
  int n, m = 0; scanf("%d", &n);
  int res = n;
  while(n--){
    m++;
  	if(m == 3){
    	n++, res++; 
      	m = 0;
    }
  }
  printf("%d", res);
  return 0;
}
```

### 46.跳跃

###### 题目描述

小蓝在一个 n行 m列的方格图中玩一个游戏。

开始时，小蓝站在方格图的左上角，即第 1行第 1列。

小蓝可以在方格图上走动，走动时，如果当前在第 r行第 c列，他不能走到行号比 r小的行，也不能走到列号比 c小的列。同时，他一步走的直线距离不超过 3。

例如，如果当前小蓝在第 3行第 5列，他下一步可以走到第 3行第 6列、第 3行第 7列、第 3行第 8列、第 4行第 5列、第 4行第 6列、第 4行第 7列、第 5行第 5列、第 5行第 6列、第 6行第 5列之一。

小蓝最终要走到第 n行第 m列。

在图中，有的位置有奖励，走上去即可获得，有的位置有惩罚，走上去就要接受惩罚。奖励和惩罚最终抽象成一个权值，奖励为正，惩罚为负。

小蓝希望，从第 1行第 1列走到第 n行第 m列后，总的权值和最大。请问最大是多少？

###### 输入描述

输入的第一行包含两个整数$ n, m$，表示图的大小。

接下来$ n$行，每行$ m$个整数，表示方格图中每个点的权值。

其中，$1 \leq n \leq 100，-10^4 \leq $权值$ \le 10^4$。

###### 输出描述

输出一个整数，表示最大权值和。

###### 代码

```C++

```

### 47.最大降雨量

###### 题目描述

由于沙之国长年干旱，法师小明准备施展自己的一个神秘法术来求雨。

这个法术需要用到他手中的$ 49$张​法术符，上面分别写着 $1$至$ 49 $这$ 49$​个数字。法术一共持续$ 7$周，每天小明都要使用一张法术符，法术符不能重复使用。

每周，小明施展法术产生的能量为这周$ 7$张法术符上数字的中位数。法术 施展完 7周后，求雨将获得成功，降雨量为 $7 $周能量的中位数。

由于干旱太久，小明希望这次求雨的降雨量尽可能大，请问最大值是多少？

###### 代码

```C++

```

### 48.大臣的旅费

###### 题目描述

很久以前，$T$王国空前繁荣。

为了更好地管理国家，王国修建了大量的快速路，用于连接首都和王国内的各大城市。

为节省经费，$T$国的大臣们经过思考，制定了一套优秀的修建方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。

同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。

$J$​是$T$国重要大臣，他巡查于各大城市之间，体察民情。

所以，从一个城市马不停蹄地到另一个城市成了$J$最常做的事情。

他有一个钱袋，用于存放往来城市间的路费。

聪明的$J$发现，如果不在某个城市停下来修整，在连续行进过程中，他所花的路费与他已走过的距离有关，在走第$x$千米到第$x+1$千米这一千米中（$x$是整数），他花费的路费是$x+10$​这么多。也就是说走$1$千米花费$11$，走$2$千米要花费$23$。

$J$大臣想知道：他从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢？

###### 输入格式

输入的第一行包含一个整数$ n$​，表示包括首都在内的$T$王国的城市数。

城市从 1开始依次编号，1号城市为首都。

接下来 n−1行，描述T国的高速路（T国的高速路一定是 n−1条）。

每行三个整数$ P_i,Q_i,D_i$，表示城市 $P_i$和城市 $Q_i$​之间有一条**双向**高速路，长度为$D_i$千米。

###### 输出格式

输出一个整数，表示大臣$J$最多花费的路费是多少。

###### 数据范围

$1≤n≤10^5,$​​
$1≤P_i,Q_i≤n,$​​
$1≤D_i≤1000$​

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

struct Node{
    vector<int> children;
    vector<int> weight;
}N[100005];
long long res = 0;

int process(int node){
    if(N[node].children.empty()) return 0;
    long long maxn1 = 0, maxn2 = 0;
    for (int i = 0; i < (int)N[node].children.size(); i++){
        int temp = N[node].weight[i] + process(N[node].children[i]);
        if(temp >= maxn1){
            maxn2 = maxn1; maxn1 = temp; 
        }else if(temp > maxn2) maxn2 = temp;
    }
    res = max(res, maxn1 + maxn2);
    // printf("%d %d %d\n", maxn1, maxn2, res);
    return maxn1;
}

long long calDistance(long long num){
    long long sum = 0;
    for (int i = 1; i <= num; i++) sum += i + 10;
    return sum;
}

int main()
{
    int n, p, q, d;
    scanf("%d", &n);
    for (int i = 1; i <= n - 1; i++){
        scanf("%d%d%d", &p, &q, &d);
        N[p].children.push_back(q);
        N[p].weight.push_back(d);
    }
    process(1);
    printf("%lld\n", calDistance(res));
    return 0;
}
```

###### 注意点：

树的直径问题，运用树型$DP$

### 49.斐波那契

###### 题目描述：

斐波那契数列大家都非常熟悉。它的定义是：

$f(x)=1(x=1,2)$​

$f(x)=f(x−1)+f(x−2)....(x>2)$

对于给定的整数 n 和 m，我们希望求出$f(1)+f(2)+…+f(n)$的值。

但这个值可能非常大，所以我们把它对$ f(m)$ 取模。

但这个数字依然很大，所以需要再对 p求模。

###### 输入格式

输入包含多组数据。

每组数据占一行，包含三个整数 n,m,p。

###### 输出格式

每组数据输出一个整数，表示答案。

每个数占一行。

###### 数据范围

$0<n,m,p<1018$​
测试数据不超过$100$组

###### 代码

```C++

```

### 50.地宫取宝

###### 题目描述

$X $国王有一个地宫宝库，是 $n×m$个格子的矩阵，每个格子放一件宝贝，每个宝贝贴着价值标签。

地宫的入口在左上角，出口在右下角。

小明被带到地宫的入口，国王要求他只能向右或向下行走。

走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。

当小明走到出口时，如果他手中的宝贝恰好是$ k$件，则这些宝贝就可以送给小明。

请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这$ k$件宝贝。

###### 输入格式

第一行 3个整数，$n,m,k$，含义见题目描述。

接下来 $n$行，每行有 $m $个整数$ C_i$用来描述宝库矩阵每个格子的宝贝价值。

###### 输出格式

输出一个整数，表示正好取 $k$个宝贝的行动方案数。

该数字可能很大，输出它对$ 1000000007$取模的结果。

###### 数据范围

$1≤n,m≤50,$​
$1≤k≤12,$​
$0≤Ci≤12$

###### 代码1(枚举当前状态，然后枚举可能转移到当前状态的状态)

```C++
#include <bits/stdc++.h>
using namespace std;

const int N = 55;
const int M = 15;
const int MOD = 1e9 + 7;

int n, m, c, a[N][N];
//f[i][j][cnt][k]表示：在(i, j)这个点，拿了cnt个物品，这些物品中最大价值的是k
int f[N][N][M][M];

int main(){
    scanf("%d%d%d", &n, &m, &c);
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            scanf("%d", &a[i][j]);
            a[i][j]++;
        }
    }
    //两个边界初始化
    //在起点(1, 1)处
    //如果拿也只能拿a[i][j]这个物品，只有一种方案
    //如果不拿，那就是0个物品，也是一个方案数
    //由于物品价值已经增加了一个偏移量，现在价值的范围是[1, 13]
    //所以价值为0并不代表物品的价值，而是一个边界点
    f[1][1][0][0] = 1;
    f[1][1][1][a[1][1]] = 1;

    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            for(int cnt = 0; cnt <= c; cnt++)
                for(int k = 0; k < M; k++){
                    //不拿物品
                    f[i][j][cnt][k] = (f[i][j][cnt][k] + f[i - 1][j][cnt][k]) % MOD;
                    f[i][j][cnt][k] = (f[i][j][cnt][k] + f[i][j - 1][cnt][k]) % MOD;

                    //可以拿
                    if(cnt > 0 && k == a[i][j]){
                        for(int s = 0; s < a[i][j]; s++){
                            f[i][j][cnt][k] = (f[i][j][cnt][k] + f[i - 1][j][cnt - 1][s]) % MOD;
                            f[i][j][cnt][k] = (f[i][j][cnt][k] + f[i][j - 1][cnt - 1][s]) % MOD;
                        }
                    }
                }

    //最后把在终点(n, m)处拿c个物品的方案数累加
    int res = 0;
    for(int i = 1; i < M; i++)
        res = (res + f[n][m][c][i]) % MOD;

    printf("%d\n", res);

    return 0;
}
```

###### 代码2(枚举当前状态，枚举可能从当前状态达到的状态)

```C++
#include <bits/stdc++.h>
using namespace std;

const int N = 55, M = 15, mod = 1e9 + 7;
int n, m, c, res = 0;
int a[N][N];
int f[N][N][M][M];

int main()
{
    scanf("%d%d%d", &n, &m, &c);
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            scanf("%d", &a[i][j]);
            a[i][j] ++ ;
        }

    // 初始化
    f[1][1][0][0] = f[1][1][1][a[1][1]] = 1;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            for (int cnt = 0; cnt <= c; cnt ++ )
                for (int k = 0; k < M; k ++ )
                    if (f[i][j][cnt][k])
                    {
                        // 不取(i+1,j)的物品，可以直接从(i,j)转移到(i+1,j)
                        f[i + 1][j][cnt][k] = (f[i + 1][j][cnt][k] + f[i][j][cnt][k]) % mod;
                        // 不取(i,j+1)的物品，可以直接从(i,j)转移到(i,j+1)
                        f[i][j + 1][cnt][k] = (f[i][j + 1][cnt][k] + f[i][j][cnt][k]) % mod;

                        // 还可以取物品
                        if (cnt + 1 <= c)
                        {
                            // 取(i+1,j)的物品，从(i,j)转移到(i+1,j)
                            if (a[i + 1][j] > k) f[i + 1][j][cnt + 1][a[i + 1][j]] = (f[i + 1][j][cnt + 1][a[i + 1][j]] + f[i][j][cnt][k]) % mod;
                            // 取(i,j+1)的物品，从(i,j)转移到(i,j+1)
                            if (a[i][j + 1] > k) f[i][j + 1][cnt + 1][a[i][j + 1]] = (f[i][j + 1][cnt + 1][a[i][j + 1]] + f[i][j][cnt][k]) % mod;
                        }
                    }

    for (int i = 1; i < M; i ++ ) res = (res + f[n][m][c][i]) % mod;
    printf("%d\n", res);
    return 0;
}
```

### 51.蚂蚁感冒

###### 题目描述

长$ 10$厘米的细长直杆子上有$ n$只蚂蚁。

它们的头有的朝左，有的朝右。

每只蚂蚁都只能沿着杆子向前爬，速度是$ 1$厘米/秒。

当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。

这些蚂蚁中，有 $1$只蚂蚁感冒了。

并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。

请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。

###### 输入格式

第一行输入一个整数 $n,$ 表示蚂蚁的总数。

接着的一行是$ n$个用空格分开的整数$ Xi, Xi $的绝对值表示蚂蚁离开杆子左边端点的距离。

正值表示头朝右，负值表示头朝左，数据中不会出现$ 0$值，也不会出现两只蚂蚁占用同一位置。

其中，第一个数据代表的蚂蚁感冒了。

#### 输出格式

输出$1$个整数，表示最后感冒蚂蚁的数目。

#### 数据范围

$1<n<50,$​
$0<|X_i|<100$

###### 代码

```C++ 
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n, pivot, left = 0, right = 0;
    scanf("%d", &n);
    scanf("%d", &pivot);

    for (int i = 1; i < n; i++)
    {
        int x;
        scanf("%d", &x);
        //找到感冒蚂蚁左边边且向右走的
        if (abs(x) < abs(pivot) && x > 0) right++;
        //找到感冒蚂蚁右边且向左走的
        if (abs(x) > abs(pivot) && x < 0) left++;
    }
    //特殊情况
    if ((pivot < 0 && right == 0) || pivot > 0 && left == 0) puts("1");
    else printf("%d\n", left + right + 1);

    return 0;
}
```

###### 注意点：

第一只蚂蚁左边的蚂蚁只要朝右边走也可能被感染，这样就很容易得到$ans=right+left+1$。这里$left$表示左边蚂蚁向右走的数量，$right$表示右边蚂蚁向左走的数量，1是指第一只蚂蚁本身。当第一只蚂蚁向左走的时候，如果第一只蚂蚁左边没有向右爬行的蚂蚁，其右边的蚂蚁永远不可能被感染；当第一只蚂蚁向右走的时候，如果第一只蚂蚁右边没有向左爬行的蚂蚁，其左边也永远不可能感染

### 52.垒骰子

###### 题目描述

赌圣$atm$晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。
经过长期观察，$atm$发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！
我们先来规范一下骰子：$1$的对

面是$ 4，2$的对面是$ 5，3$的对面是$6$。
假设有 $m$组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。
$atm$想计算一下有多少种不同的可能的垒骰子方式。
两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。
由于方案数可能过多，请输出模$10^9+7$的结果。
不要小看了 $atm $​​​​的骰子数量哦～

###### 输入格式

第一行两个整数 n m
n表示骰子数目
接下来 m 行，每行两个整数 a b ，表示 a 和 b 数字不能紧贴在一起。

###### 输出格式

一行一个数，表示答案模 $10^9 + 7 $​​的结果。

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

const int N = 6, P = 1e9 + 7;

int n, m, a[N][N];
int op[] = {3, 4, 5, 0, 1, 2};
int f1[] = {4, 4, 4, 4, 4, 4};
bool st[N][N] = {false};

void mul(int c[], int a[], int b[][N]){
    int temp[N] = {0};
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
            temp[i] = (temp[i] + (LL)a[j] * b[j][i]) % P;
            
    memcpy(c, temp, sizeof(temp));
}

void mul(int c[][N], int a[][N], int b[][N]){
    int temp[N][N] = {0};
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
            for (int k = 0; k < N; k ++ )
                temp[i][j] = (temp[i][j] + (LL)a[i][k] * b[k][j]) % P;
                
    memcpy(c, temp, sizeof(temp));
}

int main(){
    scanf("%d%d", &n, &m);
    for (int i = 0; i < m; i++){
        int a, b;
        scanf("%d%d", &a, &b);
        st[a - 1][b - 1] = st[b - 1][a - 1] = true;
    }

    for (int i = 0; i < N; i++){
        for (int j = 0; j < N; j++){
            if (st[j][op[i]]) a[j][i] = 0;
            else a[j][i] = 4;
        }
    }

    n -- ;
    while(n){
        if (n & 1) mul(f1, f1, a);
        mul(a, a, a);
        n >>= 1;
    }

    int res = 0;
    for (int i = 0; i < N; i++){
        res = (res + f1[i]) % P;
    }
    printf("%d",res);

    return 0;
}
```

###### 注意点：

动态规划 + 矩阵快速幂

### 53.波动数列

###### 题目描述

观察这个数列：

1 3 0 2 -1 1 -2 …

这个数列中后一项总是比前一项增加$2$或者减少$3$，**且每一项都为整数**。

栋栋对这种数列很好奇，他想知道长度为 $n$和为$ s$而且后一项总是比前一项增加 a或者减少 b的整数数列可能有多少种呢？

#### 输入格式

共一行，包含四个整数$ n,s,a,b，$含义如前面所述。

#### 输出格式

共一行，包含一个整数，表示满足条件的方案数。

由于这个数很大，请输出方案数除以 $100000007$的余数。

###### 数据范围

$1≤n≤1000,$​​
$−10^9≤s≤10^9,$​​
$1≤a,b≤10^6$

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

const int N = 1010, MOD = 100000007;
int n, s, a, b;
int f[N][N];

int get_mod(int a, int b) {return (a % b + b) % b;}

int main() {
    scanf("%d%d%d%d", &n, &s, &a, &b);
    f[0][0] = 1;
    for (int i = 1; i < n; i++)
        for (int j = 0; j < n; j++)
            f[i][j] = (f[i - 1][get_mod(j - (n - i) * a, n)] + f[i - 1][get_mod(j + (n - i) * b, n)]) % MOD;

    printf("%d", f[n - 1][get_mod(s, n)]);
    return 0;
}
```

###### 分析：

设第一位数为$x$，则第二个数为$x+d_1$，第三个数$x+d_1+d_2\dots$。这里的$d_1,d_2$表示$a$或者$-b$，所以数列为$x,x+d_1,x+d_1+d_2,\dots,x+d_1+d_2+\dots+d_{n-1}$，又因为数列之和为$s$，所以转化为
$$
\begin{split}
n\times x+(n-1)\times d_1+(n-2)\times d_2+\dots+d_{n-1}=s\\
x=\frac{s-[(n-1)\times d_1+(n-2)\times d_2+\dots+d_{n-1}]}{n}
\end{split}
$$
因为$x$是任意整数，所以又转化成：

$s$与$(n-1)\times d_1+(n-2)\times d_2+\dots+d_{n-1}$​模$n$​的余数相同。

闫式$dp$分析法：

1.状态表示：`f[i][j]`表示要选`i`个`a`或者`-b`且余数为`j`的所有集合的数量。

2.状态计算：第`i`个可以选`a`或者`-b`

- 第`i`个选`a`：$(n-1)\times d_1+(n-2)\times d_2+\dots+2\times d_{i-1}+(n-i)a$​​​模$x=j$​​​，则$f[i][j]=f[i-1][(j-(n-i)*a)\%n]$​
- 第`i`个选`-b`：$f[i][j] = f[i - 1][(j + (n - i) * b)\%n]$

### 54.错误票据

###### 题目描述

某涉密单位下发了某种票据，并要在年终全部收回。

每张票据有唯一的ID号。

全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。

因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。

你的任务是通过编程，找出断号的ID和重号的ID。

假设断号不可能发生在最大和最小号。

###### 输入格式

第一行包含整数$ N$，表示后面共有 $N$​ 行数据。

接下来$ N $行，每行包含空格分开的若干个（不大于$100$个）正整数（不大于$100000$），每个整数代表一个$ID$号。

###### 输出格式

要求程序输出1行，含两个整数 $m$,$n$，用空格分隔。

其中，$m$表示断号$ID，n$表示重号$ID$。

###### 数据范围

$1≤N≤100$

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, res1, res2, minv = 100001; 
    scanf("%d", &n);
    set<int> s;
    int temp;
    while (scanf("%d", &temp) == 1){
        if (s.count(temp)) res1 = temp;
        else s.insert(temp);
        minv = min(minv, temp);
    }

    for(auto it = s.begin(); it != s.end(); it++){
        if(*it == minv) continue;
        else if(*it - minv != 1){
            res2 = *it - 1;
            break;
        }
        minv = *it;
    }
    
    printf("%d %d", res2, res1);
    return 0;
}
```

### 55.最小差值

###### 问题描述

　　给定*n*个数，请找出其中相差（差的绝对值）最小的两个数，输出它们的差值的绝对值。

###### 输入形式

　　输入第一行包含一个整数*n*。
　　第二行包含*n*个正整数，相邻整数之间使用一个空格分隔。

###### 输出形式

　　输出一个整数，表示答案。

###### 测试用例与规模

对于所有评测用例，2 ≤ *n* ≤ 1000，每个给定的整数都是不超过10000的正整数。

###### 代码

```C++
#include<bits/stdc++.h>
using namespace std;

int f[1005];

int main(){
	int n, res = 10005;
	scanf("%d", &n);
	for(int i = 0; i < n; i++) scanf("%d", &f[i]);
	sort(f, f + n);
	for(int i = 1; i < n; i++){
		res = min(res, f[i] - f[i - 1]);
	}
	printf("%d", res);
	return 0;
} 
```

### 56.最长单词

###### 题目描述

​		编写一个函数，输入一行字符，将此字符串中最长的单词输出。
　　输入仅一行，多个单词，每个单词间用一个空格隔开。单词仅由小写字母组成。所有单词的长度和不超过100000。如有多个最长单词，输出最先出现的。

###### 代码

```C++
#include <iostream>
using namespace std;
int main() {
    string s;
    string temp;
    int mmax = 0;
    while(cin >> temp) {
        int len = temp.length();
        if(mmax < len) {
            mmax = len;
            s = temp;
        }
    }
    printf("%s", s.c_str()); 
    return 0;
}
```

### 57.矩阵加法

###### 题目描述

给定两个N×M的矩阵，计算其和。其中：N和M大于等于1且小于等于100，矩阵元素的绝对值不超过1000。

###### 输入形式

　输入数据的第一行包含两个整数N、M，表示需要相加的两个矩阵的行数和列数。接下来2*N行每行包含M个数，其中前N行表示第一个矩阵，后N行表示第二个矩阵。

###### 输出形式

你的程序需要输出一个N*M的矩阵，表示两个矩阵相加的结果。

注意，输出中每行的最后不应有多余的空格，否则你的程序有可能被系统认为是Presentation Error

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

int matrix1[102][102];
int main(){
	int N, M;
	scanf("%d%d", &N, &M);
	for(int i = 0; i < N; i++){
		for(int j = 0; j < M; j++){
			scanf("%d", &matrix1[i][j]);
		}
	}
	for(int i = 0; i < N; i++){
		for(int j = 0; j < M; j++){
			int temp; scanf("%d", &temp);
			matrix1[i][j] += temp;
		}
	}
	for(int i = 0; i < N; i++){
		for(int j = 0; j < M; j++){
			if(j != M - 1) printf("%d ", matrix1[i][j]);
			else printf("%d\n", matrix1[i][j]);
		}
	}
	return 0;
} 
```

### 58.质因数

###### 题目描述

将一个正整数N(1<N<32768)分解质因数。例如，输入90，打印出90=2*3*3*5。

###### 代码

```C++
#include <iostream>
using namespace std;

int main() {
	int n;
	scanf("%d", &n);
	printf("%d=", n);
	for(int i = 2; i <= n; i++) {
		while(n != i) {
			if(n % i == 0) {
				printf("%d*", i);
				n /= i;
			}
			else break;
		}
	}
	printf("%d", n);
	return 0;
}
```

### 59.数位之和

###### 问题描述

　　给定一个十进制整数n，输出n的各位数字之和。

###### 输入形式

　　输入一个整数n。

###### 输出形式

　　输出一个整数，表示答案。

###### 评测用例规模与约定

　　所有评测用例满足：0 ≤ n ≤ 1000000000。

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
	string s; cin >> s;
	long long res = 0;
	for(int i = 0; i < s.size(); i++){
		res += s[i] - '0';
	}
	printf("%lld", res);
	return 0;
}
```

### 60.数字统计

###### 问题描述

请统计某个给定范围[L,R]的所有整数中，数字2出现的次数。

###### 输入形式

共1行，为两个正整数L和R，之间用一个空格隔开。(1≤L≤R≤10000)。

###### 输出形式

仅1行，表示数字2出现的次数。

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

int judge(int num){
	int res = 0;
	while(num){
		if(num % 10 == 2) res++;
		num /= 10;
	}
	return res;
}

int main(){
	int L, R, res = 0;
	scanf("%d%d", &L, &R);
	for(int i = L; i <= R; i++){
		res += judge(i);
	}
	printf("%d", res);
	return 0;
} 
```

### 61.计算时间

###### 题目描述

给定一个t，将t秒转化为HH:MM:SS的形式，表示HH小时MM分钟SS秒。HH,MM,SS均是两位数，如果小于10用0补到两位。

###### 输入形式

第一行一个数T(1<=T<=100,000)，表示数据组数。后面每组数据读入一个数t，0<=t<24*60*60。

###### 输出形式

每组数据一行，HH:MM:SS。

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

string process(int t){
	string second, minute, hour;
	if(t % 60 == 0) second = "00";
	else if(t % 60 < 10) second = "0" + to_string(t % 60);
	else second = to_string(t % 60);
	t /= 60;
	if(t % 60 == 0) minute = "00";
	else if(t % 60 < 10) minute = "0" + to_string(t % 60);
	else minute = to_string(t % 60);
	t /= 60;
	if(t % 60 == 0) hour = "00";
	else if(t % 60 < 10) hour = "0" + to_string(t % 60);
	else hour = to_string(t % 60);
	return hour + ":" + minute + ":" + second;
}

int main(){
	int T, t;
	scanf("%d", &T);
	while(T--){
		scanf("%d", &t);
		printf("%s\n", process(t).c_str());
	}
	return 0;
}
```

### 62.判断回文

###### 题目描述

编程判断一个字符串是否是回文，当字符串是回文时，输出字符串：yes!，否则输出字符串：no!。所谓回文即正向与反向的拼写都一样，如adgda。　　

###### 评测用例及规模

长度在100以内，且全为小写字母

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
	string s; cin >> s;
	string s1 = s;
	reverse(s.begin(), s.end());
	if (s1 == s) printf("yes!");
	else printf("no!");
	return 0;
}
```

### 63.逆序对

###### 题目描述

有一颗2n-1个节点的二叉树，它有恰好n个叶子节点，每个节点上写了一个整数。如果将这棵树的所有叶子节点上的数从左到右写下来，便得到一个序列a[1]…a[n]。现在想让这个序列中的逆序对数量最少，但唯一的操作就是选树上一个非叶子节点，将它的左右两颗子树交换。他可以做任意多次这个操作。求在最优方案下，该序列的逆序对数最少有多少。

###### 输入形式

第一行一个整数n (n <= 200000)。
下面每行，一个数x。
如果x=0，表示这个节点非叶子节点，递归地向下读入其左孩子和右孩子的信息，如果x≠0，表示这个节点是叶子节点，权值为x。

###### 输出形式

输出一个整数，表示最少有多少逆序对。

###### 样例输入

```
3
0
0
3
1
2
```

###### 样例输出

```
1
```

###### 代码

```C++
#include<bits/stdc++.h>
#define ForD(i, n) for(int i = n; i ; i--)
#define F (100000007)
#define MAXN (2 * 200000 + 10)
using namespace std;

int n, root = 0, tail = 0;
int q[MAXN], size;
struct node
{
    int fa, ch[2], size, c;
    node():size(0), c(0){ch[0] = ch[1] = fa = 0;}
}a[MAXN];

long long mul(long long a, long long b){return (a * b) % F;}
long long add(long long a, long long b){return (a + b) % F;}
long long sub(long long a, long long b){return (a - b + (a - b) / F * F + F) % F;}
void update(int x){a[x].size = a[a[x].ch[0]].size + a[a[x].ch[1]].size + (a[x].c > 0);}
void pushdown(int x){a[a[x].ch[0]].fa = a[a[x].ch[1]].fa = x;}

void build(int &x)
{
    if (!x) x = ++tail;
    scanf("%d", &a[x].c);
    if (a[x].c == 0)
    {
        build(a[x].ch[0]);
        build(a[x].ch[1]);
        update(x); pushdown(x);
    }else a[x].size = 1;
}

void rotate(int x)
{
    int y = a[x].fa, z = a[y].fa;
    bool p = a[y].ch[0] == x;
    if (z)
    {
        if (a[z].ch[0] == y) a[z].ch[0] = x;
        else a[z].ch[1]=x;
    }
    a[x].fa = z,a[y].fa = x;
    if (a[x].ch[p]) a[a[x].ch[p]].fa = y;
    a[y].ch[p^1] = a[x].ch[p];
    a[x].ch[p] = y;
    update(y);
}

void splay(int x)
{
    while (a[x].fa)
    {
        int y = a[x].fa, z = a[y].fa;
        if (z)
            if ((a[y].ch[0] == x) ^ (a[z].ch[0] == y)) rotate(x);
            else rotate(y);
        rotate(x);
    }
    update(x);
}

void ins(long long &tot, int x, int y)
{
    a[x].size++;
    if (a[y].c <= a[x].c)
    {
        if (a[x].ch[0]) ins(tot, a[x].ch[0], y);
        else a[y].fa = x,splay(a[x].ch[0] = y);
    }
    else
    {
        tot += a[a[x].ch[0]].size + (a[x].c > 0);
        if (a[x].ch[1]) ins(tot, a[x].ch[1],y);
        else a[y].fa = x,splay(a[x].ch[1] = y);
    }
}


void clac(int x,int y)
{
    if (a[y].ch[0]) clac(x, a[y].ch[0]);
    if (a[y].c) q[++size] = y;
    if (a[y].ch[1]) clac(x, a[y].ch[1]);
}

long long merge(bool &lor, int z)
{
    int x = a[z].ch[0],y = a[z].ch[1];
    if (a[x].size < a[y].size) swap(x,y); 
 
    a[x].fa = 0; a[y].fa = 0; q[1] = y;
    size = 0; clac(x,y);
    long long tot = 0;
    ForD(i, size)
    {
        int now = q[i];
        a[now].ch[0] = a[now].ch[1] = a[now].fa=0; a[now].size = 1;
        ins(tot, x, now);
        x = now;
    }
    a[x].fa = z;
    a[z].ch[0] = 0, a[z].ch[1] = x;
    return tot;
}

long long qur(int &x)
{
    if (a[x].c) return 0;
    else
    {
        long long lson = a[a[x].ch[0]].size, rson = a[a[x].ch[1]].size, ls = qur(a[x].ch[0]), rs = qur(a[x].ch[1]);
        bool lor = 0;
        long long ms = merge(lor,x);
        return ls + rs + min(lson * rson - ms, ms);
    }
}

int main()
{
    scanf("%d",&n);
    build(root);
    printf("%lld", qur(root));
    return 0;
}
```

### 64.移动距离

###### 题目描述

X星球居民小区的楼房全是一样的，并且按矩阵样式排列。

其楼房的编号为 $1,2,3…$

当排满一行时，从下一行相邻的楼往反方向排号。

比如：当小区排号宽度为 6 时，开始情形如下：

```
1  2  3  4  5  6
12 11 10 9  8  7
13 14 15 .....
```

我们的问题是：已知了两个楼号 m和 n，需要求出它们之间的最短移动距离（不能斜线方向移动）。

###### 输入格式

输入共一行，包含三个整数 w,m,n，w为排号宽度，m,n为待计算的楼号。

###### 输出格式

输出一个整数，表示 m,n两楼间最短移动距离。

###### 数据范围

$1≤w,m,n≤10000,$

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int w, m, n,x1, y1, x2, y2;
    scanf("%d%d%d", &w, &m, &n);
    x1 = (m - 1) / w, x2 = (n - 1) / w;
    if(x1 % 2) y1 = m % w ? w - m % w + 1 : 1;
    else y1 = m % w ? m % w : w;
    if(x2 % 2) y2 = n % w ? w - n % w + 1 : 1;
    else y2 = n % w ? n % w : w;
    printf("%d", abs(x1 - x2) + abs(y1 - y2));
    return 0;
}
```

### 65.直方图中的最大矩形

###### 题目描述

直方图是由在公共基线处对齐的一系列矩形组成的多边形。

矩形具有相等的宽度，但可以具有不同的高度。

例如，图例左侧显示了由高度为 2,1,4,5,1,3,3的矩形组成的直方图，矩形的宽度都为 11：

![2559_1.jpg](https://www.acwing.com/media/article/image/2019/01/14/19_eac6c46017-2559_1.jpg)

通常，直方图用于表示离散分布，例如，文本中字符的频率。

现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。

图例右图显示了所描绘直方图的最大对齐矩形。

###### 输入格式

输入包含几个测试用例。

每个测试用例占据一行，用以描述一个直方图，并以整数 n开始，表示组成直方图的矩形数目。

然后跟随 n 个整数 $h_1，…，h_n$。

这些数字以从左到右的顺序表示直方图的各个矩形的高度。

每个矩形的宽度为 1。

同行数字用空格隔开。

当输入用例为$ n=0$时，结束输入，且该用例不用考虑。

###### 输出格式

对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。

每个数据占一行。

请注意，此矩形必须在公共基线处对齐。

###### 数据范围

$1≤n≤100000,$

$0≤h_i≤1000000000$

###### 代码1(单调栈)

```C++
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long LL;

const int N = 100010;
//l[i], r[i]表示第i个矩形的高度可向两侧扩展的左右边界
int h[N], q[N], l[N], r[N];

int main(){
    int n;
    while(scanf("%d", &n), n){
        for(int i = 1; i <= n; i++)  scanf("%d", &h[i]);
        h[0] = h[n + 1] = -1;
        int tt = -1;
        q[++tt] = 0;
        for(int i = 1; i <= n; i++){
            while(h[q[tt]] >= h[i]) tt--;
            l[i] = i - q[tt];
            q[++tt] = i;
        }
        tt = -1;
        q[++tt] = n + 1;
        for(int i = n; i; i --){
            while(h[q[tt]] >= h[i]) tt--;
            r[i] = q[tt] - i;
            q[++tt] = i;
        }
        LL res = 0;
        for(int i = 1; i <= n; i++) res = max(res, (LL)h[i] * (l[i] + r[i] - 1));
        printf("%ld\n", res);
    }
    return 0;
}
```

###### 代码2(笛卡尔树)

笛卡尔树是一种特定的二叉树数据结构，可由数列构造，在范围最值查询、范围top kth查询等问题上有广泛应用。它具有堆的有序性，中序遍历可以输出原数列。笛卡尔树结构由Vuillmin(1980)在解决范围搜索的几何数据结构问题时提出。从数列中构造一棵笛卡尔树可以线性时间完成，需要采用基于栈的算法来找到在该数列中的所有最近小数。

性质：

1.堆的性质。笛卡尔树的树根是这一子树中key值最小（大）的元素，父节点的键值均小于（或大于）其左右子节点的键值，可以这样递归地弄下去。
2.**树的中序遍历即为原数组序列。**

![img](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2583072437,1505927223&fm=173&app=25&f=JPG?w=432&h=414&s=CB318B461D9A8FE31EF1F50F030070C2)

构造笛卡尔树
一般，我们规定按key为第一关键字排序，（很多时候，key值即为数组下标）。

用单调栈实时维护当前树中的最右链，模仿递归建树的过程（建虚树也是这种思想啊）。

以维护小根堆为例，在以key值增序排序后，我们考虑插入一个新点i，它的值为V。

我们从栈顶出发，一直找到第一个位置pos的value小于V，因为是小根堆，所以要保证i是pos的儿子，又因为当前的key值大于之前出现过的所有值，所以i是pos的右儿子，需要把原来pos的右儿子变成i的左儿子，代码注释里也有。

然后O(n)完成对笛卡尔树的构建。
key值就是数组下标，无需排序，直接高度建树。

然后直接在树上从根节点往下走，每个节点的高度确定，所能扩展的长度即为它的子节点的区间长度，每走到一个节点就去个max，O(n)的遍历，总时间复杂度也是O(n)的（虽然有2这个常数）。

注意多组数据的话，及时在回溯时初始化。

```C++
#include <bits/stdc++.h>
#define Re register
#define ll long long
using namespace std;

const int N = 100000 + 5;
const int INF = 0x7fffffff;
ll ans;
int n, a[N];

inline int read(){
    int res = 0; bool f = false; char ch = getchar();
    while(ch < '0' || ch > '9') {
        if (ch == '-') {
            f = 1; ch = getchar();
        }
    }
    while (ch <= '9' && ch >= '0') {
        res = (res << 3) + (res << 1) + ch - '0'; 
        ch = getchar();
    }
    return f ? (~ res + 1) : res;
}

inline ll max(ll a, ll b) { return a < b ? b : a; }

struct Cartesian_Tree {
    int sta[N], top, ls[N], rs[N], root;

    inline void init() {
        top = 0;
        for (Re int i = 1;i <= n; ++i) {
            /* 用栈来维护最右链，一直找到一个位置pos的a值会小于当前a值 */
            while (top && a[sta[top]] >= a[i]) ls[i] = sta[top--];
            /*
            因为是小根堆，所以要保证i是pos的儿子，又因为当前的key值大于之前出现
            过的所有值，所以i是pos的右儿子，需要把原来pos的右儿子变成i的左儿子
            */
            if (top) rs[sta[top]] = i;
            sta[++top] = i;
        }
        root = sta[1];
    }

    inline int dfs(int x) {
        if (!x) return 0;
        int res = dfs(ls[x]) + dfs(rs[x]) + 1;
        ls[x] = 0, rs[x] = 0;
        ans = max(ans, (ll)res * a[x]);
        return res;
    }
}CT;

int main(){
    
    return 0;
}
```

### 66.楼兰图腾

###### 题目描述

坐标分别为 $(1,y_1),(2,y_2),…,(n,y_n)$，其中$ y_1∼y_n$是 1到 n的一个排列。

如果三个点 $(i,y_i),(j,y_j),(k,y_k)$满足$ 1≤i<j<k≤n$且$ y_i>y_j,y_j<y_k$，则称这三个点构成 `V` 图腾;

如果三个点  $(i,y_i),(j,y_j),(k,y_k)$满足$ 1≤i<j<k≤n$且$ y_i<y_j,y_j>y_k$​，则称这三个点构成 `∧` 图腾;

需要编写一个程序来求出 `V` 的个数和 `∧` 的个数。

###### 输入格式

第一行一个数 $n$。

第二行是$ n $个数，分别代表$ y_1，y_2,…,y_n$。

###### 输出格式

两个数，中间用空格隔开，依次为 `V` 的个数和 `∧` 的个数。

###### 数据范围

对于所有数据，$n≤200000$，且输出答案不会超过$ int64$。$y_1∼y_n$是 $1$到 $n$​的一个排列。

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

const int N = 2000010;
typedef long long LL;
int n;
//t[i]表示树状数组i结点覆盖的范围和
int a[N], t[N];
//Lower[i]表示左边比第i个位置小的数的个数
//Greater[i]表示左边比第i个位置大的数的个数
int Lower[N], Greater[N];

//返回非负整数x在二进制表示下最低位1及其后面的0构成的数值
int lowerbit(int x) {return x & -x;}

//将序列中第x个数加上k
void add(int x, int k) {
    for(int i = x; i <= n; i += lowerbit(i)) t[i] += k;
}

//查询序列前x个数的和
int ask(int x) {
    int sum = 0;
    for(int i = x; i; i -= lowerbit(i)) sum += t[i];
    return sum;
}

int main() {
    LL resA = 0, resV = 0;
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
    //从左向右，依次统计每个位置左边比第i个数y小的数的个数、以及大的数的个数
    for(int i = 1; i <= n; i++) {
        int y = a[i]; //第i个数

        //在前面已加入树状数组的所有数中统计在区间[1, y - 1]的数字的出现次数
        Lower[i] = ask(y - 1); 

        //在前面已加入树状数组的所有数中统计在区间[y + 1, n]的数字的出现次数
        Greater[i] = ask(n) - ask(y);

        //将y加入树状数组，即数字y出现1次
        add(y, 1);
    }
    //清空树状数组，从右往左统计每个位置右边比第i个数y小的数的个数、以及大的数的个数
    memset(t, 0, sizeof t);
    //从右往左统计
    for(int i = n; i >= 1; i--){
        int y = a[i];
        resA += (LL)Lower[i] * ask(y - 1);
        resV += (LL)Greater[i] * (ask(n) - ask(y));
        //将y加入树状数组，即数字y出现1次
        add(y, 1);
	}
    printf("%lld %lld\n", resV, resA);
    return 0;
}
```

### 67.联通图

###### 题目描述

求$ N$个节点的无向连通图有多少个，节点有标号，编号为$ 1∼N$​。

例如下列图示，三个节点的无向连通图共 $4$个。

![1737_1.jpg](https://www.acwing.com/media/article/image/2019/02/17/19_3da24c4c32-1737_1.jpg)

###### 输入格式

输入包含多组测试数据。

每组数据包含一个整数$ N$。

当输入为$ 0$时，表示输入终止。

###### 输出格式

每组测试数据输出一个结果，每个结果占一行。

###### 数据范围

$1≤N≤50$

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 110;
const int M = 1100;
int n, m, i, j, k;
struct bign {
    int a[M], len;
} f[N], power[N];

inline bign operator / (const bign &x, const int y) {
    bign now;
    memset(now.a, 0, sizeof now.a);
    now.len = 0;
    int ns = 0;
    for(int i = x.len; i >= 1; i--) {
        ns = ns * 10 + x.a[i];
        now.a[i] = ns / y;
        ns %= y;
        if(!now.len && now.a[i]) now.len = i;
    }
    return now;
}

inline bign operator + (const bign &x, const bign &y) {
    bign now;
    memset(now.a, 0, sizeof now.a);
    for(int i = 1; i <= max(x.len, y.len); i++) {
        now.a[i] += x.a[i] + y.a[i];
        now.a[i + 1] = now.a[i] / 10;
        now.a[i] %= 10;
    }
    now.len = max(x.len, y.len);
    if(now.a[now.len + 1]) now.len++;
    return now;
}

inline bign operator * (const bign &x, const bign &y) {
    bign now;
    memset(now.a, 0, sizeof now.a);
    for(int i = 1; i <= x.len; i++) {
        for(int j = 1; j <= y.len; j++) {
            now.a[i + j - 1] += x.a[i] * y.a[j];
            now.a[i + j] += now.a[i + j - 1] / 10;
            now.a[i + j - 1] %= 10;
        }
    }
    now.len = x.len + y.len - 1;
    if(now.a[now.len + 1]) now.len++;
    return now;
}

inline bign C(int x, int y) {
    bign tot, temp;
    tot.len = 1;
    tot.a[1] = 1;
    for(int i = y, j = 1; j <= x; i--, j++) {
        int t = i;
        temp.len = 0;
        while(t) {
            temp.a[++temp.len] = t % 10;
            t /= 10;
        }
        tot = tot * temp / j;
    }
    return tot;
}

inline void print(const bign &x) {
    for(int i = x.len; i >= 1; i--) printf("%d", x.a[i]);
    printf("\n");
}

inline void init() {
    for(int i = 1; i <= 50; i++) {
        ll temp = ((ll)(1) << i) - 1;
        while(temp) {
            power[i].a[++power[i].len] = temp % 10;
            temp /= 10;
        }
    }
    f[1].len = 1; f[1].a[1] = 1; f[2].len = 1; f[2].a[1] = 1;
    for(int i = 3; i <= 50; i++)
        for(int j = 1; j <= i - 1; j++)
            //预处理
            f[i] = f[i] + C(j - 1, i - 2) * f[j] * f[i - j] * power[j]; 
}

int main() {
    init();
    while(scanf("%d", &n) && n) print(f[n]);
    return 0;
}
```

###### 分析：

合法的无向连通图$=$​所有无向连通图个数$-$无向不连通的无向图。

$N$个点的无向图总数求解公式为$2^{N\times (N-1)/2}$​。

- 因为对于一个无向图而言，最多有$\frac{N\times(N-1)}{2}$条边，对于一条边而言，我们可选可不选，所以总数为$2^{N\times (N-1)/2}$​。

对于一个不联通的无向图而言，它是由$K$​个连通块构成的$(k≥2)$​​。

上面这个性质对于这道题目而言非常重要，因为我们不连通的无向图，是由若干个连通块构成的，那么只需要求解连通块个数$>1$的无向图总数。

连通块个数$>1$​的无向图，我们并不在意它由多少块构成，我们只需要知道，当前这个图，它的连通块个数大于$1$​，不是无向连通图就可以了。

我们对于一张不合法的图而言，我们显然是只需要，枚举一个连通块，然后剩下的点构成任意无向图即可，因此此时连通块个数已经大于$1$了。

综上所述，我们不妨枚举标号为$i$​的点，它所在的连通块节点个数有$K$​个，然后在除了它以外的$N−1$个节点中，选出剩下的$K−1$​个节点。

那么现在我们已经构造好了一个连通块，它一共有$C^{k-1}_{n-1}$​​​​种枚举方法，那么接下来我们可以将最后剩余的节点，构成任意无向图即可。

我们设置$F[i]$表示为$i$个节点的无向连通图个数，它的状态转移方程为：
$$
F[i]=2^{\frac{i\times(i-1)}{2}}-\sum^{i-1}_{j=1}F[j]\times C^{j-1}_{i-1}\times2^{\frac{(i-j)\times(i-j-1)}{2}}
$$
初始值$F[1]=1$，最后目标为$F[N]$

### 68.卡图难题

###### 题目描述

有$ N$个变量$ X_0∼X_{N−1}$，每个变量的可能取值为$ 0$或$ 1$。

给定$ M$​​个算式，每个算式形如$ X_a $​​ $op$​​ $X_b=c$​，其中$ a,b$​是变量编号，$c$​是数字 $0$​或 $1，op$​是 $AND,OR,XOR$三个位运算之一。

求是否存在对每个变量的合法赋值，使所有算式都成立。

###### 输入格式

第一行包含两个整数$ N$和$ M$。

接下来 $M$ 行，每行包含三个整数$ a,b,c$，以及一个位运算（$AND,OR,XOR $中的一个）。

###### 输出格式

输出结果，如果存在，输出 `YES`，否则输出 `NO`。

###### 数据范围

$1≤N≤1000,$

$1≤M≤10^6$​

###### 代码

```C++
#include<bits/stdc++.h>
#define mk(a, b) make_pair(a, b)
using namespace std;
const int maxn = 2e3 + 5, maxm = 1e6 + 3, inf = 1 << 29;
const double eps = 1e - 6;
typedef long long ll;
typedef pair<int, int> pii;

int tot, head[maxn];
int low[maxn], num, dfn[maxn] ;//回溯值与时间戳 
int stck[maxn], ins[maxn], top;//栈 
vector<int> scc[maxn]; 
int cnt, c[maxn];//连通分量 
struct Edge{
    int ver, next;
}edge[maxm];//边数 

void add(int u,int v) {
    edge[++tot].ver = v; edge[tot].next = head[u]; head[u] = tot;
}

void tarjan(int x) {
    dfn[x] = low[x] = ++num;
    stck[++top] = x; ins[x] = 1;
    for(int i = head[x], y; i; i = edge[i].next) {
        if(!dfn[y = edge[i].ver]) {
            tarjan(y);
            low[x] = min(low[x], low[y]);
        } else if(ins[y]) low[x] = min(low[x], dfn[y]);
    }
    if(low[x] == dfn[x]) {
        cnt++; int z;
        do{
            z = stck[top--]; ins[z] = 0;
            c[z] = cnt, scc[cnt].push_back(z);
        } while(x != z);
    }
}

int main(){
    int n, m;
    scanf("%d%d", &n, &m);
    while(m--) {
        int a, b, c; string ch;
        scanf("%d%d%d", &a, &b, &c);
        a++, b++;
        cin >> ch;
        if(ch == "AND") {
            if(c == 0) add(a, b + n), add(b, a + n);
            else add(a + n, a), add(b + n, b);
        }
        if(ch == "OR") {
            if(c == 0) add(a, a + n), add(b, b + n);
            else add(a + n, b), add(b + n, a);
        }
        if(ch == "XOR") {
            if(c == 0) 
                add(a, b), add(b, a), add(b + n, a + n), add(a + n, b + n);
            else 
                add(a, b + n), add(a + n, b), add(b, a + n ), add(b + n, a);
        }
    }
    for(int i = 1; i <= 2 * n; i++) {
        if(!dfn[i]) tarjan(i);
    } 
    for(int i = 1; i <= n; i++) {
        if(c[i] == c[i + n]) {
            puts("NO");
            return 0;
        }
    } 
    puts("YES");
    return 0;
}
```

###### 分析：

$2\_SAT$问题：

> $SAT$​​是适定性(Satisfiability)问题的简称 。一般形式为k-适定性问题，简称 $k\_SAT$​。可以证明当$k>2$​时，$K\_SAT$​是NP完全的，因此一般只讨论$k=2$​的问题​​

就是给你**$n$个变量$a_i$​**，每个变量**能且只能**取0/1的值。同时给出若干条件，求解$2\_SAT$的解就是求出满足所有限制的一组$a$。

将$2\_SAT$问题转化为图论问题：

我们发现每个点要么取$0$，要么取$1$。因此对于$a_i$​，我们建两个点$2i−1$与$2i$分别表示$a_i$取$0$​和$1$

然后我们考虑建边来表示这些关系，我们令一条**有向边**的意义：x→y表示如果选择了x就必须选y

- i,j**不能**同时选：选了i就要选j′，选j就要选i′。故i→j′,j→i′。一般操作即为$a_i$ $xor$ $a_j=1$
- i,j**必须**同时选：选了i就要选j，选j就要选i。故i→j,j→i。一般操作即为$a_i$​ $ xor $​ $ a_j=0$​
- i,j任选（但至少选一个）选一个：选了i就要选j′，选j就要选i′，选i′就要选j，选j′就要选i。故i→j′,j→i′,i′→j,j′→i。一般操作即为$a_i $ $or$ $a_j=1$
- i**必须**选：直接i′→i，可以保证无论怎样都选i。一般操作为给出的$a_i=1$或$a_i$ $and $ $a_j=1$

解决图论问题1——$DFS$：

- 对于每个当前不确定的变量$a_i$，令$a_i=0$然后沿着边$DFS$访问相连的点。
- 检查如果会导致**任意**一个j与j′都被选，那么撤销。否则令$a_i=0$
- 否则令$a_i=1$​，重复上一步骤。如果还不行就无解。
- 继续考虑下一个不确定的变量。这样的时间复杂度为$O(n(n+m))$

只需要在$DFS$之前判断i′能否走到i就可以省略**撤销标记**的过程，所以我们可以**bitset**优化**传递闭包**做到$O(\frac{n^3}{w})$预处理，然后就可以实现时间复杂度为$O(n+m)$​​的$DFS$了。这种做法还可以保证解的字典序，有时不失为一种不错的方法。

解决图论问题2——$SCC$：

图建完之后,跑一遍$tarjan$求出所有$SCC$,若出现矛盾(即存在$scc[x]==scc[x+n]$​)就不存在解.否则存在。
时间复杂度$O(n+m)$

### 69.构造完全图

###### 题目描述

对于完全图 $G$，若有且仅有一棵最小生成树为$ T$​，则称完全图$ G$是树$ T$ 扩展出的。给你一棵树$ T$，找出$ T$ 能扩展出的边权和最小的完全图$ G$。

**注意：**$ T $和 $G $​中的边权均取正整数。

###### 输入格式

第一行包含一个整数$ N$​​表示树$ T$的点数；

接下来$ N−1$​行每行三个整数$ Si,Ti,Di$；描述一条边$ (S_i,T_i)$​权值为 $D_i$；

保证输入数据构成一棵树。

###### 输出格式

输出仅一个数，表示最小的完全图$ G $的边权和。

###### 数据范围

$N≤10^5,$​
$1≤Di≤10^5$

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

const int N = 100010;
const int M = 200010;
int n, f[N], num[N];
struct edge{
    LL a, b, w;
    bool operator <(const edge& n)const{return w < n.w;}
}edge[M];

LL find(LL x){
    if(f[x] != x) f[x] = find(f[x]);
    return f[x];
}

LL kruskal(){
    LL res = 0, cnt = 0;
    sort(edge, edge + n - 1);
    for(LL i = 1; i <= n; i++){
        f[i] = i; num[i] = 1;
    }
    for(LL i = 0; i < n - 1; i++){
        LL a = edge[i].a, b = edge[i].b, w = edge[i].w;
        a = find(a), b = find(b);
        res += (w + 1) * (num[a] * num[b] - 1);
        f[a] = b;
        num[b] += num[a];
        res += w;
    }
    
}

int main(){
    scanf("%d", &n);
    for(LL i = 0; i < n - 1; i++) scanf("%lld%lld%lld", &edge[i].a, &edge[i].b, &edge[i].w);
    LL res = kruskal();
    printf("%lld\n", res);
    return 0;
}
```

###### 分析：

最小生成树的最小扩展完全图，使用Kruskal算法

### 70.生命之树

###### 题目描述

在X森林里，上帝创建了生命之树。他给每棵树的每个节点（叶子也称为一个节点）上，都标了一个整数，代表这个点的和谐值。

上帝要在这棵树内选出一个非空节点集$ S$，使得对于$ S$中的任意两个点$ a,b$，都存在一个点列$ {a,v_1,v_2,…,v_k,b}$使得这个点列中的每个点都是$ S$里面的元素，且序列中相邻两个点间有一条边相连。在这个前提下，上帝要使得$ S$中的点所对应的整数的和尽量大。这个最大的和就是上帝给生命之树的评分。

经过$ atm$ 的努力，他已经知道了上帝给每棵树上每个节点上的整数。但是由于 $atm$​ 不擅长计算，他不知道怎样有效的求评分。他需要你为他写一个程序来计算一棵树的分数。

###### 输入格式：

第一行一个整数 $n$ 表示这棵树有 $n$ 个节点。

第二行 $n$ 个整数，依次表示每个节点的评分。

接下来 $n−1$ 行，每行 $2$ 个整数$ u,v$，表示存在一条 $u$ 到$ v$ 的边。

由于这是一棵树，所以是不存在环的。

树的节点编号从 $1$ 到 $n$​。

###### 输出格式

输出一行一个数，表示上帝给这棵树的分数。

###### 数据范围

$1≤n≤10^5，$​
每个节点的评分的绝对值均不超过 $10^6$。

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 100010, M = N * 2;
int h[N], e[M], ne[M], w[N], idx, n;
LL f[N], res;

void add(int a, int b){
    e[idx] = b; ne[idx] = h[a]; h[a] = idx++;
}
void dfs(int u, int father){
    f[u] = w[u];
    //~表示按位取反，当i为-1,即111...111时，退出循环。
    for(int i = h[u]; ~i; i = ne[i]){
        int j = e[i];
        if(j != father){
            dfs(j, u);
            f[u] += max(0ll, f[j]);
        }
	}
}
int main() {
    scanf("%d", &n);
	memset(h, -1, sizeof h);
	for(int i = 1; i <= n; i++) scanf("%d", &w[i]);
	for(int i = 0; i < n - 1; i++){
        int a, b; scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }
	dfs(1, -1);
	res = f[1];
	for(int i = 1; i <= n; i++) res = max(res, f[i]);
	printf("%lld\n", res);
    return 0;
}
```

### 71.四平方和

###### 题目描述

四平方和定理，又称为拉格朗日定理：每个正整数都可以表示为至多 4 个正整数的平方和。如果把 0 包括进去，就正好可以表示为 4 个数的平方和。

比如：$5=0^2+0^2+1^2+2^2$，$7=1^2+1^2+1^2+2^2$

对于一个给定的正整数，可能存在多种平方和的表示法。要求你对 4 个数排序：

$0\le a\le b\le c\le d$​ 并对所有的可能表示法按$ a,b,c,d$​​为联合主键升序排列，最后输出第一个表示法。

###### 输入格式：

输入一个正整数$N$。

###### 输出格式：

输出$4$个非负整数，按从小到大排序，中间用空格分开。

###### 数据范围：

$0<N<5\times 10^6$

###### 代码：

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e8 + 10;
int mp[N];
int main() {
    int n; scanf("%d", &n);
    for (int i = 0; i * i * 2 <= n; i++){
        for(int j = i; j * j + i * i <= n; j++){
            if(!mp[i * i + j * j]) mp[i * i + j * j] = i + 1; 
        }
    }
    for (int i = 0; i * i * 4 <= n; i++){
        for(int j = i; (i * i + j * j) * 2 <= n; j++){
            int t = n - i * i - j * j;
            if(mp[t]){
                int c = mp[t] - 1;
                int d = (sqrt(t - c * c) + 1e-4);
                printf("%d %d %d %d", i, j, c, d);
                return 0;
            }
        }
    }
    return 0;
}
```

### 72.密码脱落

###### 题目描述

X星球的考古学家发现了一批古代留下来的密码。

这些密码是由$A、B、C、D $四种植物的种子串成的序列。

仔细分析发现，这些密码串当初应该是前后对称的（也就是我们说的镜像串）。

由于年代久远，其中许多种子脱落了，因而可能会失去镜像的特征。

你的任务是：给定一个现在看到的密码串，计算一下从当初的状态，它要至少脱落多少个种子，才可能会变成现在的样子。

###### 输入格式

共一行，包含一个由大写字母$ABCD$构成的字符串，表示现在看到的密码串。

###### 输出格式

输出一个整数，表示至少脱落了多少个种子。

###### 数据范围

输入字符串长度不超过$1000$

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

const int N = 1e3 + 5;
char str[N];
int dp[N][N], n;

int main(){
    scanf("%s", str);
    n = strlen(str);
    for(int i = 0; i < N; i++){
        for(int j = 0; j < N; j++) dp[i][j] = INT_MAX;
    }
    for(int i = n - 1; i > -1; --i){
        for(int j = i; j < n; ++j){
            if(i == j) dp[i][j] = 0;
            else{
                if(str[i] == str[j]){
                    if(i == j - 1) dp[i][j] = 0;
                    else dp[i][j] = min(dp[i][j], dp[i + 1][j - 1]);
                }else dp[i][j] = min(dp[i][j], min(dp[i + 1][j] + 1, dp[i][j - 1] + 1));
            }
        }
	}
    
    return 0;
}
```

###### 分析

**状态定义：**$dp(i,j)$表示区间$[i,j]$​里去掉字符变成字串$str(i,j)$的集合。

**状态转移：**

- $dp(i,i)=0$：单个字符就是回文串
- $dp(i,j)=dp(i+1,j-1)(s[i]==s[j])$
- $dp(i,j)=min(dp(i+1,j),dp(i,j-1))+1(s[i]\ne s[j])$

当$i==j-1$​且$s[i]==s[j]$时，这也是回文串，但是$dp(i+1,j-1)$不合法，需要单独讨论。

### 73.分离的路径

###### 问题描述

为了从$F$ 个草场中的一个走到另一个，贝茜和她的同伴们不得不路过一些她们讨厌的可怕的树。奶牛们已经厌倦了被迫走某一条路，所以她们想建一些新路，使每一对草场之间都会至少有两条相互分离的路径，这样她们就有多一些选择。

每对草场之间已经有至少一条路径，给出所有$R$ 条双向路的描述，每条路连接了两个不同的草场，请计算最少的新建道路的数量。

路径由若干道路首尾相连而成，两条路径相互分离，是指两条路径没有一条重合的道路，但是两条分离的路径上可以有一些相同的草场。

对于同一对草场之间，可能已经有两条不同的道路，你也可以在它们之间再建一条道路，作为另一条不同的道路。

###### 输入形式

第一行输入两个整数 $F$和 $R$；

接下来$R$行，每行输入两个整数，表示两个草场，它们之间有一条道路。

###### 输出形式

输出最少需要新建的道路数目。

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 5010, maxm = 20010;
int u[maxn], v[maxn], h[maxn], nxt[maxm], p[maxm], dfn[maxn], low[maxn], bcc[maxn], deg[maxn];
int n, m, x, y, index_, ans, ltt, cur;
bool tf[maxn];
stack<int> st;

inline void addEdge(int x, int y){
    cur++, nxt[cur] = h[x], h[x] = cur, p[cur] = y;
}
void targan(int cur){
    dfn[cur] = low[cur] = ++index;
    for(int j = h[cur]; j != -1 && tf[j]; j = nxt[j]){
        int i = p[j];
        if(dfn[i]) low[cur] = min(low[cur], dfn[i]);
        else{
            st.push(i);
            tf[j] = tf[(j & 1) ? j + 1 : j - 1] = false;
            targan(i);
            tf[j] = tf[(j & 1) ? j + 1 : j - 1] = true;
            low[cur] = min(low[cur], low[i]);
		}
    }
    if(dfn[cur] == low[cur]){
        ans++;
        while(!st.empty()){
            bcc[st.top()] = ans;
            if(st.top() == cur) st.pop(), break;
            st.pop();
        }
    }
}
int main(){
    memset(h, -1, sizeof h);
    memset(tf, true, sizeof tf);
    scanf("%d%d", &n, &m);
    for(int i = 0; i < m; i++){
        scanf("%d%d", u + i, v + i);
        addEdge(u[i], v[i]), addEdge(v[i], u[i]);
    }
    for(int i = 1; i <= n; i++){
        if(!dfn[i]) {
            ans = 0; st.push(i); targan(i);
        }
    }
    for(int i = 0; i < m; i++){
        if(bcc[u[i]] != bcc[v[i]]){
            deg[bcc[u[i]]]++, deg[bcc[v[i]]]++;
        }
	}
    for(int i = 1; i <= n; i++){
        if(deg[i] == 1) ltt++;
    }
    printf("%d\n", (ltt | 1) >> 1);
    return 9;
}
```

###### 分析：(边双连通分量)：

边双连通分量即一个无向图中，去掉一条边后仍互相连通的极大子图。（单独的一个点也可能是一个边双连通分量）。换言之，**一个边双连通分量中不包含桥**。不难发现，在一个边双连通分量中，**任意两点都存在至少两条互相分离的路径**。我们要做的，就是连边将整张图变成一张边双连通图。

**桥的公式：**

```C++
void tarjan(int u,int edge)
{	
    dfn[u]=low[u]=++num;
    for(int i=fst[u];i!=0;i=nex[i])
    {
        int v=to[i];
        if(!dfn[v])
        {
            tarjan(v,i);
            low[u] = min(low[u],low[v]);
            if(dfn[u] < low[v])	//桥的公式qwq
            {
                bridg[i] = bridg[i^1]=1;
            }
        }
        else if(i != (edge^1))
            low[u] = min(low[u],dfn[v]);
    }
}
```

因为在一个边双连通分量中，任意两点都存在至少两条互相分离的路径，所以我们可以将其缩为一个点。缩完点之后，我们可以把它转换成一棵搜索树。

我们会发现，去掉一条边后可能会与原树不连通的，是只连有一条边的边，即叶结点（设其数量为$leaf$​）为令原图 *边双连通*（我不知道这么说对不对），我们把两个叶结点为一组用新边将其连接起来。最终公式为$(leaf+1)/2$

### 74.螺旋矩阵

###### 题目描述：

生成一个n行n列的螺旋矩阵，顺时针填充。

###### 输入形式：

输入三个整数，代表矩阵大小n，横坐标i，纵坐标j

###### 输出形式：

输出矩阵中第i行第j列的数

###### 数据规模：

$1\le n\le30000$

```
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long n, i, j, k, ans = 0;
	scanf("%d%d%d", &n, &i, &j);
	k = min(i, min(j, min(n - i + 1, n - j + 1)));
	if(i <= j) ans = k * (4 * (n - 1) - 4 * k) + 10 * k - 4 * n - 3 + i + j;
	else ans = k * (4 * n - 4 * k) + 2 * k + 1 - i - j;
	printf("%lld", ans);
	return 0;
}
```

### 75.easy problem

###### 问题描述

给定一个长度为 $n$的非负整数序列 ，求一个平均数最大的，长度不小于$L$ 的子段。

###### 输入形式

第$ 1 $行用空格分隔的两个整数$n$ 和$L$ ；

第$ 2$ 行到第$ n + 1 $行每行一个数字，分别为$n$个非负整数，表示$A_i$ 。

###### 输出形式

输出一个整数，表示这个平均数的$1000$ 倍。不用四舍五入，直接输出。

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 100005;
double f[N], pre[N], b[N];

int main(){
    int n, L, i, j;
    double l = -1e6, r = 1e6, precision = 1e-6, maxn, minn, mid;
    scanf("%d%d", &n, &L);
    for(i = 1; i <= n; i++) scanf("%lf", &f[i]);
    while(r - 1 > precison){// l和r很接近,二分到值可以确定
        mid = (r + l) >> 1;//假设最大平均数是mid
        for(int i = 1; i <= n; i++){
            b[i] = f[i] - mid;
            pre[i] = pre[i - 1] + b[i]; //前缀和(除去假设的最大平均数) 
		}
        maxn = -1e10, minn = 1e10;
        for(i = L; i <= n; i++){
            minn = min(minn, pre[i - L]);//最小的前缀 
            maxn = max(maxn, pre[i] - minn);//前缀和（大于L）减去最小的前缀 ,得到连续（大于L）的最大和 
		}
        if(maxn >= 0) l = mid; //maxx>0代表假设的mid可以得到
        else r = mid; //找比mid更小的 
    }
    printf("%d", int(r * 1000));
    return 0;
}
```

### 76.Delegation

###### 问题描述

Farmer John 的$N$ 片牧场由$N-1$ 条道路连接而成，使得任意一片牧场与其他牧场都联通，形成了树状结构。在研究了由这树状结构产生的各种算法问题$ 28$年后，他还是觉得农场的结构过于复杂，而他相信研究路径的算法问题更为简单。

因此，他的目标是把牧场间的道路分成一条条路径，然后指定这些路径在他贵重的农场工人的使用过程中起些什么作用。他不关心路径的数目，而是想要这些路径越长越好，使得没有农场工人可以用低效率的算法解决问题。

你的任务是帮 Farmer John 找出最大的整数$K$ 使得每条道路恰好被分入一条路径中，且路径长度至少为$K$​ 。

###### 输入形式

第一行一个整数$N$ 。

接下来$N-1$ 行每行两个以空格隔开的整数$a,b$ ，表示节点$a$ 和节点$b$​ 之间有一条边。

###### 输出形式

输出$K$ 。

###### 样例输入

```
8
1 2
1 3
1 4
4 5
1 6
6 7
7 8
```

###### 样例输出

3

###### 样例说明

一个可行的划分方案是：$2-1-6-7-8,3-1-4-5$。

###### 数据范围 

$2\le N\le10^5$

###### 代码

```C++
#include <bits/stdc++.h>
#define pb push_back
using namespace std;

const int N = 1e5 + 5;
int n, m, ans, flg, jb, f[N];
vector<int> g[N];

inline void dfs(int u, int fa, int l) {
	multiset<int> m;//multiset容器
	if (flg) return;
	for (int i = 0; i < g[u].size(); i++) {
		int v = g[u][i];
		if (v == fa) continue;
		dfs(v, u, l);
		m.insert(f[v] + 1);
	}
	jb = 0;
	if ((u == 1 && m.size() & 1) || (u != 1 && !(m.size() & 1))) m.insert(0);
	//强制除根节点外的点从儿子连边过来的边数为奇数条
	while (m.size()) {
		multiset<int>::iterator it = m.begin();//取当前最小边
		int small = *it;
		m.erase(it);
		multiset<int>::iterator big = m.lower_bound(l - small);
		//二分找到第一条大于等于二分的l的边
		if (u == 1) {
			if (big == m.end()) {//找不到，走人
				flg = 1;
				break;
			}
			m.erase(big);
		}
		else {
			if (big == m.end() && jb) {
				flg = 1;
				break;
			}
			if (big == m.end() && !jb)
				jb = 1, f[u] = small;//找到那一条可以给f[u]造成贡献的边
			if (big != m.end()) m.erase(big);
		}
	}
}

inline bool check(int mid) {
	flg = 0;
	for(int i = 0; i < N; i++) f[i] = 0;
	dfs(1, 0, mid);
	return (!flg);
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i < n; i++) {
		int x, y;
		scanf("%d%d", &x, &y);
		g[x].pb(y);
		g[y].pb(x);
	}
	int l = 0, r = n;
	while (l <= r) {
		int mid = (l + r) / 2;
		if (check(mid))
			l = mid + 1, ans = mid;
		else r = mid - 1;//二分答案
	}
	printf("%d\n", ans);
	return 0;
}
```

### 77.子集选取

###### 题目描述

一个有$N$个元素的集合有$2^N$个不同子集（包含空集），现在要在这$2^N$​个集合中取出若干集合（至少一个），使得它们的交集的元素个数为$K$​，求取法的方案数，答案模$1000000007$​。

###### 输入形式

输入一行两个整数$N，K$​。

###### 输出形式

输出一个整数表示答案。

###### 数据范围

$1\le K\le N\le10^6$

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1000005;
const ll MOD = 1000000007;
int n, k, m;
ll ans, nw, inv[N], fac[N], ifac[N];

ll C(int a, int b){
	return fac[a] * ifac[b] % MOD * ifac[a - b] % MOD;
}

int main(){
    scanf("%d%d", &n, &k);
    inv[1] = fac[0] = fac[1] = ifac[0] = ifac[1] = 1;
    for(int i = 2; i <= n; i++){
        inv[i] = ill * (MOD - MOD / i) * inv[MOD % i] % MOD;
        fac[i] = fac[i - 1] * i % MOD;
        ifac[i] = ifac[i - 1] * inv[i] % MOD;
    }
    m = n - k, nw = 2;
    for(int i = m; i >= 0; --i, nw = now * nw % MOD){
        ans = ((ans + ((i & 1) ? -1 : 1) * C(m, i) % MOD * (nw - 1) % MOD) % MOD + MOD) % MOD;
    }
    ans = ans * C(n, k) % MOD;
    printf("%lld", ans);
    return 0;
}
```

###### 分析

从$n$​个数中可以任意选出$k$​个，所以会有$C^k_n$​的组合数。规定当前的交集就是组合数选出的这$k$​个数，那么剩下数的应该是可以任意选或者不选，于是会有$2^{n-k}$​​种组合。而这些集合可以任意选或者不选，但是不能一个都不选，于是方案数是$2^{2^{n-k}}-1$​种，但是这样可能导致最后的交集变大。所以需要使用容斥原理，计算

$$
ans=\sum^n_{n=k}(-1)^{i-k}C^k_iC^i_n(2^{2^{n-i}}-1)
$$

### 78.接水问题

###### 题目描述

学校里有一个水房，水房里一共装有m 个龙头可供同学们打开水，每个龙头每秒钟的 供水量相等，均为1。 现在有n 名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从1 到n 编号，i 号同学的接水量为wi。接水开始时，1 到m 号同学各占一个水龙头，并同时打 开水龙头接水。当其中某名同学j 完成其接水量要求wj 后，下一名排队等候接水的同学k 马上接替j 同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即 j 同学第x 秒结束时完成接水，则k 同学第x+1 秒立刻开始接水。若当前接水人数n’不足m， 则只有n’个龙头供水，其它m?n’个龙头关闭。 现在给出n 名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。

###### 输入形式

　第1 行2 个整数n 和m，用一个空格隔开，分别表示接水人数和龙头个数。 第2 行n 个整数w1、w2、……、wn，每两个整数之间用一个空格隔开，wi 表示i 号同 学的接水量。

###### 输出形式

输出只有一行，1 个整数，表示接水所需的总时间。

###### 样例输入

```
5 3
4 4 1 2 1
```

###### 样例说明

　　第1 秒，3 人接水。第1 秒结束时，1、2、3 号同学每人的已接水量为1，3 号同学接完
　　水，4 号同学接替3 号同学开始接水。
　　第2 秒，3 人接水。第2 秒结束时，1、2 号同学每人的已接水量为2，4 号同学的已接
　　水量为1。
　　第3 秒，3 人接水。第3 秒结束时，1、2 号同学每人的已接水量为3，4 号同学的已接
　　水量为2。4 号同学接完水，5 号同学接替4 号同学开始接水。
　　第4 秒，3 人接水。第4 秒结束时，1、2 号同学每人的已接水量为4，5 号同学的已接
　　水量为1。1、2、5 号同学接完水，即所有人完成接水。
　　总接水时间为4 秒。

###### 数据规模和约定

　　$1 ≤ n ≤ 10000，1 ≤m≤ 100 $且$m≤ n$​；
　　$1 ≤ w_i ≤ 100$

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    priority_queue<int, vector<int>, greater<int> > pq;
    int n, m, t, ans; scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++){
       	scanf("%d", &t);
        if(i <= m) pq.push(t);
        else{
            int a = q.top(); q.pop();
            q.push(a + t);
        }
    }
    while(!q.empty()){
        ans = q.top(); q.pop();
    }
    printf("%d", ans);
    return 0;
}
```

### 79.Car的旅行路线

###### 题目描述

​	又到暑假了，住在城市A的Car想和朋友一起去城市B旅游。她知道每个城市都有四个飞机场，分别位于一个矩形的四个顶点上，同一个城市中两个机场之间有一 条笔直的高速铁路，第I个城市中高速铁路了的单位里程价格为Ti，任意两个不同城市的机场之间均有航线，所有航线单位里程的价格均为t。
那么Car应如何安排到城市B的路线才能尽可能的节省花费呢?她发现这并不是一个简单的问题，于是她来向你请教。找出一条从城市A到B的旅游路线，出发和到达城市中的机场可以任意选取，要求总的花费最少。

###### 输入形式

第一行有四个正整数s，t，A，B。s表示城市的个数，t表示飞机单位里程的价格，A，B分别为城市A，B的序号，(1<=A，B<=S)。

接下来有S行，其中第I行均有7个正整数xi1，yi1，xi2，yi2，xi3，yi3，Ti，这当中的(xi1，yi1)，(xi2，yi2)，(xi3，yi3)分别是第I个城市中任意三个机场的坐标，T I为第I个城市高速铁路单位里程的价格。

###### 输出形式

共有n行，每行一个数据对应测试数据，保留一位小数。

###### 数据规模和约定

$0<S<=100$，

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
struct node {
    int x, y, id;
};
vector<node> nodes(1);
int n, flyprice, beginn, endn, inf = 99999;
double e[500][500];

double w(int x1, int y1, int x2, int y2) {
    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}
bool h(int x1, int y1, int x2, int y2, int x3, int y3) {
    return !((x1 - x2) * (x1 - x3) + (y1 - y2) * (y1 - y3));
}
double f(int m) {
    double dis[500];
    bool book[500] = {0};
    fill(dis, dis + 500, inf);
    for (int i = 0; i < 500; i++) dis[i] = inf;
    dis[m] = 0;
    for (int i = 1; i <= n * 4 - 1; i++) {
        int minn = inf, u = -1;
        for (int j = 1; j <= n * 4; j++) {
            if (book[j] == false && dis[j] < minn) {
                minn = dis[j];
                u = j;
            }
        }
        if (u == -1) break;
        book[u] = true;
        for (int k = 1; k <= n * 4; k++) {
            if (e[u][k] < inf && dis[k] > e[u][k] + dis[u]) {
                dis[k] = e[u][k] + dis[u];
            }
        }
    }
    return min(min(dis[endn * 4 - 3], dis[endn * 4 - 2]), min(dis[endn * 4 - 1], dis[endn * 4]));
}
int main() {
    fill(e[0], e[0] + 500 * 500, inf);
    scanf("%d %d %d %d", &n, &flyprice, &beginn, &endn);
    for (int i = 1; i <= n; i++) {
        int x1, y1, x2, y2, x3, y3, x4, y4, t;
        scanf("%d %d %d %d %d %d %d", &x1, &y1, &x2, &y2, &x3, &y3, &t);
        if (h(x1, y1, x2, y2, x3, y3)) {
            x4 = x2 + x3 - x1;
            y4 = y2 + y3 - y1;
        } else if (h(x2, y2, x1, y1, x3, y3)) {
            x4 = x1 + x3 - x2;
            y4 = y1 + y3 - y2;
        } else {
            x4 = x1 + x2 - x3;
            y4 = y1 + y2 - y3;
        }
        e[(i - 1) * 4 + 1][(i - 1) * 4 + 2] = e[(i - 1) * 4 + 2][(i - 1) * 4 + 1] = w(x1, y1, x2, y2) * t;
        e[(i - 1) * 4 + 1][(i - 1) * 4 + 3] = e[(i - 1) * 4 + 3][(i - 1) * 4 + 1] = w(x1, y1, x3, y3) * t;
        e[(i - 1) * 4 + 1][(i - 1) * 4 + 4] = e[(i - 1) * 4 + 4][(i - 1) * 4 + 1] = w(x1, y1, x4, y4) * t;
        e[(i - 1) * 4 + 2][(i - 1) * 4 + 3] = e[(i - 1) * 4 + 3][(i - 1) * 4 + 2] = w(x2, y2, x3, y3) * t;
        e[(i - 1) * 4 + 2][(i - 1) * 4 + 4] = e[(i - 1) * 4 + 4][(i - 1) * 4 + 2] = w(x2, y2, x4, y4) * t;
        e[(i - 1) * 4 + 3][(i - 1) * 4 + 4] = e[(i - 1) * 4 + 4][(i - 1) * 4 + 3] = w(x3, x3, x4, y4) * t;
        nodes.push_back({x1, y1, i});
        nodes.push_back({x2, y2, i});
        nodes.push_back({x3, y3, i});
        nodes.push_back({x4, y4, i});
    }
    for (int i = 1; i <= n * 4; i++) {
        for (int j = i + 1; j <= n * 4; j++) {
            if (nodes[i].id != nodes[j].id) {
                e[i][j] = e[j][i] = flyprice * w(nodes[i].x, nodes[i].y, nodes[j].x, nodes[j].y);
            }
        }
    }
    double ans = inf;
    for (int i = 3; i >= 0; i--) ans = min(ans, f(beginn * 4 - i));
    printf("%.1f\n", ans);
    return 0;
}
```

### 80.校门内的树

###### 问题描述

校门内有很多树，学校决定在某个时刻在某一段种上一种树，保证任一时刻不会出现两段相同种类的树，现有两种操作：

- K=1,读入l,r表示在l到r之间种上一种树，每次操作种的树的种类都不同；
- K=2,读入l,r表示询问l到r之间有多少种树。

注意：每个位置都可以种几棵不同种类的树。

###### 输入形式

第一行$n,m$ 表示道路总长为$n$ ，共有$m$ 个操作；
接下来$m$ 行为$m$ 个操作。

###### 输出形式

对于每个$K=2$ 输出一个答案。

###### 数据范围

$1\le n,m\le5\times10^4$，保证$l,r>0$​

###### 代码(树状数组)

```C++
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 100010;
int n, m, sum1[MAXN], sum2[MAXN];

int lowerbit(int x) {return x & ~x;}
int getSum(int x, int c[]){
    int ans = 0;
    for(int i = x; i > 0; i -= lowerbit(i)) ans += c[i];
    return ans;
}
void update(int i, int k, int c[]){
    while(i <= n){
        c[i] += k;
        i += lowerbit(i);
    }
}
int main(){
    scanf("%d%d", &n, &m);
    while(m--){
        int k, a, b; scanf("%d%d%d", &k, &a, &b);
        if(k == 1){
            update(a, 1, sum2); update(b, 1, sum1);
        }else if(k == 2){
            printf("%d\n", getSum(b, sum2) - getSum(a - 1, sum1));
        }
    }
    return 0;
}
```

###### 代码(线段树)：

```C++
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 50005;
int n, m, tot, a, b, k;
struct wk{
    int a, b, left, right, v, lazy, ex;
}tree[2 * maxn];

inline void _read(int &x){
    char t = getchar(); bool sign = true;
    while(t < '0' || t > '9'){
        if(t == '-') sign = false;
        t = getchar();
    }
    for(x = 0; t >= '0' && t <= '9'; t = getchar()) x = x * 10 + t - '0';
    if(!sign) x = -x;
}
void buildtree(int x, int y){
    int r = ++ tot, mid;
    tree[r].a = x, tree[r].b = y;
    if(x < y){
        mid = (x + y) >> 1;
        tree[r].left = tot + 1;
        buildtree(x, mid);
        tree[r].right = tot + 1;
        buildtree(mid + 1, y);
    }
}
void putdown(int r){
    tree[r].ex += tree[r].lazy;
    tree[tree[r].left].lazy += tree[r].lazy;
    tree[tree[r].right].lazy += tree[r].lazy;
    tree[tree[r].left].v += tree[r].lazy;
    tree[tree[r].right].v += tree[r].lazy;
    tree[r].lazy = 0;
}
void add(int r){
    if(tree[r].a > b || tree[r].b > a) return;
    tree[r].v++;
    if(tree[r].a >= a && tree[r].b <= b){
        tree[r].lazy++; return;
    }
    if(tree[r].lazy) putdown(r);
    int mid = (tree[r].a + tree[r].b) >> 1;
    if(a <= mid) add(tree[r].left);
    if(b > mid) add(tree[r].right);
    if(a <= mid && b > mid) tree[r].ex++;
}

int getnum(int r){
	if(tree[r].a > b || tree[r].b < a) return 0;
	if(tree[r].a >= a && tree[r].b <= b) return tree[r].v;
	if(tree[r].lazy) putdown(r);
	int mid = (tree[r].a + tree[r].b) >> 1;
	int sum = 0;
	if(a <= mid) sum += getnum(tree[r].left);
	if(b > mid) sum += getnum(tree[r].right);
	if(a <= mid && b > mid) sum -= tree[r].ex;
	return sum;
}
int main(){
    _read(n); _read(m);
	buildtree(1, n);
	for(int i = 1; i <= m; i++){
		_read(k); _read(a); _read(b);
		if(k == 1) add(1);
		else printf("%d\n", getnum(1));
	}
    return 0;
}
```

### 81.山峰和山谷

###### 问题描述

给定一个$n\times n$​ 的网格状地图，每个方格$(i,j)$有一个高度$w_j$ 。如果两个方格有公共顶点，则它们是相邻的。

定义山峰和山谷如下：

- 均由地图上的一个连通块组成；
- 所有方格高度都相同；
- 周围的方格（即不属于山峰或山谷但与山峰或山谷相邻的格子）高度均大于山谷的高度，或小于山峰的高度。

求地图内山峰和山谷的数量。特别地，如果整个地图方格的高度均相同，则整个地图既是一个山谷，也是一个山峰。

###### 输入形式

第一行一个整数$n(2\le n\le1000)$，表示地图的大小。

接下来$n$ 行每行$n$ 个整数表示地图。第$i$ 行有$n$ 个整数$w_{i1},w_{i2},...,w_{in}(0\le w_{ij}\le1000000000)$ ，表示地图第$i$​ 行格子的高度。

###### 输出形式

输出一行两个整数，分别表示山峰和山谷的数量。

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

const int N = 1010;
int g[N][N], st[N][N];
int n;
int q[N * N][2];

void bfs(int x, int y, bool &higher, bool &lower) {
    int hh = 0, tt = 0;
    q[tt][0] = x, q[tt][1] = y;
    while(hh <= tt) {
        x = q[hh][0], y = q[hh][1], hh ++;
        for(int i = x - 1; i <= x + 1; i ++)
            for(int j = y - 1; j <= y + 1; j ++) {
                if(i < 0 || i >= n || j < 0 || j >= n) continue;
                if(g[x][y] != g[i][j]) {
                    if(g[x][y] > g[i][j]) lower = true;
                    if(g[x][y] < g[i][j]) higher = true;
                }
                else if(!st[i][j]) {
                    q[++ tt][0] = i, q[tt][1] = j, st[i][j] = 1;
                }
            }
    }
}

int main() {
    scanf("%d", &n);
    for(int i = 0; i < n; i ++)
        for(int j = 0; j < n; j ++)
            scanf("%d", &g[i][j]);
    int peak = 0, valley =  0;
    for(int i = 0; i < n; i ++)
        for(int j = 0; j < n; j ++)
            if(!st[i][j]) {
                bool higher = false, lower = false;
                bfs(i, j, higher, lower);
                if(!higher) peak ++;
                if(!lower) valley ++;
            }
    printf("%d %d\n", peak, valley);
    return 0;
}
```

### 82.打开灯泡

###### 问题描述

有一种正方形的电路元件，在它的两组相对顶点中，有一组会用导线连接起来，另一组则不会。
有 $N\times M$个这样的元件，你想将其排列成 $N$行$M$ 列放在电路板上。电路板的左上角连接电源，右下角连接灯泡。
试求：至少要旋转多少个正方形元件才能让电源与灯泡连通，若无解则输出`NO SOLUTION` 。

###### 输入形式

第一行有两个整数$N$ 和$M$​ 。
在接下来的$N$ 行中，每行有$M$ 个字符。每个字符均为 `\` 或 `/`，表示正方形元件上导线的连接方向。

###### 输出形式

输出共一行，若有解则输出一个整数，表示至少要旋转多少个正方形元件才能让电源与灯泡连通；若无解则输出 `NO SOLUTION`。

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
typedef pair<int, int> PII;
const int N = 510;

int n, m; //长和宽
char g[N][N]; //图
int d[N][N]; //距离

int bfs() {
    memset(d, 0x3f, sizeof d); //把所有距离赋值正无穷

    deque<PII> dq; //双端队列
    dq.push_back({0, 0});
    d[0][0] = 0;

    int dx[4] = {-1, -1, 1, 1}, dy[4] = {-1, 1, 1, -1};
    int ix[4] = {-1, -1, 0, 0}, iy[4] = {-1, 0, 0, -1};
    char cs[] = "\\/\\/";

    while(dq.size()) {
        auto t = dq.front();
        dq.pop_front();

        int x = t.first, y = t.second;
        for(int i = 0; i < 4; i ++) {
            int a = x + dx[i], b = y + dy[i];
            if(a >= 0 && a <= n && b >= 0 && b <= m) {
                int w = 0;
                int j = x + ix[i], k = y + iy[i];
                if(g[j][k] != cs[i]) w = 1;

                if(d[a][b] > d[x][y] + w) {
                    d[a][b] = d[x][y] + w;
                    if(w) dq.push_back({a, b});
                    else dq.push_front({a, b});
                }
            }
        }
    }
    if(d[n][m] == 0x3f3f3f3f) return -1;
    return d[n][m];
}

int main() {
    scanf("%d%d", &n, &m);
    for(int i = 0; i < n; i++) scanf("%s", g[i]);    
    int t = bfs();
    if(t == -1) puts("NO SOLUTION");
    else printf("%d\n", t);
    return 0;
}

```

### 83.字符串编辑

###### 题目描述

从键盘输入一个字符串（长度$\le40$个字符），并以字符 ’.’ 结束。

  编辑功能有：

  1 D：删除一个字符，命令的方式为： D a  其中a为被删除的字符，例如：D s 表示删除字符 's’ ，若字符串中有多个 's’，则删除第一次出现的。
  2 I：插入一个字符，命令的格式为：I a1 a2  其中a1表示插入到指定字符前面，a2表示将要插入的字符。例如：I s d 表示在指定字符's’ 的前面插入字符'd’ ，若原串中有多个's’ ，则插入在最后一个字符的前面。
　3 R：替换一个字符，命令格式为：R a1 a2  其中a1为被替换的字符，a2为替换的字符，若在原串中有多个a1则应全部替换。

  在编辑过程中，若出现被改的字符不存在时，则输出提示信息`指定字符不存在`

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    string str;
    char edit, a1, a2;
    cin >> edit >> a1;
    switch(edit){
        case 'D':
            str.erase(str.find_first_of(a1), 1);
            break;
        case 'I':
            cin >> a2;
            str.insert(str.find_last_of(a1), 1);
            break;
        case 'R':
            cin >> a2;
            replace(str.begin(), str.end(), a1, a2);
            break;
        default: break;     
    }
    if(str == tempstr) puts("指定字符不存在");
    else printf("%s", str.c_str());
    return 0;
}
```

### 84.岛屿面积

###### 题目描述

若海域由一个主岛和一些附属岛屿组成，海域可由一个$n×n$的方阵表示，矩阵中的数字表示相应主岛或岛屿的海拔：数字$1～9$表示陆地，数字$0$表示海洋。

现在A君打算在某个岛屿或主岛上探险，他的飞机将会降落在海域坐标为$(x, y)$的陆地上，请你计算A君降落点所在岛屿或主岛的面积有多大，此处将面积定义为满足4连通的格子有多少个，4连通即为将与A君降落点上下左右相邻接的陆地均视为同一岛屿或主岛。

###### 输入形式

输入一行包含3个整型数据，第一个用于表示海域的总面积，即*n*行*n*列$(1<=n<=30)$​​的方形区域；后两个用于表示A君的降落点坐标$x$​和$y（1<=x, y <=n）$​​。

###### 输出形式

A君降落点所在岛屿或主岛的面积。

###### 样例输入

```
3 1 1
1 1 0
2 1 0
0 0 0

5 2 4
0 1 1 5 0
2 2 3 1 1
2 0 0 2 0
0 1 3 1 0
1 0 1 0 0

10 6 8
1 2 1 0 0 0 0 0 2 3
3 0 2 0 1 2 1 0 1 2
4 0 1 0 1 2 3 2 0 1
3 2 0 0 0 1 2 4 0 0
0 0 0 0 0 0 1 5 3 0
0 1 2 1 0 1 5 4 3 0
0 1 2 3 1 3 6 2 1 0
0 0 3 4 8 9 7 5 0 0
0 0 0 3 7 8 6 0 1 2
0 0 0 0 0 0 0 0 1 0
```

###### 样例输出

```
4
14
38
```

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
int a[51][51], book[51][51], n;

int dfs(int x, int y) {
    int sum = 0;
    if (x >= 1 && x <= n && y >= 1 && y <= n) {
        if (a[x][y] != 0) {
            sum = 1; a[x][y] = 0;
            sum += dfs(x - 1, y);
            sum += dfs(x + 1, y);
            sum += dfs(x, y - 1);
            sum += dfs(x, y + 1);
        }
        return sum;
    }
    else return 0;
}
int main(){
	int x, y, i, j;
	while(scanf("%d%d%d", &n, &x, &y) == 3){
		for(i = 1; i <= n; i++){
			for(j = 1; j <= n; j++) scanf("%d", &a[i][j]);
		}
		book[x][y] = 1;
		int sum = dfs(x, y);
		printf("%d\n", sum);
	}
	return 0;
}
```

### 85.方格取数

###### 题目描述

设有N*N的方格图(N<=10),我们将其中的某些方格中填入正整数,而其他的方格中则放入数字0。
某人从图的左上角的A 点(1,1)出发，可以向下行走，也可以向右走，直到到达右下角的B点(N,N)。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。
此人从A点到B 点共走两次，试找出2条这样的路径，使得取得的数之和为最大。

###### 输入形式

输入的第一行为一个整数N（表示N*N的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的0表示输入结束。

###### 输出形式

只需输出一个整数，表示2条路径上取得的最大的和。

###### 样例输入

```
8
2 3 13
2 6 6
3 5 7
4 4 14
5 2 21
5 6 4
6 3 15
7 2 14
0 0 0
```

###### 样例输出

```
67
```

###### 代码

```C++
#include<bits/stdc++.h>
using namespace std;
int dp[20][20][20][20], g[20][20];

int main() {
    int n;
    while(~scanf("%d",&n)) {
        memset(dp, 0, sizeof(dp));
        int x, y, w;
        while(1) {
            scanf("%d%d%d", &x, &y, &w);
            g[x][y] = w;
            if(w == 0) break;
        }
        for(int i = 1; i <= n; i++) {
        	for(int j = 1; j <= n; j++) {
                for(int k = 1; k <= n; k++) {
                    for(int l = 1; l <= n; l++) {
                    	dp[i][j][k][l] = max(dp[i-1][j][k-1][l], max(dp[i-1][j][k][l-1], max(dp[i][j-1][k-1][l], dp[i][j-1][k][l-1]))) + g[i][j];
                        if(i != k || j != l) dp[i][j][k][l] += g[k][l];
                	}
               }
           }
        }
        printf("%d\n", dp[n][n][n][n]);
  	}
	return 0;
}
```

### 86.寻找三位数

###### 题目描述

将1，2，…，9共9个数分成三组，分别组成三个三位数，且使这三个三位数构成1：2：3的比例，试求出所有满足条件的三个三位数。例如：三个三位数192，384，576满足以上条件。

###### 输出形式

输出每行有三个数，为满足题设三位数。各行为满足要求的不同解。

###### 代码

```C++
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
	int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
	int a, b, c;
	do {
		a = A[0] *100 + A[1] * 10 + A[2];
		b = A[3] * 100 + A[4] * 10 + A[5];
		c = A[6] * 100 + A[7] * 10 + A[8];
		if(a == b/2 && a == c/3) printf("%d %d %d\n", a, b, c);
	} while(next_permutation(A, A + 9));//全排列
	return 0;
}
```

### 87.装箱问题

###### 题目描述

有一个箱子容量为V（正整数，0＜＝V＜＝20000），同时有n个物品（0＜n＜＝30），每个物品有一个体积（正整数）。要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。

###### 输入形式

第一行为一个整数，表示箱子容量；第二行为一个整数，表示有n个物品；接下来n行，每行一个整数表示这n个物品的各自体积。

###### 输出形式

一个整数，表示箱子剩余空间。

###### 样例输入

```
24
6
8
3
12
7
9
7
```

###### 样例输出

```
0
```

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
int maxv[30000], goods[100], n, v;
int main() {
	scanf("%d%d", &v, &n);
	for (int i = 1; i <= n; i++) scanf("%d", &goods[i]);
	for (int i = 1; i <= n; i++) {
		for (int j = v; j >= goods[i]; j--) {
			if (maxv[j] < maxv[j - goods[i]] + goods[i]) {
				maxv[j] = maxv[j - goods[i]] + goods[i];
			}
		}
	}
	printf("%d", v - maxv[v]);
	return 0;
}
```

### 88.高精度加法

###### 题目描述

输入两个整数a和b，输出这两个整数的和。a和b都不超过100位。

###### 输入形式

输入包括两行，第一行为一个非负整数a，第二行为一个非负整数b。两个整数都不超过100位，两数的最高位都不是0。

###### 输出形式

输出一行，表示a + b的值。

###### 代码

```C++
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
	string a, b;
	cin >> a;
	cin >> b;
	int A[101] = {0}, B[101] = {0}, C[102] = {0};
	int k = 0;
	for (int i = a.length() - 1; i >= 0; i--) A[k++] = a[i] - '0';
	k = 0;
	for (int i = b.length() - 1; i >= 0; i--) B[k++] = b[i] - '0';
	int j;
	int len = max(a.length(), b.length());
	for (j = 0; j < len; j++) {
		int sum = C[j] + A[j] + B[j];
		C[j] = sum % 10;
		C[j + 1] = sum / 10;
	}
	if (C[j] != 0) len++;
	for (int i = len - 1; i >= 0; i--) cout << C[i];

	return 0;
}
```

### 89.K倍区间

###### 题目描述：

给定一个长度为 $N$ 的数列，$A_1,A_2,…A_N$​，如果其中一段连续的子序列$ A_i,A_{i+1},…A_j$ 之和是 $K$ 的倍数，我们就称这个区间 $[i,j] $ 是 $K$ 倍区间。

你能求出数列中总共有多少个 $K$​ 倍区间吗？

###### 输入形式

第一行包含两个整数 $N$ 和 $K$。以下 $N$ 行每行包含一个整数 $A_i$。

###### 输出形式

输出一个整数，代表 $K$ 倍区间的数目。

###### 数据范围

$1\le N,K\le 100000,$

$1\le A_i\le 100000$

###### 代码

```C++
#include<bits/stdc++.h>
using namespace std;
const int N = 100010;
typedef long long ll;
int sum[N], a[N], res[N];
int n, k;
ll ans = 0;
int main(){
    scanf("%d%d", &n, &k);
    for(int i = 1; i <= n; i++){
        scanf("%d", &a[i]);
        sum[i] = (sum[i-1] + a[i]) % k; //前缀和取模
        ans += res[sum[i]]; //更新答案  
        res[sum[i]]++; //两个相等的前缀和就能组成一个k倍区间
    }
    printf("%lld", ans + res[0]);
    return 0;
}
```

###### 分析：

$(Sum[j]-Sum[i-1]) \% k == 0$​​ 等价于 $Sum[j] \%k==Sum[i-1]\%k$​​

### 90.压缩和解压缩

###### 问题描述：

$prime21$有一种用于压缩**仅有小写字符**的串的方式，压缩方式如下：
记原串为$S$​，原串中连续相同的x个字符(x≥2)，在新串中用cx表示（c表示该相同的字符）,其余字符不变。
例子如下

|     原串      |  新串  |
| :-----------: | :----: |
|     prime     | prime  |
|      wjj      |  wj2   |
| kkkkkkkkkkdao | k10dao |

现在要求你完成以下两种任务:
1.给定一个原串，输出压缩后的新串
2.给定一个新串，输出压缩前的原串

###### 输入形式:

一行，表示按要求应当输出的串

###### 样例输入1

1

pppppppr

###### 样例输出1

p7r

###### 样例输入2：

2
wj2

###### 样例输出2

wjj

###### 数据范围和约定

全文比较忽略行末空格和结尾空行

保证任务中原串的长度小于10000，保证压缩后的串格式合法

###### 代码

```C++
#include <iostream>
using namespace std;

int main() {
	int n; scanf("%d", &n);
	string s; cin >> s;
	char c; int mul = 0, count = 1;
	if (n == 1) {
		for (int i = 0; i < s.size(); i++) {
			if (s[i] == ' ') return 0;
			c = s[i];
			if (i < s.size() - 1 && s[i] != s[i + 1]) {
				putchar(c);
				if (count > 1) printf("%d", count); count = 1;
			}
			else if (i < s.size() - 1) count++;
		}
		putchar(c);
		if (count > 1) printf("%d", count);
	}
	else if (n == 2) {
		for (int i = 0; i < s.size(); i++) {
			if (s[i] == ' ') return 0;
			if (islower(s[i])) {
				putchar(s[i]);
				if (i < s.size() - 1 && isdigit(s[i + 1])) c = s[i];
			}
			else {
				mul *= 10;
				mul += s[i] - '0';
				if (!isdigit(s[i + 1]) || i == s.size() - 1) {
					for (int j = 1; j <= mul - 1; j++) putchar(c);
					mul = 0;
				}
			}
		}
	}
	return 0;
}
```

### 91.报数

###### 问题描述

甲乙丙丁决定玩一个报数的游戏来打发时间。游戏规则为四个人从1开始轮流进行报数，但如果需要报出的数是7的倍数或含有数字7则直接跳过。此外大家约定，在总共报出了n个数后（不计入被跳过的数）游戏结束。现在需要你来帮忙统计，游戏过程中每个人各自跳过了几次。

###### 输入形式

从标准输入读入数据。
输入仅一行，包含一个正整数n，表示报出了多少个数后游戏结束。

###### 输出形式

输出到标准输出。
输出共四行，每行一个整数，依次表示甲乙丙丁四人在游戏过程中跳过的次数。

###### 样例输入1

20

###### 样例输出1

2
1
1
0

###### 样例说明1

报数过程为：
甲：1，乙：2，丙：3，丁：4
甲：5，乙：6，丙：跳过，丁：8
甲：9，乙：10，丙：11，丁：12
甲：13，乙：跳过，丙：15，丁：16
甲：跳过，乙：18，：19，丁：20
甲：跳过，乙：22，丙：23，丁：24
在丁报出24后，四个人总计报出了20个数，游戏结束。

###### 样例输入2

66

###### 样例输出2

7
5
11
5

###### 代码

```C++
#include <iostream>
using namespace std;
int n, f[4], cnt = 0;

bool isContain(int num) {
	while (num) {
		if (num % 10 == 7) return true;
		num /= 10;
	}
	return false;
}

int main() {
	int i = 1, num = 0; scanf("%d", &n);
	while (num <= n) {
		if (i % 7 == 0 || isContain(i)) f[cnt]++;
		else num++;
		i++; cnt = (cnt + 1) % 4;
	}
	for (i = 0; i <= 3; i++) printf("%d\n", f[i]);
	return 0;
}
```

### 92.推荐系统

###### 问题描述

某电商有编号为0到m-1的m类商品，包括家电、汽车、电动车、面包、化妆品等。对于每个app新用户，每类商品初始有编号不同的n个商品，包括各个商家、品牌、供应商等。在任何时刻，同类的任意两个商品的编号各不相同，不同类的任意两个商品的编号可能相同。app会给每个商品打分。初始时，各类商品的编号和得分都相同。在用户使用app时，会产生有效信息，包括喜欢、不喜欢等。app会根据这些信息，在某类商品增加或删除商品。app每次会推荐一部分商品给用户看。一个简单的想法是，选出各类所有商品中得分最大的若干商品。
该方法虽然简单，但是如果某类商品可能得分特别高，这种简单想法就无法保证推荐商品的多样性。因此，app查询得分最大的若干商品，同时限制各类商品个数不能超过一个阅值。将上述过程抽象成3中操作：操作1、2、3，分别对应增加、删除、查询操作：
1 type commodity score表示在type类商品中增加编号为commodity的商品，该商品分数为score
2 type commodity表示在type类商品中删除编号为commodity的商品。
3 k k_0 k_1 k_{m-1}表示在各类所有商品中选出不超过K个（不一定要达到K个）得分最大的商品，同时第i（0<=i<m）类商品的个数不超过k_i。在查询时，如果第a（0<=a<m）类商品中编号为b的商品和第A（0<=A<m）类商品中编号为B的商品得分相同：
1，当a=A时，选取编号为min（b，B）的商品；
2，当a≠A时，选取第min（a，A）类商品。

###### 输入形式

从标准输入读入数据。
输入的第一行包含两个正整数m和n，保证n<=3x10^4和m<=50.
接下来n行，每行两个正整数id和score。第1+j（1<=j<=n）行表示所有m类商品的第j个商品的编号和得分。
接下来一行包含一个正整数opnum，表示操作总数，保证n<=10^5。其中，查询操作一共有opask个，保证$opask <= 10^2.$​​
接下来opnum行，每行若干个正整数，格式对应1 type commodity score、2
type commodity、3 K $k_0$​ $k_1$​ … $k_{m-1}$​，其中，$K<=10^2$​​，$k_0$​ $k_1$​ … $k_{m-1}<=10^5.$

###### 输出形式

输出到标准输出。
输出共$opask×m$，对应opask个查询操作。第$r×m+c$，$0\le r<opask$，$1\le c\le m$​行表示，在第r个查询操作中，第c类商品选出的商品编号，同类商品的编号从小到大输出。如果r个查询操作中，第c类商品没有选出任何商品，则该行输出-1

###### 样例输入

```C++
2 3
1 3
2 2
3 1
8
3 100 1 1
1 0 4 3
1 0 5 1
3 10 2 2
3 10 1 1
2 0 1
3 2 1 1
3 1 1 1
```

###### 样例输出

```C++
1
1
1 4
1 2
1
1
4
1
4
-1
```

###### 代码

```C++

```

### 92.小明种苹果

###### 问题描述

小明在他的果园里种了一些苹果树。为了保证苹果的品质，在种植过程中要进行若干轮疏果操作，也就是提前从树上把不好的苹果去掉。第一轮疏果操作开始前，小明记录了每棵树上苹果的个数。每轮疏果操作时，小明都记录了从每棵树上去掉的苹果个数。在最后一轮疏果操作结束后，请帮助小明统计相关的信息。

###### 输入形式

从标准输入读入数据。
第1行包含两个正整数N和M，分别表示苹果树的棵数和疏果操作的轮数。
第1+i行$（1\le i\le N）$，每行包含M+1个整数$a_{i0},a_{i1},...,a_{iM}$。其中为$a_{i0}$正整数，表示第一轮疏果操作开始前第；棵树上苹果的个数。1$a_{ij}(i\le j\le M）$为零或负整数，表示第j轮疏果操作时从第i棵树上去掉的苹果个数。如果为零，表示没有去掉苹果；如果为负，其绝对值为去掉的苹果个数。
每行中相邻两个数之间用一个空格分隔。

###### 输出形式

输出到标准输出。
输出只有一行，包含三个整数T、k和P，其中，
T为最后一轮疏果操作后所有苹果树上剩下的苹果总数（假设苹果不会因为其他原因减少）
k为疏果个数（也就是疏果操作去掉的苹果个数）最多的苹果树编号（如有并列，输出满足条件的最小编号）；P为该苹果树的疏果个数。
相邻两个数之间用一个空格分隔。输入数据保证是正确的，也就是说，每棵树在全部疏果操作结束后剩下的苹果个数是非负的。

###### 样例输入1

```
3 3
73 -8 -6 -4
76 -5 -10 -8
80 -6 -15 0
```

###### 样例输出1

```
167 2 23
```

###### 样例解释1

第1棵苹果树的疏果个数为$8+6+4=18$​，第2棵为$5+10+8=23$​，第3棵为$6+15+0= 21$​​，因此最后一轮疏果操作后全部苹果树上的苹果个数总和为
$(73-18)+(76-23)(80-21)= 167$​，疏果个数最多的是第2棵数，其疏果个数为23.

###### 样例输入2

```
2 2
10 -3 -1
15 -4 0
```

###### 样例输出2

```
17 1 4
```

###### 样例解释2

两棵树的疏果个数均为4，应该输出编号最小的第1棵树。

###### 代码

```C++

```

### 93.小明种苹果(续)

###### 问题描述

小明在他的果园里种了一些苹果树，这些苹果树排列成一个圆。为了保证苹果的品质，在种植过程中要进行疏果操作。为了更及时地完成疏果操作，小明会不时地检查每棵树的状态，根据需要进行疏果。检查时，如果发现可能有苹果从树上掉落，小明会重新统计树上的苹果个数（然后根据之前的记录就可以判断是否有苹果掉落了），在全部操作结束后，请帮助小明统计相关的信息。

###### 输入形式

从标准输入读入数据。
第1行包含一个正整数N，表示苹果树的棵数。
第1+i行（1<=i<=N），每行的格式为 *m**i*，*a**i*1，*a**i*2 *... a*    *i**m**i*  其中，第一个正整数 *m**i* 表示本行后面的整数个数。后续的 *m**i* 个整数表示小明对第i棵苹果树的操作记录。若 *a**i**j*（1<=j<= *m**i*）为正整数，则表示小明进行了重新统计该棵树上的苹果个数的操作，统计的苹果个数为 *a**i**j* ；若为零或负整数，则表示一次疏果操作，去掉的苹果个数是 | *a**i**j* | 输入保证一定是正确的，满足：
1、*a**i*1>0，即对于每棵树的记录，第一个操作一定是统计苹果个数（初始状态，此时不用判断是否有苹果掉落）；
2、每次疏果操作保证操作后树上的苹果个数仍为正。

###### 输出形式

输出到标准输出。
输出只有一行，包含三个整数T、D、E，其中，
T为全部疏果操作结束后所有苹果树上剩下的苹果总数（假设每棵苹果树在最后一次统计苹果个数操作后苹果不会因为疏果以外的原因减少）；
D为发生苹果掉落的苹果树的棵数；
E为相邻连续三棵树发生苹果掉落情况的组数。
对于第三个统计量的解释：N棵苹果树A1，A2...ANA1，A2...AN排列成一个圆，那么A1A1与A2A2相邻，A2A2与A3A3相邻，…AN−1AN−1与ANAN相邻，ANAN与A1A1相邻。如果Ai−1，Ai，Ai+1Ai−1，Ai，Ai+1这三棵树都发生了苹果掉落的情况，则记为一组。形式化的，有E=∣{Ai,∣Drop(Pred(Ai))∧Drop(Ai)∧Drop(Suce(A))}∣E=∣{Ai,∣Drop(Pred(Ai))∧Drop(Ai)∧Drop(Suce(A))}∣
其中，Drop(Ai)Drop(Ai)表示苹果树A，是否发生苹果掉落的情况，Pred(Ai)Pred(Ai)表示AiAi的前一棵树Ai−1Ai−1（如果i>1）或者ANAN（如果i=1），Succ(Ai)Succ(Ai)表示AiAi的后一棵树Ar+1Ar+1（如果i<N）或者A1A1（如果i=N）

###### 样例输入1

```
4
4 74 -7 -12 -5
5 73 -8 -6 59 -4
5 76 -5 -10 60 -2
5 80 -6 -15 59 0
```

###### 样例输出1

```
222 1 0
```

###### 样例说明1

全部操作结束后，第1棵树上剩下的苹果个数为74-7-12-5=50，第2棵为59-4=55，第3棵为60-2=58，第4棵为59-0=59，因此T=50+55+58+59 = 222。
其中，第3棵树在第2次统计之前剩下的苹果个数为76-5-10=61>60，因此发生了苹果掉落的情况。可以检验其他的树没有这种情况，因此D=1。
没有连续三棵树都发生苹果掉落的情况，因此E=0

###### 样例输入2

```
5
4 10 0 9 0
4 10 -2 7 0
2 10 0
4 10 -3 5 0
4 10 -1 8 0
```

###### 样例输出2

```
39 4 2
```

###### 样例说明2

全部操作结束后，第1棵树上剩下的苹果个数为74-7-12-5=50，第2棵为59-4=55，第3棵为60-2=58，第4棵为59-0=59，因此T=50+55+58+59 = 222。
其中，第3棵树在第2次统计之前剩下的苹果个数为76-5-10=61>60，因此发生了苹果掉落的情况。可以检验其他的树没有这种情况，因此D=1。
没有连续三棵树都发生苹果掉落的情况，因此E=0

### 94.消息传递接口

###### 题目背景

消息传递接口（MPI）是一个并行计算的应用程序接口，常用于超级计算机、计算机集群等环境下的程序设计。

###### 问题描述

老师给了 T 份 MPI 的样例代码，每份代码都实现了 n 个进程通信。这些进程标号从 0 到 n − 1，每个进程会顺序执行自己的收发指令，如：“S x”，“R x”。“S x”表示向x 号进程发送数据，“R x”表示从 x 号进程接收数据。每一对收发命令必须匹配执行才能生效，否则会“死锁”。
举个例子，x 号进程先执行发送命令“S y”，y 号进程必须执行接送命令“R x”，这一对命令才执行成功。否则 x 号进程会一直等待 y 号进程执行对应的接收命令。反之，若 y 号进程先执行接收命令“R x”，则会一直等待 x 号进程执行发送命令“S y”，若 x号进程一直未执行发送命令“S y”，则 y 号进程会一直等待 x 号进程执行对应的发送命令。上述这样发送接收命令不匹配的情况都会造成整个程序出现“死锁”。另外，x
号进程不会执行“S x”或“R x”，即不会从自己的进程收发消息。.现在老师请你判断每份样例代码是否会出现“死锁”的情况。每个进程的指令最少有 1 条，最多有 8 条，这些指令按顺序执行，即第一条执行完毕，才能执行第二条，依次到最后一条。

###### 输入形式

从标准输入读入数据。
输入第一行两个正整数 T, n，表示有 T 份样例代码，实现了 n 个进程通信。
接下来有 T × n 行，每行有若干个（1 − 8 个）字符串，相邻之间有一个空格隔开，表示相应进程的收发指令。不存在非法指令。对于第 2 + i, 0 ≤ i ≤ (T × n − 1) 行，表示第 i ÷ n（商）份代码的 i KQ/ n（余数）号进程的收发指令。
（比如，“S1”表示向 1 号进程发送消息，“R1”表示从 1 号进程接收消息。细节请参考样例。）

###### 输出形式

输出到标准输出。
输出共 T 行，每行一个数字，表示对应样例代码是否出现“死锁”的情况。1 表示死锁，0 表示不死锁。

###### 样例输入1

```
3 2
R1 S1
S0 R0
R1 S1
R0 S0
R1 R1 R1 R1 S1 S1 S1 S1
S0 S0 S0 S0 R0 R0 R0 R0
```

###### 样例输出1

```
0
1
0
```

###### 样例说明1

第 1 份代码中，（1）0 号进程执行的“R1”和 1 号进程执行的“S0”成功执行；（2）0 号进程执行的“S1”和 1 号进程执行的“R0”成功执行，所以未发生“死锁”，程序顺利运行。
第 2 份代码中，（1）0 号进程执行的“R1”和 1 号进程执行的“R0”一直在等待发送命令，进入“死锁”状态。

###### 样例输入2

```
2 3
R1 S1
R2 S0 R0 S2
S1 R1
R1
R2 S0 R0
S1 R1
```

###### 样例输出1

```
0
1
```

###### 样例说明1

第 1 份代码中，（1）2 号进程执行的“S1”和 1 号进程执行的“R2”成功执行；（2）0 号进程执行的“R1”和 1 号进程执行的“S0”成功执行；（3）0 号进程执行的“S1”和 1 号进程执行的“R0”成功执行；（4）1 号进程执行的“S2”和 2 号进程执行的“R1”成功执行；所以未发生“死锁”，程序顺利运行。
第 2 份代码中，（1）2 号进程执行的“S1”和 1 号进程执行的“R2”成功执行；（2）
0 号进程执行的“R1”和 1 号进程执行的“S0”成功执行；（3）1 号进程执行的“R0”
和 2 号进程执行的“R1”一直在等待发送命令；进入“死锁”状态。

###### 代码

```C++

```

### 95.游戏

###### 问题描述

　　有*n*个小朋友围成一圈玩游戏，小朋友从1至*n*编号，2号小朋友坐在1号小朋友的顺时针方向，3号小朋友坐在2号小朋友的顺时针方向，……，1号小朋友坐在*n*号小朋友的顺时针方向。
　　游戏开始，从1号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加1。若一个小朋友报的数为*k*的倍数或其末位数（即数的个位）为*k*，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。
　　例如，当n=5, k=2时：
　　1号小朋友报数1；
　　2号小朋友报数2淘汰；
　　3号小朋友报数3；
　　4号小朋友报数4淘汰；
　　5号小朋友报数5；
　　1号小朋友报数6淘汰；
　　3号小朋友报数7；
　　5号小朋友报数8淘汰；
　　3号小朋友获胜。

　　给定*n*和*k*，请问最后获胜的小朋友编号为多少？

###### 输入形式

　　输入一行，包括两个整数*n*和*k*，意义如题目所述。

###### 输出形式

　　输出一行，包含一个整数，表示获胜的小朋友编号。

###### 样例输入

```
5 2
```

###### 样例输出

```
3
```

###### 样例输入

```
7 3
```

###### 样例输出

```
4
```

###### 评分标准

对于所有评测用例，$1 ≤ n ≤ 1000，1 ≤ k ≤ 9$。

###### 代码

```C++
#include <iostream>
using namespace std;
int n, k, cnt = 1;
bool f[1005];

int main() {
	scanf("%d%d", &n, &k);
	int left = n, i = 1;
	while (left > 1) {
		if (i % k == 0 || i % 10 == k) {
			f[cnt] = true;
			left--;
		}
		do{
			cnt = (cnt + 1) % n;
			if (!cnt) cnt = n;
		} while (f[cnt]);
		i++;
	}
	printf("%d", cnt);
	return 0;
}
```

### 96.Crontab

![crontab1.png](https://cslabcg.whu.edu.cn/userfiles/image/15214255032460394774333.png)

###### 代码

```C++

```

### 97.行车路线

###### 问题描述

　　小明和小芳出去乡村玩，小明负责开车，小芳来导航。
　　小芳将可能的道路分为大道和小道。大道比较好走，每走1公里小明会增加1的疲劳度。小道不好走，如果连续走小道，小明的疲劳值会快速增加，连续走*s*公里小明会增加*s*2的疲劳度。
　　例如：有5个路口，1号路口到2号路口为小道，2号路口到3号路口为小道，3号路口到4号路口为大道，4号路口到5号路口为小道，相邻路口之间的距离都是2公里。如果小明从1号路口到5号路口，则总疲劳值为(2+2)2+2+22=16+2+4=22。
　　现在小芳拿到了地图，请帮助她规划一个开车的路线，使得按这个路线开车小明的疲劳度最小。

###### 输入形式

　　输入的第一行包含两个整数*n*, *m*，分别表示路口的数量和道路的数量。路口由1至*n*编号，小明需要开车从1号路口到*n*号路口。
　　接下来*m*行描述道路，每行包含四个整数*t*, *a*, *b*, *c*，表示一条类型为*t*，连接*a*与*b*两个路口，长度为*c*公里的双向道路。其中*t*为0表示大道，*t*为1表示小道。保证1号路口和*n*号路口是连通的。

###### 输出形式

　输出一个整数，表示最优路线下小明的疲劳度。

###### 样例输入

```
6 7
1 1 2 3
1 2 3 2
0 1 3 30
0 3 4 20
0 4 5 30
1 3 5 6
1 5 6 1
```

###### 样例输出

```
76
```

###### 样例说明

从1走小道到2，再走小道到3，疲劳度为$5^2=25$；然后从3走大道经过4到达5，疲劳度为$20+30=50$；最后从5走小道到6，疲劳度为1。总共为76。

###### 评分标准

对于30%的评测用例，1 ≤ *n* ≤ 8，1 ≤ *m* ≤ 10；
对于另外20%的评测用例，不存在小道；
对于另外20%的评测用例，所有的小道不相交；
对于所有评测用例，1 ≤ *n* ≤ 500，1 ≤ *m* ≤ 105，1 ≤ *a*, *b* ≤ *n*，*t*是0或1，*c* ≤ 105。保证答案不超过106。

###### 代码

```C++

```

### 98.迷宫

###### 题目描述

X 星球的一处迷宫游乐场建在某个小山坡上。它是由 10 \times 1010×10 相互连通的小房间组成的。

房间的地板上写着一个很大的字母。我们假设玩家是面朝上坡的方向站立，则：

- L*L* 表示走到左边的房间，
- R*R* 表示走到右边的房间，
- U*U* 表示走到上坡方向的房间，
- D*D* 表示走到下坡方向的房间。

X 星球的居民有点懒，不愿意费力思考。他们更喜欢玩运气类的游戏。这个游戏也是如此！

开始的时候，直升机把 100100 名玩家放入一个个小房间内。玩家一定要按照地上的字母移动。

迷宫地图如下：

UDDLUULRUL
UURLLLRRRU
RRUURLDLRD
RUDDDDUUUU
URUDLLRRUU
DURLRLDLRL
ULLURLLRDU
RDLULLRDDD
UUDDUDUDLL
ULRDLUURRR

请你计算一下，最后，有多少玩家会走出迷宫，而不是在里边兜圈子？

###### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
char a[15][15];
int ans = 0;
int visited[10][10];

void dfs(int i, int j){
  if(i < 0 || i > 9|| j < 0 || j > 9) {
    ans++; return;
  }
  else{
    if(visited[i][j]) return;
    visited[i][j] = 1;
    if(a[i][j] == 'U') dfs(i - 1, j);
    else if(a[i][j] == 'D') dfs(i + 1, j);
    else if(a[i][j] == 'R') dfs(i, j + 1);
    else if(a[i][j] == 'L') dfs(i, j - 1);
  }
}

int main(){
  // 请在此输入您的代码
  int i, j;
  for(i = 0; i < 10; i++){
    for(j = 0; j < 10; j++) cin >> a[i][j];
  }
  for(i = 0; i < 10; i++){
    for(j = 0; j < 10; j++){
      memset(visited, 0, sizeof visited);
      dfs(i, j);
    }
  }
  printf("%d", ans);
  return 0;
}
```

### 99.跳蚂蚱

###### 题目描述

如下图所示： 有 99 只盘子，排成 11 个圆圈。 其中 88 只盘子内装着 88 只蚱蜢，有一个是空盘。 我们把这些蚱蜢顺时针编号为 11 ~ 88。

![图片描述](https://doc.shiyanlou.com/courses/uid1580206-20210317-1615963722953)

每只蚱蜢都可以跳到相邻的空盘中， 也可以再用点力，越过一个相邻的蚱蜢跳到空盘中。

请你计算一下，如果要使得蚱蜢们的队形改为按照逆时针排列， 并且保持空盘的位置不变（也就是 1-81−8 换位，2-72−7换位,...），至少要经过多少次跳跃？

###### 运行限制

- 最大运行时间：1s
- 最大运行内存: 128M

###### 代码

```C++
#include<iostream>
#include<queue>
#include<set>
using namespace std;

//局面字符串，0位置，步数
struct node{
	string str;
	int pos;
	int step;
	node(string str,int pos,int step):str(str),pos(pos),step(step){	}
}; 
queue<node> q;//广搜队列 
set<string> visited; //已经搜索过的情况 

//no当前操作元素，i空盘子跳的状态 
void insertq(node no,int i){
	string s = no.str;
//	交换过后,新的字符串未存在过 
	swap(s[no.pos],s[(no.pos+i+9)%9]);
	if(visited.count(s)==0) {
//	if(visited.find(s)==visited.end()) {
//		放入set容器和队列 
		visited.insert(s);
		node n(s,(no.pos+i+9)%9,no.step+1);
		q.push(n);
	}
}
int main(){
//	空盘子视为0 
	node first("012345678",0,0);
	q.push(first);
	while(!q.empty()){
//		对队首元素操作 
		node temp = q.front();
		if(temp.str=="087654321"){
			cout<<temp.step<<endl;
			break;
		}
		else{
			insertq(temp,-1);
			insertq(temp,1);
			insertq(temp,-2);
			insertq(temp,2);
//			相当于对队首元素四种操作执行完之后弹出队列 
			q.pop();
		}
	} 
	return 0;
}
```

### 100.螺旋矩阵下标

###### 题目描述:

一个 n 行 n 列的螺旋矩阵可由如下方法生成：

从矩阵的左上角（第 1 行第 1 列）出发，初始时向右移动；如果前方是未曾经过的格子， 则继续前进，否则右转；重复上述操作直至经过矩阵中所有格子。根据经过顺序，在格子中 依次填入 1, 2, 3, ... , n^2，便构成了一个螺旋矩阵。

现给出矩阵大小 n 以及 i 和 j，请你求出该矩阵中第 i 行第 j 列的数是多少。

###### 输入格式:

输入共一行，包含三个整数 n，i，j，每两个整数之间用一个空格隔开，分别表示矩阵大小、待求的数所在的行号和列号。

###### 输出格式:

输出共一行，包含一个整数，表示相应矩阵中第 i 行第 j 列的数。

###### 限制:

空间限制：128MByte
时间限制：1秒

###### 数据说明 

对于 50%的数据，1 ≤ n ≤ 100; 

对于 100%的数据，1 ≤ n ≤ 30,000，1 ≤ i ≤ n，1 ≤ j ≤ n。 

###### 代码

```C++
#include <iostream>
using namespace std;
 
int n,x,y;
int main(){
    scanf("%d %d %d", &n, &x, &y);
 
    int p = 1, q = 0;
    int t = 0;
    while (n > 0){
        //判断在不在外圈
 
        if( (x == p && y > q && y <= q + n)
        ||  (x == p + n - 1 && y > q && y <= q + n)
        ||  (x >= p && x <= p + n - 1 && y == q + 1)
        ||  (x >= p && x <= p + n - 1 && y == q + n)
        ) {
            for (int i = 1; i <= n; ++i) {
                q++;
                t++;
                if (p == x && q == y) {
                    printf("%d", t);
                    return 0;
                }
            }
 
            for (int i = 1; i <= n - 1; ++i) {
                p++;
                t++;
                if (p == x && q == y) {
                    printf("%d", t);
                    return 0;
                }
            }
 
            for (int i = 1; i <= n - 1; ++i) {
                q--;
                t++;
                if (p == x && q == y) {
                    printf("%d", t);
                    return 0;
                }
            }
 
            for (int i = 1; i <= n - 2; ++i) {
                p--;
                t++;
                if (p == x && q == y) {
                    printf("%d", t);
                    return 0;
                }
            }
 
        }else{
            t += 4*n - 4;
            p ++;
            q ++;
        }
        n -= 2;
    }
    return 0;
}
```

