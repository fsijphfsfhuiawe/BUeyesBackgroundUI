# 算法竞赛技巧

### 一、register关键字

register 关键字会引导变量存储在寄存器中， 而不是内存，寄存器中存取得速度远远优与内存，但是寄存器数量有限，因此可以把少量频繁使用得变量设为 register 关键字，由此加快代码运行速度。

例如：临时的循环变量 i 就很适合使用 register

```C++
for (register int i = 1; i <= M; ++i) {
		cout << i << endl;
}
```

注意！

register 变量必须时单个值（不能是数组），并且长度小于等于整形长度

### 二、Cin，Cout加速代码

这个代码可以使 cin， cout 执行效率贴近 scanf 和 printf
但是 cin， cout 不能和 scanf， printf 混用了

```C++
ios::sync_with_stdio(false);
cin.tie(0);
cout.tie(0);
```

### 三、快读

#### 快读int模板

```C++
inline int readInt(){
    register int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*f;
}
```

#### 快读long long模板

```C++
inline long long readLL(){
	register long long x=0;int f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*f;
}
```

#### 快读char模板

```C++
inline char readChar(){
	return getchar();
}
```

#### 快读char*模板

```C++
void readCStr(char *str){
		char c = getchar();
		while (blank(c)) c = getchar();
		int p = 0;
		for (str[p++] = c; !blank(c = getchar()); str[p++] = ch);
		c[p] = '\0';
}
bool blank(char c){
    return c == ' ' || c == '\r' || c == '\n' || c == '\t';
}
```

#### 快读string模板

```C++
// 在char*模板的基础上进行转换
string readString(){
    char strBuf[10000];
    readCStr(strBuf);
    string s = strBuf;
    return s;
}
```

#### 三、inline关键字

可以给函数加速

#### 四、$0x3f3f3f3f$

$0x3f3f3f3f$是一个很神奇的数字。当需要把一个数组中的数值初始化成 正无穷 时，为了避免加法算数上溢或者繁琐的判断，可以使用#include<cstring>头文件中的 memset() 函数 memset(a, 0x3f, sizeof a) 给数组赋值成 $0x3f3f3f3f $的值来代替。这个数转换成十进制为：$1061109567 $它的两倍为：$2122219134$。而 int 的最大值为：$2147483647$。所以在很多题目中用它表示正无穷可以更加方便我们写程序。

#### 五、运算优化

##### 5.1取模优化

```C++
inline int MOD(int x, int y){
	return x - y * (x / y);
}
```

对$2^k$取模：实际等同于和$2^k - 1$进行“位与”操作

```C++
inline int MOD(int x, int y){	// x % 2^y
	x = x & (pow(2, y) - 1);
}
```

##### 5.2加法优化

用`++i`代替`i++`。 

1. 后置++需要保存临时变量以返回之前的值，在 STL 中非常慢。 
2. 事实上，int的后置++ 在实测中也比前置++ 慢0.5倍左右

##### 5.3数组优化

1. 不要开bool，所有bool改成char，int是最快的。 
2. 在最大值50000*50000的时候用unsigned代替long long 
3. 对于多维数组，用到乘法优化寻址

##### 5.4判断优化

1. if()else语句比()?():()语句要慢
2. 逗号运算符比分号运算符要快

##### 5.5结构优化

1. 如果你要经常调用a[x],b[x],c[x]这样的数组，把她们写在同一个结构体里面会变快一些，比如f[x].a, f[x].b, f[x].c 
2. 指针比下标快

##### 5.6位运算优化

```C++
10x     等价于 x << 3 + x << 1
x != y  等价于 x ^ y
x != -1 等价于 ~x
2x + 1  等价于 x << 1 | 1
x / 2   等价于 x >> 1
(x + 1) % 2 等价于 x ^ 1
x % 2   等价于 x & 1
```

#### 六、函数替代

```C++
inline int Min(int a, int b) {return a < b ? a : b;}
```

```C++
inline void swap(int &a, int &b){a ^= b, b ^= a, a ^= b;}
```

```C++
inline void equal_min(int &a, int b){if(a > b) a = b;}
```

#### 七、常用头文件

```C++
#include <algorithm>
#include <iostream>
#include <cstring>
#include <climits>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <queue>
#include <stack>
#include <map>
#include <set>
#define Re register
#define LL long long
#define U unsigned
#define FOR(i,a,b) for(Re int i = a;i <= b;++i)
#define ROF(i,a,b) for(Re int i = a;i >= b;--i)
#define SFOR(i,a,b,c) for(Re int i = a;i <= b;i+=c)
#define SROF(i,a,b,c) for(Re int i = a;i >= b;i-=c)
#define CLR(i,a) memset(i,a,sizeof(i))
#define BR printf("--------------------\n")
#define DEBUG(x) std::cerr << #x << '=' << x << std::endl
```

