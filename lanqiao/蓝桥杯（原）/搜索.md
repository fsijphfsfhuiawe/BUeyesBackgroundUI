# 搜索

### P1443 马的遍历

#### 代码

```C++
#include <iostream>
#include <queue>
#include <string.h>
using namespace std;
typedef pair<int, int> P;
const int maxn = 405;
const int dx[8] = {-1, -2, -2, -1, 1, 2, 2, 1};
const int dy[8] = {2, 1, -1, -2, 2, 1, -1, -2};
bool vis[maxn][maxn];
int dis[maxn][maxn];	// 存储步数
int n, m, x, y;

void bfs(){
	vis[x][y] = true;
	queue<P> que; que.push(P(x, y));
	memset(dis, -1, sizeof dis);
	dis[x][y] = 0;
	while(!que.empty()){
		P p = que.front(); que.pop();
		for(int i = 0; i < 8; i++){
			int u = p.first + dx[i], v = p.second + dy[i];
			if(u < 1 || u > n || v < 1 || v > m || vis[u][v]) continue;
			dis[u][v] = dis[p.first][p.second] + 1;
			vis[u][v] = true;
			que.push(P(u, v));
		}
	}
}

int main() {
	scanf("%d%d%d%d", &n, &m, &x, &y);
	bfs();
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++) printf("%-5d", dis[i][j]);
		printf("\n");
	}
	system("pause");
	return 0;
}
```

#### 知识点

BFS、搜索、队列



### P1747 好奇怪的游戏

#### 代码

```
#include <iostream>
#include <queue>
#include <string.h>
using namespace std;
typedef pair<int, int> P;
const int maxn = 25;
const int dx[12] = {-1, -2, -2, -1, 1, 2, 2, 1, -2, 2, 2, -2};
const int dy[12] = {2, 1, -1, -2, 2, 1, -1, -2, -2, 2, -2, 2};
bool vis[maxn][maxn];
int dis[maxn][maxn];	// 存储步数

void bfs(int x, int y){
	vis[x][y] = true;
	queue<P> que; que.push(P(x, y));
	memset(vis, 0, sizeof vis);
	memset(dis, -1, sizeof dis);
	dis[x][y] = 0;
	while(!que.empty()){
		P p = que.front(); que.pop();
		if(p.first == 1 && p.second == 1) break;
		for(int i = 0; i < 12; i++){
			int u = p.first + dx[i], v = p.second + dy[i];
			if(u < 1 || u > maxn || v < 1 || v > maxn || vis[u][v]) continue;
			dis[u][v] = dis[p.first][p.second] + 1;
			vis[u][v] = true;
			que.push(P(u, v));
		}
	}
}

int main() {
	int x1, y1, x2, y2; scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
	bfs(x1, y1);
	printf("%d\n", dis[1][1]);
	bfs(x2, y2);
	printf("%d\n", dis[1][1]);
	return 0;
}
```

#### 知识点

BFS、搜索、队列



### P1746 离开中山路

```C++
#include<iostream>
#include<queue>
using namespace std;
struct Pos
{
	int x,y;
};
queue <Pos> q;
int n,x,y,tx,ty,dis[1001][1001],s_a,s_b,t_a,t_b;
const int dx[]={1,-1,0,0};
const int dy[]={0,0,1,-1};
char mp[1001][1001];
bool vis[1001][1001];
int bfs(int sx,int sy)
{
	q.push((Pos){sx,sy});
	vis[sx][sy]=true;
	while(!q.empty())
	{
		x=q.front().x;
		y=q.front().y;
		q.pop();
		if(x==t_a&&y==t_b) return dis[x][y];
		for(int i=0;i<4;i++)
		{
			tx=x+dx[i];
			ty=y+dy[i];
			if(tx<=0||tx>n||ty<=0||ty>n) continue;
			if(mp[tx][ty]=='1'||vis[tx][ty]==true) continue;
			dis[tx][ty]=dis[x][y]+1;
			vis[tx][ty]=true;
			q.push((Pos){tx,ty});
		}
	}
	return -1;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=n;j++)
	        cin>>mp[i][j];
	cin>>s_a>>s_b>>t_a>>t_b;
	cout<<bfs(s_a,s_b);
	return 0;
}
```

#### 知识点

BFS、搜索、队列



### P1331 海战

#### 思想

如果图是不合法的，在一个$2\times 2$的方格中，有三个$\#$

#### 代码

```C++
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int r,c;
char map[1010][1010];
int fx[4]={0,-1,1,0};
int fy[4]={-1,0,0,1};
int dfs(int x,int y){
	map[x][y]='*';
	for(int i=0;i<4;i++){
		if(x+fx[i]>0&&x+fx[i]<=r&&y+fy[i]>0&&y+fy[i]<=c&&
		map[x+fx[i]][y+fy[i]]=='#')dfs(x+fx[i],y+fy[i]);
	}
}//把与#连通的所有点改成*因为它们是同一艘船 
bool d(int i,int j){
	int c=0;
	if(map[i][j]=='#')c++;
	if(map[i+1][j]=='#')c++;
	if(map[i][j+1]=='#')c++;
	if(map[i+1][j+1]=='#')c++;
	if(c==3)return 0;
	return 1;
}//判断是否合法 
int main(){
	scanf("%d%d",&r,&c);
	register int i,j;
	for(i=1;i<=r;i++){
		for(j=1;j<=c;j++){
		cin>>map[i][j];
		}
	}
	int s=0;
	for(i=1;i<=r;i++){
		for(j=1;j<=c;j++){
			if(i<r&&j<c&&d(i,j)==0){
				printf("Bad placement.");
				return 0;//不合法后面就没必要继续了 
			}
		}
	}
	for(i=1;i<=r;i++){
		for(j=1;j<=c;j++){
			if(map[i][j]=='#'){
			s++;
			dfs(i,j);	
			}//因为前面已经确保了是合法的，现在只需统计船的数量 
		}
	}
	printf("There are %d ships.",s);
	return 0;
}
```

#### 知识点

DFS、搜索



### [P1087 [NOIP2004 普及组\] FBI 树](https://www.luogu.com.cn/problem/P1087)

```C++
#include <iostream>
using namespace std;

struct node{
	char ch;
	node *lchild = NULL;
	node *rchild = NULL;
};

char judge(string s){
	int res = 0;
	for(register int i = 0; i < s.size(); i++){
		res += s[i] - '0';
	}
	if(res == 0) return 'B';
	else if(res < s.size()) return 'F';
	else return 'I';
}

node* build(string s){
	node* head = new node();
	head->ch = judge(s);
	if(s.size() >= 2){
		head->lchild = build(s.substr(0, s.size() >> 1));
		head->rchild = build(s.substr(s.size() >> 1, s.size() >> 1));
	}
	return head;
}

void dfs(node *head){
	if(head->lchild != NULL) dfs(head->lchild);
	if(head->rchild != NULL) dfs(head->rchild);
	putchar(head->ch);
}

int main() {
	int N; scanf("%d", &N);
	string s; cin >> s;
	node *head = build(s);
	dfs(head);
	system("pause");
	return 0;
}
```

#### 知识点：

DFS、二叉树后序遍历。



### P1596 [USACO10OCT]Lake Counting S

```C++
#include <iostream>
using namespace std;
const int maxn = 105;
const int dx[8] = {0, -1, -1, -1, 0, 1, 1, 1};
const int dy[8] = {1, 1, 0, -1, -1, -1, 0, 1};
char mp[maxn][maxn];
int N, M; 

void dfs(int x, int y){
	if(mp[x][y] == '.') return;
	mp[x][y] = '.';
	for(int i = 0; i < 8; ++i){
		int u = x + dx[i], v = y + dy[i];
		if(0 <= u && u < N && 0 <= v && v < M && mp[u][v] == 'W'){
			dfs(u, v);
		}
	}
}

int main() {
	scanf("%d%d", &N, &M);
	register int i, j;
	int res = 0;
	for(i = 0; i < N; ++i){
		for(j = 0; j < M; ++j) cin >> mp[i][j];
	}
	for(i = 0; i < N; ++i){
		for(j = 0; j < M; ++j){
			if(mp[i][j] == 'W'){
				++res;
				dfs(i, j);
			}
		}
	}
	printf("%d", res);
	system("pause");
	return 0;
}
```

#### 知识点

DFS、联通性问题



### P1141 01迷宫

#### 思想1：

BFS：

#### 思想2：

很显然这是一道求连通块的题目，只需构造点到节点一一映射：$(i,j)=i\times n+j$，即可套用并查集。

#### 思想3：

DFS:

#### 代码

```C++

```

#### 知识点

BFS、DFS、并查集



### P2298 Mzc和男家丁的游戏

```C++
#include <iostream>
#include <cstring>
#include <queue>
#define P pair<int, int>
using namespace std;
int n, m, sx, sy, dx, dy, dis[2005][2005];
const int bx[4] = {0, -1, 0, 1};
const int by[4] = {1, 0, -1, 0};
char s[2005][2005];

int bfs(){
    queue<P> que; que.push(P(sx, sy));
    s[sx][sy] = '#';
    while (!que.empty()){
        P p = que.front(); que.pop(); 
        if(p.first == dx && p.second == dy) return dis[dx][dy];
        for(register int i = 0; i < 4; ++i){
            int u = p.first + bx[i], v = p.second + by[i];
            if(u < 0 || u >= n || v < 0 || v >= m || s[u][v] == '#') continue;
            que.push(P(u, v));
            s[u][v] = '#'; dis[u][v] = dis[p.first][p.second] + 1;
        }
    }
    return -1;
}

int main() {
    scanf("%d%d", &n, &m);
    register int i, j;
    for(i = 0; i < n; ++i) scanf("%s", s[i]);
    for(i = 0; i < n; ++i){
        for(j = 0; j < m; ++j) {
            if(s[i][j] == 'm') sx = i, sy = j;
            if(s[i][j] == 'd') dx = i, dy = j;
        }
    }
    if(bfs() != -1) printf("%d", dis[dx][dy]);
    else puts("No Way!");
    system("pause");
    return 0;
}
```



### P1332 血色先锋队

假设感染源的坐标为$(x_i,y_i),(1\le i\le a)$，假设一个先锋队队长的坐标为$(p,q)$，则其感染的时间为
$$
T=\min_{i=1}^a(|x_i-p|+|y_i-q|)
$$

```C++
#include <iostream>
#include <vector>
#define INF 0x3f3f3f3f
#define P pair<int, int>
using namespace std;
vector<P> vec;

int main() {
    int n, m, a, b; scanf("%d%d%d%d", &n, &m, &a, &b);
    register int i, j, x, y;
    for(i = 1; i <= a; ++i){
        scanf("%d%d", &x, &y);
        vec.push_back(P(x, y));
    }
    for(i = 1; i <= b; ++i){
        int res = INF;
        scanf("%d%d", &x, &y);
        for(j = 0; j < a; ++j){
            res = min(res, abs(vec[j].first - x) + abs(vec[j].second - y));
        }
        printf("%d\n", res);
    }
    return 0;
}
```



### P1451 求细胞数量

```C++
#include<bits/stdc++.h> 
using namespace std;
struct pp
{
	int x,y;
};
deque<pp> q;//队列 
int n,m,ans=0;//n行m列，ans为答案 
int a[105][105];//存矩阵 
bool used[105][105];//记录是否走过 
int dx[4]={-1,1,0,0};//向上下左右走一步行号和列好的改变 
int dy[4]={0,0,-1,1};
void bfs(int sx,int sy)//bfs 
{
	pp st;
	st.x=sx;st.y=sy;
	used[sx][sy]=1;
	q.push_back(st);
	while(!q.empty())
	{
		pp nw=q.front();
		for(int i=0;i<4;i++)
		{
			pp nxt=nw;
			nxt.x+=dx[i];
			nxt.y+=dy[i];
			if(a[nxt.x][nxt.y]==0 || used[nxt.x][nxt.y]==1) continue;
			used[nxt.x][nxt.y]=1;//把这一连通块的点染色 
			q.push_back(nxt);
		}
		q.pop_front();
	}
}
int main()
{
	cin>>n>>m;
	memset(a,0,sizeof(a));
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++) 
			scanf("%1d",&a[i][j]);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(used[i][j]==0 && a[i][j]!=0)
			{
			    bfs(i,j);
			    ans++;//若这一连通块没搜过ans++ 
			}
		}
	}
	cout<<ans;	
	return 0;
}
```



### P1162 填涂颜色

搜索边框上为$0$，即不被包裹在$1$内的，将他们赋值为$3$。最后将所有的$3$还原为$0$，$1$原样输出，$0$填充为$2$

```C++
#include <iostream>
#include <queue>
#define P pair<int, int>
using namespace std;
int maze[35][35], n, res;
const int dx[4] = {0, -1, 0, 1};
const int dy[4] = {1, 0, -1, 0};

void bfs(int x, int y){
    queue<P> que; que.push(P(x, y));
    int a, b;
    while (!que.empty()){
        P p = que.front(); que.pop();
        maze[p.first][p.second] = 3;
        for(register int i = 0; i < 4; ++i){
            a = p.first + dx[i], b = p.second + dy[i];
            if(a < 1 || a > n || b < 1 || b > n || maze[a][b]) continue;
            que.push(P(a, b));
        }
    }
}

int main() {
    scanf("%d", &n);
    register int i, j;
    for(i = 1; i <= n; ++i)
        for(j = 1; j <= n; ++j) scanf("%d", &maze[i][j]);

    for(i = 1; i <= n; ++i){
        if(!maze[i][1]) bfs(i, 1);
        if(!maze[i][n]) bfs(i, n);
    }
    for(j = 1; j <= n; ++j){
        if(!maze[1][j]) bfs(1, j);
        if(!maze[n][j]) bfs(n, j);
    }
    for(i = 1; i <= n; ++i){
        for(j = 1; j <= n; ++j){
            if(maze[i][j] == 3) printf("0 ");
            else if(!maze[i][j]) printf("2 ");
            else printf("1 ");
        }
        printf("\n");
    }
    return 0;
}
```



### P1683 入门

```C++
#include<iostream>
#include<string>
using namespace std;
string str;
int h,w,head=0,tail=1,p1[4]={1,0,0,-1},p2[4]={0,1,-1,0},ans,fx[1001],fy[1001],x,y;  //纯手工队列！
bool l[1001][1001]={false};  //是否走过或能否走
int main(){
    cin>>w>>h;
    for(int i=1;i<=h;i++){
        cin>>str;
        for(int j=0;j<w;j++){
            if(str[j]=='@'){
                fx[1]=i;
                fy[1]=j+1;
            }
            if(str[j]=='#') l[i][j+1]=true;
        }
    }
    do {
        head++;
        for(int i=0;i<=3;i++){
            x=fx[head]+p1[i];
            y=fy[head]+p2[i];
            if(!l[x][y]&&x<=h&&y<=w&&x>=1&&y>=1){
                ans++;
                l[x][y]=true;
                tail++;
                fx[tail]=x;
                fy[tail]=y;
            }
        }
    }while(head<tail);
    cout<<ans<<endl;   
    return 0;
}
```

