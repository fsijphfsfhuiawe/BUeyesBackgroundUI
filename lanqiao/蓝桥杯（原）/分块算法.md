# 分块算法

所谓分块算法，就是讲一个序列分成若干块，维护块内的信息。为了保证一定的时间复杂度，所以对于一个n个元素组成的数组，将其分为√n块，每块也有√n个元素。所以一般分块算法的复杂中都带有根号。

对于一个暴力的区间修改问题，方法自然是对于区间的每一个元素都暴力修改，这样的话时间复杂度是明显不够优秀的。所以引入了分块的算法，分块相当于一种优雅的暴力。

在分块中，我们需要维护的基本内容有：总的元素个数nn，每一块的个数block，块的总数目num，这块左端点的位置l[i]，这块右端点的位置r[i]，元素data[i]具体属于那一块，根据具体情况，可以适当修改。

### 预处理：

```C++
int sq = sqrt(n);
for (int i = 1; i <= sq; ++i)
{
    st[i] = n / sq * (i - 1) + 1; // st[i]表示i号块的第一个元素的下标
    ed[i] = n / sq * i; // ed[i]表示i号块的最后一个元素的下标
}
```

但是，数组的长度并不一定是一个完全平方数，所以这样下来很可能会漏掉一小块，我们把它们纳入最后一块中：

```
ed[sq] = n;
```

然后，我们为每个元素确定它所归属的块：

```C++
for (int i = 1; i <= sq; ++i)
    for (int j = st[i]; j <= ed[i]; ++j)
        bel[j] = i; // 表示j号元素归属于i块

```

最后，如果必要，我们再预处理每个块的大小：

```C++
for (int i = 1; i <= sq; ++i)
    size[i] = ed[i] - st[i] + 1;
```



### 洛谷P3372 线段树1

**题目描述**
如题，已知一个数列，你需要进行下面两种操作：

将某区间每一个数加上 k。
求出某区间每一个数的和。

**输入格式**
第一行包含两个整数 n, m，分别表示该数列数字的个数和操作的总个数。
第二行包含 n 个用空格分隔的整数，其中第 i 个数字表示数列第 i 项的初始值。
接下来 m 行每行包含 3 或 4 个整数，表示一个操作，具体如下：
`1 x y k`：将区间 [x, y] 内每个数加上 k 。
`2 x y`：输出区间 [x, y] 内每个数的和。

这个题数据范围只有 ![[公式]](https://www.zhihu.com/equation?tex=10%5E5) ，可以用分块。我们用一个`sum` 数组来记录每一块的和，`mark`数组来做标记（注意这两者要分开，因为处理零散块时也要用到标记）。

#### 读入和预处理数据

```C++
for(int i = 1; i <= n; i++){
  A[i] = read();
}
for(int i = 1; i <= sq; ++i){
  for(int j = st[i]; j <= ed[i]; ++j){
    sum[i] += A{j};		// sum[i]保存第i个快的和
  }
}
```

#### 区间修改

首先是区间修改，当x与y在同一块内时，直接暴力修改原数组和`sum`数组：

```C++
if(bel[x] == bel[y]){
  for(int i = x; i <= y; i++){
    A[i] += k;
    sum[bel[i]] += k;
  }
}
```

否则，先暴力修改左右两边的零散区间：

```C++
for (int i = x; i <= ed[bel[x]]; ++i)
{
    A[i] += k;
    sum[bel[i]] += k;
}
for (int i = st[bel[y]]; i <= y; ++i)
{
    A[i] += k;
    sum[bel[i]] += k;
}
```

然后对中间的整块打上标记：

```C++
for (int i = bel[x] + 1; i < bel[y]; ++i)
    mark[i] += k;
```

#### 区间查询

同样地，如果左右两边在同一块，直接暴力计算区间和。

```C++
if (bel[x] == bel[y])
    for (int i = x; i <= y; ++i)
        s += A[i] + mark[bel[i]]; // 注意要加上标记
```

否则，暴力计算零碎块：

```C++
for (int i = x; i <= ed[bel[x]]; ++i)
    s += A[i] + mark[bel[i]];
for (int i = st[bel[y]]; i <= y; ++i)
    s += A[i] + mark[bel[i]];
```

再处理整块：

```C++
for (int i = bel[x] + 1; i < bel[y]; ++i)
    s += sum[i] + mark[i] * size[i]; // 注意标记要乘上块长
```