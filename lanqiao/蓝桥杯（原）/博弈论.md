# 博弈论

### 1.Bash Game

#### 题目

有一堆石子共有$N$个。$A、B$两个人轮流拿，$A$先拿。每次最少拿$1$颗，最多拿$m$颗，拿到最后$1$颗石子的人获胜。假设$A、B$都非常聪明，拿石子的过程中不会出现失误。给出$N$和$m$，问最后谁能赢得比赛。

#### 思想

若$n=k\times (m+1),k=1,2,\dots$则先取者必输

```C++
int Bash_Game(int n, int m){ // 是否有先手必赢策略
    if(n % (m + 1)) return 1;
    else return 0;
}
```



### 2.Nimm Game

#### 题目

有$N$堆石子，每堆有$M_i$个物品。$A、B$两个人轮流拿，$A$先拿。每次只能从一堆中取若干个，可将一堆全取走，但不可不取，拿到最后$1$颗石子的人获胜。假设$A、B$都非常聪明，拿石子的过程中不会出现失误。给出$N$及每堆石子的数量，问最后谁能赢得比赛。

#### 思想

$M_1\bigoplus M_2\bigoplus\dots \bigoplus M_n\neq0\to$必胜态。

$M_1\bigoplus M_2\bigoplus\dots \bigoplus M_n=0\to$必败态。

可以证明必败态只可以转换为必胜态，必胜态总是可以转换为必败态。

#### 代码

```C++
int Nimm_Game(int n){ //假设n个数存在数组f[]中,有必胜策略返回1
    int flag = 0;
    for(register int i = 1; i <= n; ++i) flag ^= f[i];
    if(flag) return 1;
    return 0;
}
```

#### 优化代码

```C++
//读入n，表示有从物品数分别1到n的n堆物品，假设n个数存在数组f[]中,每一堆的物品数为连续的整数
int xor_n(int n){
    int t = n & 3;
    if(t & 1) return t / 2 ^ 1;
    return t / 2 ^ n;
}
int Nimm_Game(int n){
    
}
```



### 3.Wythoff Game

#### 题目

有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。

#### 思路

我们用$(a_k,b_k),(a_k\le b_k,k=0,1,2,\dots,n)$表示两队物品的数量并称之为局势。如果甲面对（0，0），那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。

 可以看出,a0=b0=0,ak是未在前面出现过的最小自然数,而 bk= ak + k，奇异局势有
如下三条性质：

1. 任何自然数都包含在一个且仅有一个奇异局势中。由于ak是未在前面出现过的最小自然数，所以有ak > ak-1 ，而 bk= ak + k > ak-1 + k-1 = bk-1 > ak-1 。所以性质1。成立。

2. 任意操作都可将奇异局势变为非奇异局势。事实上，若只改变奇异局势（ak，bk）的某一个分量，那么另一个分量不可能在其他奇异局势中，所以必然是非奇异局势。如果使（ak，bk）的两个分量同时减少，则由于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势

3. 采用适当的方法，可以将非奇异局势变为奇异局势。假设面对的局势是（a,b），若 b = a，则同时从两堆中取走 a 个物体，就变为了奇异局势（0，0）；如果a = ak ，b > bk，那么，取走b – bk个物体，即变为奇异局势；如果 a = ak ， b < bk ,则同时从两堆中拿走 ak – ab – ak个物体,变为奇异局势（ ab – ak , ab – ak+ b – ak）；如果a > ak ，b= ak + k,则从第一堆中拿走多余的数量a – ak 即可；如果a < ak ，b= ak + k,分两种情况，第一种，a=aj （j < k）,从第二堆里面拿走 b – bj 即可；第二种，a=bj （j < k）,从第二堆里面拿走 b – aj 即可。

4.  从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，则后拿者取胜。

5.  那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式：

    ak =[k（1+√5）/2]，bk= ak + k （k=0，1，2，…,n 方括号表示取整函数)

#### 代码

```C++
#include<bits/stdc++.h>
using namespace std;
int n, m;
const double lorry = (sqrt(5.0) + 1.0) / 2.0;
int main() {
    scanf("%d%d",&n,&m);
    if(n < m) swap(n, m);
    int a = n - m;
    if(m == int(lorry * (double)a)) puts("0");
    else puts("1");
    return 0;
}
```

