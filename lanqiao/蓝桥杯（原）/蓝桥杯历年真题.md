# 蓝桥杯历年真题

## 2021年第十二届

### 第一题：平面分割

#### 题目描述

20个圆和20条直线最多能把平面分成多少个部分?

#### 题目代码

```C++
#include <bits/stdc++.h>
using namespace std;

int cal(int n){
	int ans = 2;
	for(int i = 2; i <= n; i++) ans += (i - 1) * 2;	
	ans += n * 2;
	for(int i = 2; i <= n; i++){
		ans += 2 * n + i;
	}
	return ans;
}

int main(){
	printf("%d", cal(20));
	return 0;
} 
```

#### 题目解答

直线分割平面公式：$1/2（N^2+N+2)$
封闭曲线平面分割公式：$n^2-n+2$
折线平面分割公式：$f(n)=2n^2-n+1$
平面分割空间公式：$f(n)=(n^3+5n)/6+1$



### 第二题：数字三角形

#### 题目描述

![图片描述](https://doc.shiyanlou.com/courses/uid1580206-20210224-1614154063705)

上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。

路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右 边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过$ 1$。

#### 输入描述

输入的第一行包含一个整数$ N\ (1 \leq N \leq 100)$，表示三角形的行数。

下面的$ N$行给出数字三角形。数字三角形上的数都是$ 0 $至$ 100 $之间的整数。

#### 输出描述

输出一个整数，表示答案。

#### 运行限制

- 最大运行时间：$1s$
- 最大运行内存: $256M$

#### 代码

```C++
#include <iostream>
using namespace std;
int c[200][200], n;
int main()
{
  	scanf("%d", &n);
  	for(int i = 1; i <= n; i++){
  		for(int j = 1; j <= i; j++){
			int temp; scanf("%d", &temp);
  			c[i][j] = temp + max(c[i - 1][j], c[i - 1][j - 1]);
	  	}
	}
	printf("%d", max(c[n][(n + 1) >> 1], c[n][(n + 2) >> 1]));
  	system("pause");
 	return 0;
}
```



### 第三题 作物杂交

#### 题目描述

作物杂交是作物栽培中重要的一步。已知有 N种作物 (编号 1至 N)，第 i种作物从播种到成熟的时间为$ T_i$。作物之间两两可以进行杂交，杂交时间取两种中时间较长的一方。如作物 A 种植时间为 5 天，作物 B 种植时间为 7 天，则 AB 杂交花费的时间为 7 天。作物杂交会产生固定的作物，新产生的作物仍然属于 N种作物中的一种。

初始时，拥有其中 M*M* 种作物的种子 (数量无限，可以支持多次杂交)。同时可以进行多个杂交过程。求问对于给定的目标种子，最少需要多少天能够得到。

如存在 4 种作物 ABCD，各自的成熟时间为 5 天、7 天、3 天、8 天。初始拥有 AB 两种作物的种子，目标种子为 D，已知杂交情况为 A × B → C，A × C → D。则最短的杂交过程为：

第 1 天到第 7 天 (作物 B 的时间)，A × B → C。

第 8 天到第 12 天 (作物 A 的时间)，A × C → D。

花费 12 天得到作物 D 的种子。

#### 输入描述

输入的第 1 行包含 4 个整数 N, M, K, T，N表示作物种类总数 (编号 1 至 N)，M表示初始拥有的作物种子类型数量，K表示可以杂交的方案数，T表示目标种子的编号。

第 2 行包含 N个整数，其中第 i个整数表示第 i种作物的种植时间 $T_i\ (1 \leq T_i \leq 100)$。

第 3 行包含 M个整数，分别表示已拥有的种子类型 $K_j\ (1 \leq K_j \leq M)$两两不同。

第 4 至$ K+ 3 $行，每行包含 3 个整数 $A, B,C$表示第$ A$类作物和第$ B$类作物杂交可以获得第$ C$类作物的种子。

其中$，1 \leq N \leq 2000, 2 \leq M \leq N, 1 \leq K \leq 10^5, 1 \leq T \leq N, $保证目标种子一定可以通过杂交得到。

#### 输出描述

输出一个整数，表示得到目标种子的最短杂交时间。

#### 运行限制

- 最大运行时间：2s
- 最大运行内存: 256M

#### 代码

```C++
#include <iostream>
#include <algorithm>
#include <queue>
#include <cstring>
using namespace std;
const int maxn = 2020;
const int maxk = 2E5+10;
int grow[maxn];
bool have[maxn];
int edge[maxk], head[maxn], ne[maxk], cost[maxk], target[maxk], idx = 1;
int getcost(int u, int v) {return max(grow[u], grow[v]);}
void add(int u, int v, int c, int t)
{
    edge[idx] = v;
    cost[idx] = c;
    ne[idx] = head[u];
    head[u] = idx;
    target[idx] = t;
    idx++;
}
struct Node{
    int id, cost;
    bool operator > (const Node &x) const {return cost > x.cost;}
};
priority_queue<Node, vector<Node>, greater<Node> > heap;
int dist[maxn];
int main()
{
    int N, M, K, T;
    cin >> N >> M >> K >> T;
    memset(dist, 0x3f, sizeof dist);
    for(int i = 1; i <= N; ++i)
        cin >> grow[i];
    for(int i = 0; i < M; ++i)
    {
        int u;
        cin >> u;
        have[u] = 1;
        dist[u] = 0;
    }
    for(int i = 0; i < K; ++i)
    {
        int u, v, c, t;
        cin >> u >> v >> t;
        c = getcost(u, v);
        if(have[u] && have[v] && c < dist[t])
        {
            dist[t] = c;
            Node temp = {t, c};
            heap.push(temp);
        }
        add(u, v, c, t);
        add(v, u, c, t);
    }
    while(!have[T])
    {
        Node p = heap.top();
        heap.pop();
        if(!have[p.id])
        {
            have[p.id] = 1;
            for(int i = head[p.id]; i; i = ne[i])
            {
                int to = edge[i], c = cost[i], tar = target[i];
                int bet = dist[p.id];
                if(!have[tar] && have[to] && bet+c < dist[tar])
                {
                    dist[tar] = bet+c;
                    Node temp = {tar, dist[tar]};
                    heap.push(temp);
                }
            }
        }
    }
    cout << dist[T];
    return 0;
}
```



### 2021年第十二届

#### 双向排序

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210429211716488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70)

##### 思想

[(28条消息) 蓝桥杯 I.双向排序_Jozky86的博客-CSDN博客_蓝桥杯双向排序](https://blog.csdn.net/qq_35975367/article/details/116277383)

##### 代码（栈）

```C++
#include <iostream>
#include <cstring>
#include <algorithm>
#define x first
#define y second
#define PII pair<int, int>
#define N 100010
using namespace std;
int n, m;
PII stk[N];
int ans[N];

int main() {
    scanf("%d%d", &n, &m);
    int top = 0;
    while(m--){
        int p, q; scanf("%d%d", &p, &q);
        if(!p){ // 前缀操作
            while(top && stk[top].x == 0) q = max(q, stk[top--].y);
            while(top >= 2 && stk[top-1].y <= q) top -= 2;
            stk[++top] = {0, q};
        }else if(top){  // 第一个操作不会是后缀操作
            while(top && stk[top].x  == 1) q = min(q, stk[top--].y);
            while(top >= 2 && stk[top-1].y >= q) top -= 2; 
            stk[++top] = {1, q};
        }
    }
    int k = n, l = 1, r = n;
    for(register int i = 1; i <= top; ++i){
        if(stk[i].x  == 0)
            while(r > stk[i].y && l <= r) ans[r--] = k--;
        else  
            while(l < stk[i].y && l <= r) ans[l++] = k--;
        if(l > r) break;
    }
    if(top & 1)
        while(l <= r) ans[l++] = k--;
    else 
        while(l <= r) ans[r--] = k--;
    for(register int i = 1; i <= n; ++i) printf("%d ", ans[i]);
    return 0;
}
```

##### 代码（文艺平衡树）

```C++

```



#### 分果果

##### 题目描述

小蓝要在自己的生日宴会上将 $n$包糖果分给 $m$ 个小朋友。每包糖果都要分出去，每个小朋友至少要分一包，也可以分多包。

小蓝已经提前将糖果准备好了，为了在宴会当天能把糖果分得更平均一些，小蓝要先计算好分配方案。 小蓝将糖果从 $1$ 到 $n$ 编号，第 $i $包糖果重$ w_i$。小朋友从 $1$ 到 $m$ 编号。每个小朋友只能分到编号连续的糖果。小蓝想了很久没想出合适的分配方案使得每个小朋友分到的糖果差不多重。因此需要你帮他一起想办法。为了更好的分配糖果，他可以再买一些糖果，让某一些编号的糖果有两份。当某个编号的糖果有两份时，一个小朋友最多只能分其中的一份。

请找一个方案，使得小朋友分到的糖果的最大重量和最小重量的差最小，请输出这个差。

##### 评测用例规模与约定

对于所有评测用例，$1≤n≤100，1≤m≤50，1≤w_i≤100$。在评测数据中，$w_i$ 随机生成，在某个区间均匀分布。

##### 思想(DP)

##### 代码

```C++
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const int M = 51, N = 101;

int n, m, w[N], f[M][N][N], st[N], ans = 0x7fffffff;

int main(){
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++){
        scanf("%d", &w[i]);
        w[i] += w[i - 1];
    }
    for(int minw = 1; minw <= 2 * w[n] / m; minw++){
        memset(f, 0x7f, sizeof(f));
        f[0][0][0] = minw;
        for(int i = 1; i <= m; i++) {
            for(int j = 0; j <= n; j++){
                *st = 0;
                int p = 0, pst = 1;
                for(int k = j; k <= n; k++){
                    if(j > 0) f[i][j][k] = f[i][j - 1][k];
                    while(w[k] - w[p] >= minw){
                        if(p >= j){
                            while(*st && f[i - 1][j][p] <= f[i - 1][j][st[*st]])
                                (*st)--;
                            st[++*st] = p;
                        }
                        p++;
                    }
                    if(*st){
                        pst = min(pst, *st);
                        while(pst < *st && f[i - 1][j][st[pst + 1]] < w[k] - w[st[pst + 1]])
                            pst++;
                        while(pst > 1 && f[i - 1][j][st[pst]] > w[k] - w[st[pst]])
                            pst--;
                        f[i][j][k] = min(f[i][j][k], max(f[i - 1][j][st[pst]], w[k] - w[st[pst]]));
                        if(pst < *st)
                            f[i][j][k] = min(f[i][j][k], max(f[i - 1][j][st[pst + 1]], w[k] - w[st[pst + 1]]));
                    }
                    int pp = min(p - 1, j);
                    if(pp >= 0)
                        f[i][j][k] = min(f[i][j][k], max(f[i - 1][pp][j], w[k] - w[pp]));
                }
            }
        }
        ans = min(ans, f[m][n][n] - minw);
    }
    printf("%d", ans);
    return 0;
}

```



#### 括号序列

![img](https://img-blog.csdnimg.cn/3a0edb79ac1248a9a5e394d53dc9f2ac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Im-5ZOl5ZOl5b6I5qOS,size_20,color_FFFFFF,t_70,g_se,x_16)

##### 思想：

合法括号序列的要求：

- 左右括号数相同
- 任意前缀的左括号数不小于右括号数

$dp[i][j]$表示前$i$个括号，并且左括号比右括号多$j$个的所有方案数。

若$s[i]='('$，则$dp[i][j]=dp[i-1][j-1]$

若$s[i]=')'$，则$dp[i][j]=dp[i-1][j+1]+dp[i-1][j]+\dots+dp[i-1][0]=dp[i-1][j-1]+dp[i][j-1]$

##### 代码

```C++
#include <iostream>
#include <cstring>
#include <algorithm>
#define mod 1000000007
#define LL long long
#define N 5010
using namespace std;

int n;
char str[N];
LL f[N][N];

LL calc(){
    memset(f, 0, sizeof f);
    f[0][0] = 1;
    for (register int i = 1; i <= n; ++i) {
        if(str[i] == '('){
            for(register int j = 1; j <= n; ++j) 
                f[i][j] = f[i - 1][j - 1];
        }else{
            f[i][0] = (f[i - 1][0] + f[i - 1][1]) % mod;
            for(register int j = 1; j <= n; ++j){
                f[i][j] = (f[i - 1][j + 1] + f[i][j - 1]) % mod;
            }
        }
    }
    for(register int i = 0; i <= n; ++i){
        if(f[n][i]) return f[n][i];
    }
    return -1;
}

int main() {
    scanf("%s", str + 1);
    n = strlen(str + 1);
    LL l = calc();
    reverse(str + 1, str + n + 1);
    for(register int i = 1; i <= n; ++i){
        if(str[i] == '(') str[i] = ')';
        else str[i] = '(';
    }
    LL r = calc();
    printf("%lld\n", l * r % mod);
    system("pause");
    return 0;
}
```

