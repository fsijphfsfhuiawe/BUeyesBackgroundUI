

# 数论

### P1029 [NOIP2001 普及组] 最大公约数和最小公倍数问题

##### 辗转相除法求最大公因数

$$
x\times y=gcd(x,y)\times lcm(x, y)
$$

```C++
#include <iostream>
#include <cmath>
#define ll long long
using namespace std;
int x, y, ans, flag; 
ll gcd(ll u, ll v){
    if(!v) return u;
    return gcd(v, u % v);
}

int main() {
    scanf("%d%d", &x, &y);
    for(register int i = 1; i <= sqrt(1ll * x * y); ++i){
        if((1ll * x * y) % i == 0 && gcd(i, (1ll * x * y) / i) == x){
            ans++;
            if(1ll * i * i == 1ll * x * y) flag = 1;
        }
    }
    printf("%d", (ans << 1) - flag);
    system("pause");
    return 0;
}
```



### P4549 【模板】裴蜀定理

##### 裴蜀定理

$$
ax+by=c,x\in Z^*,y\in Z^*成立的充要条件为gcd(a,b)|c
$$

##### 裴蜀定理的推广

$$
\sum_{i=1}^na_ix_i=f,其中a_i,x_i,f\in Z有解的充要条件gcd(a_1,a_2,\dots,a_n)|f
$$

```C++
#include <iostream>
using namespace std;
int gcd(int a, int b){
    if(!b) return a;
    return gcd(b, a % b);
}

int main() {
    int n, res, tmp; scanf("%d", &n);
    for(register int i = 1; i <= n; ++i){
        if(i == 1) scanf("%d", &res);
        else{
            scanf("%d", &tmp); tmp = abs(tmp);
            res = gcd(res, tmp);
        }
    }
    printf("%d", res);
    return 0;
}
```



### P3383 【模板】线性筛素数

```C++
#include <iostream>
#include <vector>
#define MAXN 100000010
using namespace std;
bool isPrime[MAXN];
int n, q, k;
vector<int> prime;
int main() {
    scanf("%d%d", &n, &q);
    register int i, j;
    for(i = 2; i <= n; ++i) isPrime[i] = true;
    for(i = 2; i <= n; ++i){
        if(isPrime[i]) prime.push_back(i);
        for(j = 0; j < prime.size() && i * prime[j] <= n; ++j){
            isPrime[i * prime[j]] = false;
            if(i % prime[j] == 0) break;
        }
    }
    while(q--){
        scanf("%d", &k);
        printf("%d\n", prime[k - 1]);
    }
    return 0;
}
```



### P4213 【模板】杜教筛（Sum）

#### 积性函数

积性函数：对于任意互质的整数$ a,b $有$ f(ab)=f(a)f(b) $的数论函数。

完全积性函数：对于任意整数$ a,b$有 $f(ab)=f(a)f(b)$的数论函数。

- 常见的积性函数：$\varphi,\mu,\sigma,d$
  - $\varphi(n)$表示所有不超过$n$的与$n$互质的数的个数
  - 莫比乌斯函数$ \mu(n) =\begin{cases}1,n=1\\(-1)^s,n=p_1p_2\dots p_s,p_1<p_2<\dots<p_s\\0,others\end{cases}$
  - $\sigma(n)$定义为整数$n$的所有正因子之和
  - $d(n)$定义为$n$的所有正除数的个数，含$1$和$n$本身
- 常见的完全积性函数：$\epsilon,I,id$

这里特殊解释一下 $\epsilon,I,id$分别是什么意思：$ \epsilon(n) = [n=1], I(n) = 1, id(n) = n$

#### 狄利克雷卷积

设$ f, g$ 是两个数论函数，它们的狄利克雷卷积是：$(f*g)(n) = \sum \limits _{d | n} f(d) g(\frac{n}{d})$

性质：满足交换律，结合律

单位元：$\epsilon$（即$ f*\epsilon=f$）

结合狄利克雷卷积得到的几个性质：

1. $\mu * I = \epsilon$
2. $\varphi * I = id$
3. $\mu * id = \varphi$

#### 莫比乌斯反演

若$g(n) = \sum\limits_{d|n}f(d)$

则$f(n)=\sum\limits_{d|n}\mu(d)g(\frac{n}{d})$

证明：

1. 这里需要用到前面提到的性质$：\mu * I = \epsilon$

2. 给出的条件等价于$ g=f * I$

3. 所以$ g*\mu=f*I*\mu=f*\epsilon=f$即$ g * \mu = f$即 结论。

#### 杜教筛

设现在要求积性函数$ f $的前缀和， 设 $\sum \limits_{i=1}^{n} f(i) = S(n)$,再找一个积性函数$ g$，可以得到下面的式子：
$$
g(1)S(n)=\sum_{i=1}^n(f*g)(i)-\sum_{i=2}^ng(i)S(\lfloor\frac{n}{i}\rfloor)
$$
如果可以找到一个合适的积性函数$ g$，使得可以快速算出$ \sum\limits_{i=1}^{n}(f*g)(i)$和 $g $的前缀和，便可以用数论分块递归地求解。

如果有$f*g=h$，那么有
$$
\sum\limits_{i=1}^n h(i)=\sum\limits_{i=1}^n f(i)\sum\limits_{j=1}^{\lfloor\frac ni\rfloor} g(j)
$$

```C++
ll GetSum(int n) { // 算 f 前缀和的函数
  ll ans = f_g_sum(n); // 算 f * g 的前缀和
  // 以下这个 for 循环是数论分块
  for(ll l = 2, r; l <= n; l = r + 1) { // 注意从 2 开始
    r = (n / (n / l)); 
    ans -= (g_sum(r) - g_sum(l - 1)) * GetSum(n / l);
    // g_sum 是 g 的前缀和
    // 递归 GetSum 求解
  } return ans; 
}
```

这个代码的时间复杂度为$O(n^{\frac{3}{4}})$

##### $\mu$的前缀和

考虑到莫比乌斯函数的性质$ \mu * I = \epsilon$ ，自然想到取$ f=\mu,g=I,f*g=\epsilon$ 。

##### $ \varphi$的前缀和

考虑到$ \varphi$的性质$ \varphi * I = id$，取$ f = \varphi, g = I, f * g = id$

$f * g$即$ id$的前缀和为$ \frac{n\times (n+1)}{2}$

#### 代码

```C++
#include <cstdio>
#include <cstring>
#include <bitset>
using namespace std;
const int N = 0x7fffffff;
const int MX = 5e6;
int T,n;
int vis[MX + 5],cnt,prime[MX + 5],mu[MX + 5];
long long phi[MX + 5], ans;
int w[MX + 5];
bitset<MX + 5> v;
inline int id(int x){ return n / x; }
int smu(int n) {
    if(n <= MX) return mu[n];
    if(v[id(n)]) return w[id(n)];
    int ret = 1;
    for(register int l = 2,r;l <= n;l = r + 1){
        r = n / (n / l);
        ret -= (r - l + 1) * smu(n / l);
    }
    v[id(n)] = 1;
    return w[id(n)] = ret;
}
int main() {
    mu[1] = phi[1] = 1;
    for(register int i = 2;i <= MX;++i) {
        if(!vis[i]) mu[prime[++cnt] = i] = -1,phi[i] = i - 1;
        for(register int j = 1;j <= cnt && i * prime[j] <= MX;++j){
            vis[i * prime[j]] = 1;
            if(!(i % prime[j])) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            phi[i * prime[j]] = phi[i] * (prime[j] - 1);
            mu[i * prime[j]] = -mu[i];
        }
        mu[i] += mu[i - 1],phi[i] += phi[i - 1];
    }
    scanf("%d",&T);
    while(T--){
        ans = 0,v.reset(),scanf("%d",&n);
        if(n <= MX) printf("%lld %d\n",phi[n],mu[n]);
        else {
            for(register int l = 1,r;l <= n;l = r + 1) {
                r = n / (n / l);
                ans += (long long)(n / l) * (n / l + 1) / 2 * (smu(r) - smu(l - 1));
            }
            printf("%lld %d\n",ans,smu(n));
        }
    }
}
```



### P5091 【模板】扩展欧拉定理

#### 费马小定理

当$ a,p\in \mathbb{Z}$ 且$ p$为质数，且$ a\not\equiv 0\pmod{p}$ 时
$$
a^{p-1}\equiv1\mod p\\a^b\equiv a^{b\mod p-1}\mod p
$$


#### 欧拉定理

$φ(n) $表示小于等于$ n$的正整数中与$ n$互质的数的个数（欧拉函数）
$$
a\text{ 与 }m\text{ 互质时，}a^{\varphi(m)}\equiv1\mod m
$$

#### 扩展欧拉定理

$$
b≥φ(m)时,a^b ≡a ^{(b\modφ(m))+φ(m)} \mod m
$$

#### 代码1

```C++
#include <iostream>
#include <cmath>
#define ll long long
using namespace std;
ll a,m,b;

inline ll read(ll m){
	register ll x=0,f=0;char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)){
		x=x*10+ch-'0';
		if(x>=m) f=1;
		x%=m;ch=getchar();
	}
	return x+(f==1?m:0);
}

ll phi(ll n){
	ll ans=n,m=sqrt(n);
	for(ll i=2;i<=m;i++){
		if(n%i==0){
			ans=ans/i*(i-1);
			while(n%i==0) n/=i;	
		}
	}
	if(n>1) ans=ans/n*(n-1);
	return ans;
}

ll fast_pow(ll a,ll b,ll p){ // 快速幂
	ll ret=1;
	for(;b;b>>=1,a=a*a%p)
		if(b&1) ret=ret*a%p;
	return ret;
}

int main() {
    scanf("%lld%lld",&a,&m);
    b=read(phi(m));
    printf("%lld\n",fast_pow(a,b,m));
    system("pause");
    return 0;
}
```

#### 代码2

```C++
#include <iostream>
#include <cmath>
#define ll long long
using namespace std;
ll a,m,b;

inline ll read(ll m){
	register ll x=0,f=0;char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)){
		x=x*10+ch-'0';
		if(x>=m) f=1;
		x%=m;ch=getchar();
	}
	return x+(f==1?m:0);
}

ll phi(ll n){
	ll ans=n,m=sqrt(n);
	for(ll i=2;i<=m;i++){
		if(n%i==0){
			ans=ans/i*(i-1);
			while(n%i==0) n/=i;	
		}
	}
	if(n>1) ans=ans/n*(n-1);
	return ans;
}

ll quick_mul(ll a, ll b, ll p){
    ll ans = 0;
    for(;b;b >>= 1, a = (a + a) % p)
        if(b&1) ans = (ans + a) % p;
    return ans;
}

ll quick_pow(ll a,ll b,ll p){ // 龟速幂,底数乘方和除数乘方会爆long long时使用
    ll sum = 1;
    for(;b;b>>=1, a = quick_mul(a,a,p)%p)
        if(b&1) sum = quick_mul(sum,a,p)%p;
    return sum;
}

int main() {
    scanf("%lld%lld",&a,&m);
    b=read(phi(m));
    printf("%lld\n",quick_pow(a,b,m));
    system("pause");
    return 0;
}
```



### P3811 【模板】乘法逆元

#### 逆元定义

若$a*x\equiv1 \pmod {b}$，且$a$与$b$互质，那么我们就能定义:$ x$为$ a$的逆元。

一般用于求解$\frac{a}{b}\mod p$：先求出$b$在$\mod p$意义下的逆元，然后乘上$a$，再$\mod p$

#### 求解单个元素的逆元

##### 拓展欧几里得

利用拓欧求解 线性同余方程 $a*x \equiv c \pmod {b}$的$c=1$的情况。我们就可以转化为解$ a*x + b*y = 1$这个方程。

```C++
void Exgcd(ll a, ll b, ll &x, ll &y) {
    if (!b) x = 1, y = 0;
    else Exgcd(b, a % b, y, x), y -= a / b * x;
}
int main() {
    ll x, y;
    Exgcd (a, p, x, y);
    x = (x % p + p) % p;
    printf ("%d\n", x); //x是a在mod p下的逆元
}
```

##### 费马小定理+快速幂

$$
a*x\equiv1\mod p\\a*x\equiv a^{p-1}\mod p\\ x\equiv a^{p-2}\mod p
$$

用快速幂来算出$ a^{p-2} \pmod p$的值，这个数就是它的逆元了

```C++
ll fpm(ll x, ll power, ll mod) {
    x %= mod;
    ll ans = 1;
    for (; power; power >>= 1, (x *= x) %= mod)
    	if(power & 1) (ans *= x) %= mod;
    return ans;
}
int main() {
	ll x = fpm(a, p - 2, p); //x为a在mod p意义下的逆元
}
```

#### 求解一连串数字对于$p$的逆元

首先我们有一个,$1^{-1}\equiv 1 \pmod p$

然后设$ p=k*i+r,(1<r<i<p)$也就是$ k$是$ p / i$的商，$r$是余数 。

再将这个式子放到$(\mod p)$意义下就会得到：
$$
k*i+r \equiv 0 \pmod p
$$
然后乘上$i^{-1},r^{-1}$就可以得到:
$$
k*r^{-1}+i^{-1}\equiv 0 \pmod p\\
i^{-1}\equiv -k*r^{-1} \pmod p\\
i^{-1}\equiv -\lfloor \frac{p}{i} \rfloor*(p \bmod i)^{-1} \pmod p
$$

```C++
inv[1] = 1;
for(int i = 2; i < p; ++ i)
    inv[i] = (p - p / i) * inv[p % i] % p;
```

#### 代码

```C++
#include <iostream>
#include <cstring>
#define MAXN 3000005
using namespace std;
long long inv[MAXN];
int main() {
    int n, p;
    scanf("%d%d", &n, &p);
    inv[1] = 1; puts("1");
    for(register int i = 2; i <= n; ++i){
        inv[i] = (long long)p - (p / i) * inv[p % i] % p;
        printf("%d\n", inv[i]);
    }  
    system("pause");
    return 0;
}
```



### P5656 【模板】二元一次不定方程 (exgcd)



### P1495 【模板】中国剩余定理(CRT)/曹冲养猪



### P3846 [TJOI2007] 可爱的质数/【模板】BSGS



### P6091 【模板】原根



### P4195 【模板】扩展 BSGS/exBSGS



### P4195 【模板】扩展 BSGS/exBSGS



### P5668 【模板】N次剩余



### P3807 【模板】卢卡斯定理/Lucas 定理



### P4720 【模板】扩展卢卡斯定理/exLucas



### P4718 【模板】Pollard-Rho算法



### P4714 「数学」约数个数和



### P5170 【模板】类欧几里得算法





