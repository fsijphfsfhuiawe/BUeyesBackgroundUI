# 平衡树

### 知识介绍

#### 1.Splay树(伸展树)

#### 2.Treap树(树堆)

[Treap（树堆）详解 - Seaway-Fu - 博客园 (cnblogs.com)](https://www.cnblogs.com/fusiwei/p/12884254.html)

#### 3.替罪羊树



### P3369 【模板】普通平衡树

#### 题目描述

您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：

1. 插入 x数
2. 删除 x 数(若有多个相同的数，因只删除一个)
3. 查询 x数的排名(排名定义为比当前数小的数的个数 +1 )
4. 查询排名为 x的数
5. 求 x的前驱(前驱定义为小于 x，且最大的数)
6. 求 x的后继(后继定义为大于 x，且最小的数)

#### 输入格式

第一行为 n，表示操作的个数,下面 n*n* 行每行有两个数$ \text{opt}$和 x，$\text{opt}$表示操作的序号$( 1 \leq \text{opt} \leq 6)$

#### 输出格式

对于操作 3,4,5,6 每行输出一个数，表示对应答案

#### 代码（Treap树）

```C++
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
#include<climits>
#define maxn 100005
#define INF 0x3f3f3f3f
using namespace std;
struct node{
	int size, pri, val, lchild, rchild;
}Tree[maxn];
int tot, root = 0;
inline void maintain(int pos){
	Tree[pos].size = Tree[Tree[pos].lchild].size + Tree[Tree[pos].rchild].size + 1;
}

void R_rotate(int &pos){
	node x = Tree[Tree[pos].lchild];
	Tree[pos].lchild = x.rchild;
	x.rchild = pos;
	x.size = Tree[pos].size;
	maintain(pos);
	Tree[pos] = x;
}
void L_rotate(int &pos){
	node x = Tree[Tree[pos].rchild];
	Tree[pos].rchild = x.lchild;
	x.lchild = pos;
	x.size = Tree[pos].size;
	maintain(pos);
	Tree[pos] = x;
}
void insert(int &pos, int x){
	if(!pos){
		++tot;
		pos = tot;
		Tree[pos].val = x;
		Tree[pos].pri = rand();	
	}else{
		if(x < Tree[pos].val){
			insert(Tree[pos].lchild, x);
			if(Tree[Tree[pos].lchild].pri > Tree[pos].pri) R_rotate(pos);
		}else{
			insert(Tree[pos].rchild, x);
			if(Tree[Tree[pos].rchild].pri > Tree[pos].pri) L_rotate(pos);
		}
	}
	maintain(pos);
}

void remove(int &pos, int x){
	if(!pos) return;
	if(x == Tree[pos].val){
		if(Tree[Tree[pos].lchild].size | Tree[Tree[pos].rchild].size){
			if(Tree[Tree[pos].lchild].pri > Tree[pos].pri) 
				R_rotate(pos), remove(Tree[pos].lchild, x);
			if(Tree[Tree[pos].rchild].pri > Tree[pos].pri)
				L_rotate(pos), remove(Tree[pos].rchild, x);
		} else pos = 0;
		return;
	}
	x < Tree[pos].val ? remove(Tree[pos].lchild, x) : remove(Tree[pos].rchild, x);
	maintain(pos);
}

int Rank(int pos, int x){
	if(!pos) return 1;
	if(x < Tree[pos].val) return Rank(Tree[pos].lchild, x);
	else return Tree[Tree[pos].lchild].size + 1 + Rank(Tree[pos].rchild, x);
}

int Kth(int pos, int k) {
	if(!pos || k <= 0 || k > Tree[pos].size) return -1;
	if(k == Tree[Tree[pos].lchild].size + 1) return Tree[pos].val;
	else if(k <= Tree[Tree[pos].lchild].size) return Kth(Tree[pos].lchild, k);
	else return Kth(Tree[pos].rchild, k);
}

int prev(int pos, int x){
    if(!pos) return -INF;
    if(x < Tree[pos].val) return prev(Tree[pos].lchild, x);
    else return max(Tree[pos].val, prev(Tree[pos].rchild, x));
}

int nxt(int pos, int x){
    if(!pos) return INF;
    if(x >= Tree[pos].val) return nxt(Tree[pos].rchild, x);
    else return min(Tree[pos].val, nxt(Tree[pos].lchild, x));
}

int main() {
	int n, opt, x; 
	scanf("%d", &n);
	while(n--){
		scanf("%d%d", &opt, &x);
		switch (opt) {
		case 1:
			insert(root, x);
			break;
		case 2:
			remove(root, x);
			break;
		case 3:
			printf("%d\n", Rank(root, x));
			break;
		case 4:
			printf("%d\n", Kth(root, x));
			break;
		case 5:
			printf("%d\n", prev(root, x));
			break;
		case 6:
			printf("%d\n", nxt(root, x));
			break;
		}
	}
	system("pause");
	return 0;
}
```



#### 代码（Splay树，推荐）

```C++
#include <iostream>
#define N 201000
#define INF 1000000000
using namespace std;
struct splay_tree{
    int ff, cnt, ch[2], size, val;
}t[N];
int root, tot;

inline void update(int x){
    t[x].size = t[t[x].ch[0]].size + t[t[x].ch[1]].size + t[x].cnt;
}
void rotate(int x){
    int y = t[x].ff, z = t[y].ff;
    int k = (t[y].ch[1] == x);
    t[z].ch[t[z].ch[1] == y] = x;
    t[x].ff = z;
    t[y].ch[k] = t[x].ch[k^1];
    t[t[x].ch[k^1]].ff = y;
    t[x].ch[k^1]=y;
    t[y].ff = x;
    update(y); update(x);
}
void splay(int x, int s){
    while(t[x].ff != s){
        int y = t[x].ff, z = t[y].ff;
        if(z != s) (t[z].ch[0]==y)^(t[y].ch[0]==x)?rotate(x):rotate(y);
        rotate(x);
    }
    if(s == 0) root = x;
}

void find(int x){
    int u = root;
    if(!u) return;
    while(t[u].ch[x>t[u].val] && x != t[u].val) u = t[u].ch[x>t[u].val];
    splay(u, 0);
}

void insert(int x){
    int u = root, ff = 0;
    while (u && t[u].val != x){
        ff = u;
        u = t[u].ch[x>t[u].val];
    }
    if(u) ++t[u].cnt;
    else{
        u = ++tot;
        if(ff) t[ff].ch[x>t[ff].val] = u;
        t[u].ff = ff;
        t[u].val = x;
        t[u].cnt = 1;
        t[u].size = 1;
    }
    splay(u, 0);
}

int Next(int x, int f){
    find(x);
    int u = root;
    if(t[u].val > x && f) return u;
    if(t[u].val < x && !f) return u;
    u = t[u].ch[f];
    while(t[u].ch[f^1]) u = t[u].ch[f^1];
    return u;
}

void Delete(int x){
    int last = Next(x, 0);
    int next = Next(x, 1);
    splay(last, 0);
    splay(next, last);
    int del = t[next].ch[0];
    if(t[del].cnt > 1){
        --t[del].cnt;
        splay(del, 0);
    }else t[next].ch[0] = 0;
}

int kth(int x){
    int u = root;
    while(t[u].size < x) return 0;
    while(1) {
        int y = t[u].ch[0];
        if(x > t[y].size + t[u].cnt){
            x -= t[y].size + t[u].cnt;
            u = t[u].ch[1];
        }else if(x <= t[y].size) u = y;
        else return t[u].val;
    }
}

int main() {
    int n;
    scanf("%d",&n);
    //预先插入INF和-INF 便于处理前驱和后继
	//也使得Delete的写法不会导致死循环
    insert(INF);
    insert(-INF);
    while(n--) {
        int opt,x; scanf("%d%d",&opt,&x);
        if (opt==1) insert(x);
        if (opt==2) Delete(x);
        if (opt==3) {
            find(x);
            printf("%d\n",t[t[root].ch[0]].size);
        }
        if (opt==4) printf("%d\n",kth(x+1));
        if (opt==5) printf("%d\n",t[Next(x,0)].val);
        if (opt==6) printf("%d\n",t[Next(x,1)].val);
    }
    system("pause");
    return 0;
}
```



### P3391 【模板】文艺平衡树

#### 题目描述

您需要写一种数据结构（可参考题目标题），来维护一个有序数列。

其中需要提供以下操作：翻转一个区间，例如原有序序列是5 4 3 2 1，翻转区间是$ [2,4]$的话，结果是5 2 3 4 1。

#### 输入格式

第一行两个正整数$ n,m$表示序列长度与操作个数。序列中第$ i$项初始为$i$。
接下来$ m$行，每行两个正整数$ l,r$表示翻转的区间。

#### 输出格式

输出一行$ n$个正整数，表示原始序列经过$ m$次变换后的结果。

#### 思路

这里的Splay维护的显然不再是权值排序，现在按照的是序列中的编号排序，继续考虑，其实最终的结果也就是整颗Splay的中序遍历

发现，如果一个点在序列中的位置为第K个，那么，他就是平衡树的第K大（就当做普通的Splay来看的话），所以，序列中的位置就变成了区间的第K大点

继续考虑如何翻转，翻转也就是整颗子树的每一个节点的左右儿子交换。因此，只要在根节点的地方打一个标记，在旋转之前下方一下标记就行了，最后输出的时候输出的就是Splay的中序遍历。

#### 代码

```C++
#include<iostream>
using namespace std;
#define MAX 200000
struct Node{
    int ch[2];
    int ff,v;
    int size;
    int mark;
    void init(int x,int fa){
        ff=ch[0]=ch[1]=0;
        size=1;v=x;ff=fa;
    }
}t[MAX];
int N,root,M,tot;
inline void pushup(int x)
{
    t[x].size=t[t[x].ch[0]].size+t[t[x].ch[1]].size+1;
}
inline void pushdown(int x)
{
    if(t[x].mark)
    {
        t[t[x].ch[0]].mark^=1;
        t[t[x].ch[1]].mark^=1;
        t[x].mark=0;
        swap(t[x].ch[0],t[x].ch[1]);
    }
}
inline void rotate(int x)
{
    int y=t[x].ff;
    int z=t[y].ff;
    int k=t[y].ch[1]==x;
    t[z].ch[t[z].ch[1]==y]=x;
    t[x].ff=z;
    t[y].ch[k]=t[x].ch[k^1];
    t[t[x].ch[k^1]].ff=y;
    t[x].ch[k^1]=y;
    t[y].ff=x;
    pushup(y);pushup(x);
}
inline void Splay(int x,int goal)
{
    while(t[x].ff!=goal)
    {
        int y=t[x].ff;int z=t[y].ff;
        if(z!=goal)
            (t[z].ch[1]==y)^(t[y].ch[1]==x)?rotate(x):rotate(y);
        rotate(x);
    }
    if(goal==0)root=x;
}
inline void insert(int x)
{
    int u=root,ff=0;
    while(u)ff=u,u=t[u].ch[x>t[u].v];
    u=++tot;
    if(ff)t[ff].ch[x>t[ff].v]=u;
    t[u].init(x,ff);
    Splay(u,0);
}
inline int Kth(int k)
{
    int u=root;
    while(233)
    {
        pushdown(u);
        if(t[t[u].ch[0]].size>=k)u=t[u].ch[0];
        else if(t[t[u].ch[0]].size+1==k)return u;
        else k-=t[t[u].ch[0]].size+1,u=t[u].ch[1];
    }
}
void write(int u)
{
    pushdown(u);
    if(t[u].ch[0])write(t[u].ch[0]);
    if(t[u].v>1&&t[u].v<N+2)printf("%d ",t[u].v-1);
    if(t[u].ch[1])write(t[u].ch[1]);
}
inline void Work(int l,int r)
{
    l=Kth(l);
    r=Kth(r+2);
    Splay(l,0);
    Splay(r,l);
    t[t[t[root].ch[1]].ch[0]].mark^=1;
}
int main(){
    scanf("%d%d",&N,&M);
    for(int i=1;i<=N+2;++i)insert(i);
    while(M--){
        int l, r; scanf("%d%d", &l, &r);
        Work(l,r);
    }
    write(root);
    printf("\n");
    system("pause");
    return 0;
}
```

