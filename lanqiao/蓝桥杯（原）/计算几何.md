# 计算几何

### P1652 圆

给出$ n$个圆,保证任意两个圆都不相交。然后给出两个点 $(x_1,y_1),(x_2,y_2)$，保证均不在某个圆上，要从 $(x_1,y_1) \to (x_2,y_2)$画条曲线，问这条曲线最少穿过多少次圆的边界？

```C++
#include<cstdio>
#include<cmath>//用到sqrt，即开根
using namespace std;
int x[60],y[60],r[60];//读入的三个数组
double dist(int x1,int y1,int x2,int y2){//求距离的函数
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));//公式
}
int main(){
	int n,x1,y1,x2,y2,ans=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&x[i]);
	for(int i=1;i<=n;i++) scanf("%d",&y[i]);
	for(int i=1;i<=n;i++) scanf("%d",&r[i]);
	scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
	for(int i=1;i<=n;i++)//每个圆都搜一遍
		if((dist(x1,y1,x[i],y[i])<r[i])^(dist(x2,y2,x[i],y[i]))<r[i]) ans++;//如果两个点恰有一个在圆内，就累加上
	printf("%d",ans);//输出总和
	return 0;//华丽结束
}
```



### P2181 对角线

对于一个$ n$个顶点的凸多边形，它的任何三条对角线都不会交于一点。请求出图形中对角线交点的个数。

例如，$6$边形：

![img](https://cdn.luogu.com.cn/upload/pic/6023.png)

#### 思路：

两条对角线的实质是确定了$4$个顶点，从$n$个点中选出$4$个点出来，$C_n^4$

```C++
#include <iostream>
#define ull unsigned long long
using namespace std;

int main() {
    ull n, ans;
    scanf("%lld", &n);
    ans = n * (n - 1) / 2 * (n - 2) / 3 * (n - 3) / 4;
    printf("%lld", ans);
    return 0;
}
```



### P1257 平面上的最接近点对

给定平面上$ n$个点，找出其中的一对点的距离，使得在这$ n$个点的所有点对中，该距离为所有点对中最小的。

#### 分治法

时间复杂度$O(n\log n)$

##### 分解：

对所有的点按照$ x$坐标(或者$ y$)从小到大排序(排序方法时间复杂度 $O(n\log n)$)。根据下标进行分割，使得点集分为两个集合。

##### 合并：

​		最近距离不一定存在于两个集合中，可能一个点在集合 $A$，一个点在集合$ B$，而这两点间距离小于$ dis$。

​		其中如何合并是关键。根据递归的方法可以计算出划分的两个子集中所有点对的最小距离$ disleft,disright$，再比较两者取最小值，即$ dis=\min(dis_{left},dis_{right})$。那么一个点在集合$ A$，一个在集合 $B$中的情况，可以针对此情况，用之前分解的标准值，即按照$ x$坐标(或者$ y$ )从小到大排序后的中间点的 $x $坐标作为 $mid$。划分一个 $[mid-dis,mid+dis]$区域，如果存在最小距离点对，必定存在这个区域中。
![img](https://cdn.luogu.com.cn/upload/pic/60270.png)
  之后只需要根据左边区域$ [mid-dis,mid]$的点来遍历右边区域$ [mid,mid+dis]$的点，即可找到是否存在小于 $dis$ 距离的点对。

​		但是存在一个最坏情况，即通过左右两个区域计算得到的 $dis$ 距离来划分的第三区域可能包含集合所有的点，这时候进行遍历查找，时间复杂度仍然和 brute force 方法相同，都为$O(n^2)$

​		$1985$年 $Preparata$ 和 $Shamos$ 在给出该问题的一个分治算法并且还具体分析了在$ [mid-dis,mid+dis] $区域中出现的情况，若$ (p,q)$是 $Q$的最近点对，$p$ 在带域左半部分，则 $q$点必在下图所示的$ \delta* 2\delta$长方形上，而在该长方形上，最多只能由右边点集的$6$个点。每个点对之间的距离不小于$δ$。 ![img](https://cdn.luogu.com.cn/upload/pic/60272.png)

  此结论很好证明，通过在$ \delta* 2\delta$ 上以$ \frac{2\delta}{3}* \frac{\delta}{2}$划成$ 6$个小长方形 ![img](https://cdn.luogu.com.cn/upload/pic/60273.png)

  用反证法来证明，假设存在大于$6$个点，则必有一个或多个小长方形存在两个及以上点，而小长方形的最长距离是为对角线长度，为： $\sqrt{(\frac{2\delta}{3}*\frac{2\delta}{3}+\frac{\delta}{2}*\frac{\delta}{2})}=\frac{5}{6}\delta<\delta$。最长距离都小于$δ$，与之前的条件不符合，故最多有$6$个点。借此，可以将可能的线性时间缩小到常数级，大大提高了平均时间复杂度。

#### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
struct point{
    double x,y;
}p[200010];
int n,temp[200010];
bool cmp(const point &A, const point &B){
    if(A.x == B.x) return A.y < B.y;
    else return A.x < B.x;
}
bool cmps(const int &a,const int &b){
    return p[a].y<p[b].y;
}
double distance(int i,int j){
    return sqrt((p[i].x-p[j].x)*(p[i].x-p[j].x)+(p[i].y-p[j].y)*(p[i].y-p[j].y));
}
double merge(int left,int right){
    double dis=2<<20;
    if(left==right) return dis;
    if(left+1==right) return distance(left,right);
    int mid=(left+right)>>1;
    double d1=merge(left,mid);
    double d2=merge(mid+1,right);
    dis=min(d1,d2);
    int k=0;
    for(register int i=left;i<=right;++i)
        if(fabs(p[i].x-p[mid].x)<=dis) temp[k++]=i;
    sort(temp,temp+k,cmps);
    for(register int i=0;i<k;++i)
        for(register int j=i+1;j<k&&p[temp[j]].y-p[temp[i]].y<dis;++j)
            dis=min(dis,distance(temp[i],temp[j]));
    return dis; 
}
int main() {
    int n; scanf("%d", &n);
    for(register int i = 0; i < n; ++i) scanf("%lf %lf", &p[i].x, &p[i].y);
    sort(p, p + n, cmp);
    printf("%.4lf\n",merge(0,n-1));
    return 0;
}
```

​		

