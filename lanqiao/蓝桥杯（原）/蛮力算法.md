# 蛮力算法

## 渐变分析

### 渐变符号

#### 上界$O$

若存在正数c和$n_0$​,使得对所有$n\ge n_0$​有：$0\le f(n) \le cg(n)$​​​,称$f(n)$​的渐进上界是$g(n)$​,记作$f(n)=O(g(n))$​

如果$f(n)=O(g(n))$，说明$g(n)$的阶等于或者高于$f(n)$​的阶，上界的阶越低，则评估越准确，越有价值。​

##### 定理：

1. 所有度为k的多项式的上界是$O(n^k)$

#### 下界$\Omega$​

若存在正数c和$n_0$​,使得对所有$n\ge n_0$​有：$0\le cg(n) \le f(n)$​,称$f(n)$​的渐进下界是$g(n)$​,记作$f(n)=\Omega(g(n))$​

#### 紧界$\Theta$​

若正数$c_1$和$c_2$和$n_0$使得对所有的$n\ge n_0$有：$c_1g(n)\le f(n)\le c_2g(n)$,则称$f(n)$的紧界是$g(n)$，记作$f(n)=\Theta(g(n))$​，$g(n)$是同阶无穷大​

#### 非紧上界$o$​

若对任何正数c，存在正数$n_0$​使得对所有的$n\ge n_0$​有：$0\le f(n)\le cg(n)$​,则称$f(n)$​的非紧上界是$g(n)$​,记作$f(n)=o(g(n))$​

#### 非紧下界$\omega$

若对任何正数c，存在正数$n_0$​使得对所有的$n\ge n_0$​有：$0\le cg(n)\le f(n)$​,则称$f(n)$​的非紧下界是$g(n)$​,记作$f(n)=\omega(g(n))$​

## 递归方程的求解：

### 迭代展开

### 递归树表示

### 假设归纳

### 主定理

#### 主定理1

Let $T(n)=a·T(\frac{n}{b}) + O(n^d)$ be a recurrence where $a\ge 1,b\ge 1$.Then
$$
T(n)=\begin{cases}O(n^dlogn)\quad a=b^d\\O(n^d)\quad a\le b^d\\O(n^{log_ba})\quad a \ge b^d\end{cases}\tag{1}
$$

#### 主定理2

Let $T(n)=a·T(\frac{n}{b})+f(n)$​ be a recurrence where $a\ge 1,b\ge 1$​.Then

if $f(n)=O(n^{log_b(a)-\epsilon})$​for some constant $\epsilon\ge 0,T(n)=\Theta(n^{log_b(a)}).$​​

if $f(n)=\Theta(n^{log_b(a)}),T(n)=\Theta(n^{log_b(a)}logn).$

if $f(n)=O(n^{log_b(a)+\epsilon})$for some constant $\epsilon\ge0$and if $af(n/b)\le cf(n)$ for some $c\le \epsilon$ and all sufficiently large $n$,then $T(n)=\Theta(f(n))$

## 穷举法(Exhaustive Search)

### 评价

#### 优点：

适应力强，所有问题都可以用它解决。

容易实现。

问题规模不大的都可以用它立刻得到解。

有些问题只能用穷举法。

#### 缺点：

性能往往不好，时间复杂度达到指数级。

#### 选择排序

从所有元素中选择最小的，放在第一个位置。

从剩下的元素中选择最小的，放在第二个位置。

。。。。。。

从倒数两个元素中选择最小的，放在倒数第一个位置。

#### 冒泡排序

从第一个元素开始，每个元素和后面的比较，如果逆序，则交换。得到第一大(小)的元素。

#### 顺序查找

序列中的每个元素和key进行比较，如果相等返回位置，否则返回-1.

#### 简单匹配算法

模式串对准主串的开始位置，依次比较模式串每个字符和主串的字符是否不匹配。

如果匹配，则返回匹配位置，如果不匹配，移动模式串对准主串的下一个位置。

时间复杂度为$O(n\times m)$

#### 最近点对问题

给定平面上N个点的坐标，找出距离最近的两个点。

![最近点对](D:\JAVA项目\图片\最近点对.png)

#### 凸包问题：

平面点集的凸包是包围点集中所有点的最小凸多边形。

##### 凸集：

对于平面上的一个点集合(有限或者无限)，如果以集合中任意两点P和Q为端点的线段都属于这个集合，则这个集合是凸集和(凸点集合)。

##### 凸包：

一个点集合S的凸包是包含S的最小凸集合。

##### 思路：

两点确定一条直线，如果剩余的其他点都在这条直线的同一侧，则这两个点是凸包上的点，否则不是。

- 将点集中的所有点两两配对，组成$\frac{n(n-1)}{2}$条直线。
- 对于每条直线，再检查剩余$n-2$个点是否在直线的同一侧。
  - 如果其他的点带入直线方程左边都是同一符号，说明他们在直线的同一半平面。

![凸包](D:\JAVA项目\图片\凸包.png)