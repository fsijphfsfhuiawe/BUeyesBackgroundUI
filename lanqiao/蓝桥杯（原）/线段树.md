# 线段树

## P3372 线段树1

#### 题目描述

如题，已知一个数列，你需要进行下面两种操作：

1. 将某区间每一个数加上 k。
2. 求出某区间每一个数的和。

#### 输入格式

第一行包含两个整数 n, m，分别表示该数列数字的个数和操作的总个数。

第二行包含 n 个用空格分隔的整数，其中第 i 个数字表示数列第 i 项的初始值。

接下来 m 行每行包含 3 或 4 个整数，表示一个操作，具体如下：

1. `1 x y k`：将区间 [x, y][x,y] 内每个数加上 k。
2. `2 x y`：输出区间 [x, y][x,y] 内每个数的和。

#### 输出格式

输出包含若干行整数，即为所有操作 2 的结果。

#### 输入输出样例

输入 #1

```
5 5
1 5 4 2 3
2 2 4
1 2 3 2
2 3 4
1 1 5 1
2 1 4
```

输出 #1

```
11
8
20
```

#### 说明/提示

对于 30% 的数据：$n \le 8，m \le 10$。
对于 70% 的数据：$n \le {10}^3，m \le {10}^4$。
对于 100% 的数据：$1 \le n, m \le {10}^5$。

保证任意时刻数列中任意元素的和在 $[-2^{63}, 2^{63})$内。

#### 代码

```C++
#include<iostream>
#include<cstdio>
#define MAXN 1000001
#define ll long long
using namespace std;
unsigned ll n, m, a[MAXN], ans[MAXN<<2], tag[MAXN<<2];
inline ll ls(ll x)
{
    return x << 1;
}
inline ll rs(ll x)
{
    return x << 1 | 1;
}
void scan()
{
    scanf("%d%d", &n, &m)
    for(ll i = 1; i <= n; i++)
    	scanf("%lld", &a[i]);
}
inline void push_up(ll p)
{
    ans[p] = ans[ls(p)] + ans[rs(p)];
}
void build(ll p,ll l,ll r)
{
    tag[p] = 0;
    if(l == r){
		ans[p] = a[l];
		return ;
	}
    ll mid = (l + r) >> 1;
    build(ls(p), l, mid);
    build(rs(p), mid + 1, r);
    push_up(p);
} 
inline void f(ll p,ll l,ll r,ll k)
{
    tag[p] = tag[p] + k;
    ans[p] = ans[p] + k * (r - l + 1);
}
inline void push_down(ll p,ll l,ll r)
{
    ll mid = (l+r) >> 1;
    f(ls(p), l, mid, tag[p]);
    f(rs(p), mid + 1, r, tag[p]);
    tag[p] = 0;
}
inline void update(ll nl, ll nr, ll l, ll r, ll p, ll k)
{
    if(nl <= l && r <= nr)
    {
        ans[p] += k * (r-l+1);
        tag[p] += k;
        return ;
    }
    push_down(p, l, r);
    ll mid = (l + r) >> 1;
    if(nl <= mid) update(nl, nr, l, mid, ls(p), k);
    if(nr > mid) update(nl, nr, mid + 1, r, rs(p), k);
    push_up(p);
}
ll query(ll q_x,ll q_y,ll l,ll r,ll p)
{
    ll res = 0;
    if(q_x <= l && r <= q_y) return ans[p];
    ll mid = (l + r) >> 1;
    push_down(p, l, r);
    if(q_x <= mid)res += query(q_x, q_y, l, mid, ls(p));
    if(q_y > mid) res += query(q_x, q_y, mid + 1, r, rs(p));
    return res;
}
int main()
{
    ll a1, b, c, d, e, f;
    scan();
    build(1, 1, n);
    while(m--)
    {
        scanf("%lld", &a1);
        switch(a1)
        {
            case 1:{
                scanf("%lld%lld%lld", &b, &c, &d);
                update(b, c, 1, n, 1, d);
                break;
            }
            case 2:{
                scanf("%lld%lld", &e, &f);
                printf("%lld\n",query(e, f, 1, n, 1));
                break;
            }
        }
    }
    return 0;
}
```



## P3373 线段树2

#### 题目描述

如题，已知一个数列，你需要进行下面三种操作：

- 将某区间每一个数乘上 x
- 将某区间每一个数加上 x
- 求出某区间每一个数的和

#### 输入格式

第一行包含三个整数 n,m,p，分别表示该数列数字的个数、操作的总个数和模数。

第二行包含 n 个用空格分隔的整数，其中第 i 个数字表示数列第 i 项的初始值。

接下来 m 行每行包含若干个整数，表示一个操作，具体如下：

操作 1： 格式：`1 x y k` 含义：将区间 [x,y][x,y] 内每个数乘上 k

操作 2： 格式：`2 x y k` 含义：将区间 [x,y][x,y] 内每个数加上 k

操作 3： 格式：`3 x y` 含义：输出区间 [x,y][x,y] 内每个数的和对 p 取模所得的结果

#### 输出格式

输出包含若干行整数，即为所有操作 33 的结果。

#### 输入输出样例

输入 #1

```
5 5 38
1 5 4 2 3
2 1 4 1
3 2 5
1 2 4 2
2 3 5 5
3 1 4
```

输出 #1

```
17
2
```

#### 说明/提示

【数据范围】

对于 30% 的数据：n \le 8，m \le 10
对于 70% 的数据：n \le 10^3，m \le 10^4
对于 100% 的数据：n \le 10^5，m \le 10^5

除样例外，p = 571373

#### 代码

```C++

```

