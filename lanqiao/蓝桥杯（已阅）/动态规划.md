# 动态规划

#### P1359 租用游艇

$dp[j] = min(dp[j], dp[i] + a[i][j])$

```C++
#include <iostream>
using namespace std;
const int N = 205, INF = 1e6 + 5;
long long dp[N];	// dp[i]表示从1到i的最少租金
int main()
{
 	int n; scanf("%d", &n);
	for(int i = 1; i <= n; i++) dp[i] = INF;
	dp[1] = dp[0] = 0;
	for(int i = 1; i <= n - 1; i++){
		for(int j = i + 1; j <= n; j++){
			int temp; scanf("%d", &temp);
			dp[j] = min(dp[j], dp[i] + temp);
		}
	}
	printf("%lld", dp[n]);
	system("pause");
 	return 0;
}
```

#### 01背包问题：

有$n$件物品和一个容量为$m$的背包。第$i$件物品的体积是$w[i]$，价值是$v[i]$。求解将哪些物品装入背包可使价值总和最大。每种物品仅有一件，可以选择放或不放。

$f[i][j]$表示在前$ i $件物品中选择若干件放在已用空间为$ j $的背包里所能获得的最大价值
$$
f[i][j]=max(f[i-1][j-w[i]] + P[i],f[i-1][j])
$$

```C++
for(int i = 1; i <= n; i++) {
    sumw += w[i];
    bound = max(m - sumw, w[i]);
    for(int c = m; c >= bound; c--) {
        if(c >= w[i]) f[c] = max(f[c],f[c-w[i]] + v[i]);
    }
}
```

#### 完全背包问题：

有$n$件物品和一个容量为$m$的背包。第$i$件物品的体积是$w[i]$，价值是$v[i]$。求解将哪些物品装入背包可使价值总和最大。每种物品都有无限件可用。

$f[v]$表示前$i$种物品恰放入一个容量为$v$的背包的最大权值
$$
f[j]=max\{f[j],f[j-k*c]+k*w\}(0\le k\times c\le v)
$$

```C++
for(int i = 1; i <= n; i++){
    for(int c = w[i]; c <= m; c++){
        f[c] = max(f[c], f[c - w[i]] + v[i]);
    }
}
```

#### 多重背包问题：

有n种物品和一个容量为m的背包，第i种物品最多有a[i]件可用，价值为v[i]，体积为w[i]，求解：选哪些物品放入背包，可以使得这些物品的价值最大，并且体积总和不超过背包容量。

```C++
register int i, j, k;
for(i = 1; i <= n; ++i){
    for(k = 1; k <= a[i]; ++k){
        for(j = m; j >= k * w[i]; --j){
            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
        }
    }
}
```

```C++
register int i, j, k;
for(i = 1; i <= n; ++i){
    for(j = m; j >= 0; --j){
        for(k = 0; k <= a[i] && k * w[i] <= j; ++k){
			dp[j] = max(dp[j], dp[j - k * w[i]] + v[i]);
        }
    }
}
```

#### 分组背包问题：

有$N$件物品和一个容量是$V$的背包，物品被分为$T$组，每组物品有若干个，同一组物品最多只能选一个。第$i$件物品的体积是$w[i]$，价值是$v[i]$。求解将哪些物品装入背包可使价值总和最大。

$dp[v]$表示体积为v时的最大值。
$$
dp[k][v]=max(dp[k-1][v],dp[k-1][v-w[i]]+c[i]),i属于第k组
$$

```C++
// 二维数组：
f[k][j]表示前k组体积为j的最大价值
for(int k = 1; k <= T; ++k)            //组别
    for(int i = 1; i <= N; ++i)       //物品
        for(int j=V; j >= 0; j--)   //体积
            f[k][j] = max(f[k][j], v[k][i]+f[k-1][j-w[k][i]] );  //求组这组最大
```

$$
dp[v]=max(dp[v],dp[v-w[i]]+c[i])
$$

```C++
// 一维数组 ：f[j]表示体积为j的时候的最大价值！（每组都共用一个dp数组，dp数组保存最大价值）
for(int k = 1; k <= T; k++)
    for(int j = V; j >= 0; j--)   //分组体积
        // a[k][0]表示第k组的物品个数
        for(int i = 1; i <= a[k][0]; i++){  //对体积里的每个物品
            int x = a[k][i]; //x来记录物品编号
            if(j >= w[i])  //容量大于第i个物品的体积
                f[j] = max(f[j], v[x] + f[j - w[x]] ); //价值为
        }
```



#### [P1060 [NOIP2006 普及组\] 开心的金明](https://www.luogu.com.cn/problem/P1060)

```C++
#include <iostream>
using namespace std;
int w[30], v[30], dp[50000]; // w表示价值，v表示花费，0-1背包
int main() {
	int n, m; scanf("%d%d", &n, &m);
	for(int i = 1; i <= m; i++){
		scanf("%d%d", &v[i], &w[i]);
		w[i] *= v[i];
	}
	for(int i = 1; i <= m; i++){
		for(int j = n; j >= v[i]; j--){
			if(j >= v[i]) dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
		}
	}
	printf("%d", dp[n]);	// 背包大小为n时最大值
	system("pause");
	return 0;
}
```

#### P1802 5 倍经验日

```C++
#include <iostream>
using namespace std;
typedef long long ll;
const int N = 1e3 + 5;
ll win[N], lose[N], cost[N], dp[N];
int main() {
	int n, x; scanf("%d%d", &n, &x);
	for(int i = 1; i <= n; i++){
		scanf("%lld%lld%lld", &lose[i], &win[i], &cost[i]);
	}
	for(int i = 1; i <= n; i++){ // 遍历每个物品
		for(int j = x; j >= cost[i]; j--){ // 遍历空间大于物品消耗的空间
			// 选择是否打败
			dp[j] = max(dp[j] + lose[i], dp[j - cost[i]] + win[i]);
		}
		for(int j = cost[i] - 1; j >= 0; j--){ // 不能打败
			dp[j] += lose[i];
		}
	}
	printf("%lld", 5 * dp[x]);
	system("pause");
	return 0;
}
```

#### P1049 [NOIP2001 普及组] 装箱问题

```C++
#include <iostream>
using namespace std;
// 转换为01背包问题，求最大可装容量
int V, n, cost[35], dp[20005];
int main() {
	scanf("%d%d", &V, &n);
	for(int i = 1; i <= n; i++) {
		scanf("%d", &cost[i]);
	}
	for(int i = 1; i <= n; i++){
		for(int j = V; j >= cost[i]; j--){
			dp[j] = max(dp[j], dp[j - cost[i]] + cost[i]);
		}
	}
	printf("%d", V - dp[V]);
	system("pause");
	return 0;
}
```

#### [P1048 [NOIP2005 普及组\] 采药](https://www.luogu.com.cn/problem/P1048)

```C++
#include <iostream>
using namespace std;
int T, M, t[105], value[105], dp[1005];
int main() {
	scanf("%d%d", &T, &M);
	for(int i = 1; i <= M; i++) scanf("%d%d", &t[i], &value[i]);
	for(int i = 1; i <= M; i++){
		for(int j = T; j >= t[i]; j--){
			dp[j] = max(dp[j], dp[j - t[i]] + value[i]);
		}
	}
	printf("%d", dp[T]);
	system("pause");
	return 0;
}
```

#### P1757 通天之分组背包

```C++
#include <iostream>
using namespace std;
const int MAX = 1005;
int weight[MAX], value[MAX], dp[MAX], group[MAX];
int main() {
	int n, m; scanf("%d%d", &m, &n);
	int cnt = -1;
	for(int i = 1; i <= n; i++){
		scanf("%d%d%d", &weight[i], &value[i], &group[i]);
		cnt = max(cnt, group[i]);
	}
	for(int i = 1; i <= cnt; i++){	// 枚举组
		for(int j = m; j >= 0; j--){	// 枚举重量
			for(int k = 1; k <= n; k++){	// 枚举物品
				if(group[k] != i) continue;
				else if(j >= weight[k]) dp[j] = max(dp[j], dp[j - weight[k]] +value[k]);
			}
		}
	}
	printf("%d", dp[m]);
	system("pause");
	return 0;
}
```

#### P1832 A+B Problem（再升级）

```C++
#include <iostream>
#include <vector>
using namespace std;
vector<int> prime;
bool isPrime[1005];
long long dp[1005];
int main() {
	// 每个素数都可以无限取，所以转化为完全背包问题。
	int n; scanf("%d", &n);
	for(int i = 0; i <= n; i++) isPrime[i] = true;
	isPrime[0] = isPrime[1] = false;
	// 欧式筛法，时间复杂度为O(n)
	for(int i = 2; i <= n; i++){
		if(isPrime[i]) prime.push_back(i);	
		for(int j = 0; j < prime.size() && i * prime[j] <= n; j++){
			isPrime[i * prime[j]] = false; //把p数组中记录的素数，升序依次作为需消去的合数的最小质因子
			// 若i为p[j]的倍数，则i=a*p[j]（a为常数），如果直接进入下一轮循环，j=j+1，i*p[j+1]=a*p[j]*p[j+1]，
			// 这里p[j]是最小的质因子，当i=a*p[j+1]时会重复，所以应该跳出循环
			if(i % prime[j] == 0) break;
		}
	}

	dp[0] = 1;
	for(int i = 0; i < prime.size(); i++) {
		for(int j = prime[i]; j <= n; j++)
			dp[j] += dp[j - prime[i]];
	}
	printf("%lld", dp[n]);
	system("pause");
	return 0;
}
```



### [P1203 [USACO1.1\] 坏掉的项链 Broken Necklace](https://www.luogu.com.cn/problem/P1203)

```C++
#include<iostream>
#include<cstring>
using namespace std;
int n,rR[400*2],rB[400*2],lR[400*2],lB[400*2],ans;
char c[400*2];
int fastRead()
{
	int f=1,r=0;char c=getchar();
	while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){r=r*10+c-'0';c=getchar();}
	return f*r;
}
int main()
{
	n=fastRead();
	scanf("%s",c+1);
	for(int i=1;i<=n;++i)
	c[i+n]=c[i];lB[0]=0;lR[0]=0;
	for(int i=1;i<=n*2;++i)
	{
		if(c[i]=='w')
		{
			lR[i]=lR[i-1]+1;
			lB[i]=lB[i-1]+1;
		}
		else if(c[i]=='r')
		{
			lR[i]=lR[i-1]+1;
		}
		else if(c[i]=='b')lB[i]=lB[i-1]+1;
	}
	for(int i=n*2;i>=1;--i)
	{
		if(c[i]=='w')
		{
			rR[i]=rR[i+1]+1;
			rB[i]=rB[i+1]+1;
		}
		else if(c[i]=='r')
		{
			rR[i]=rR[i+1]+1;
		}
		else if(c[i]=='b')rB[i]=rB[i+1]+1;	
	}
	for(int i=(n<<1)-1;i>=1;--i)
    ans=max(ans,max(lR[i],lB[i])+max(rR[i+1],rB[i+1]));
    if(ans>n)ans=n;
    printf("%d",ans);
    return 0;
}
```



### P1507 NASA的食物计划

$$
dp[i][j][k] = max(dp[i-1][j][k],dp[i-1][j-v[i]][k-w[i]]+val[v])
$$

```C++
#include <iostream>
using namespace std;
struct Food{
	int v, w, k;
}F[55];
int N, V, W, dp[55][405][405];
int main() {
	scanf("%d%d%d", &V, &W, &N);
	register int i, j, k;
	for(i = 1; i <= N; ++i){
		scanf("%d%d%d", &F[i].v, &F[i].w, &F[i].k);
	}
	for(i = 1; i <= N; ++i){
		for(j = V; j >= 0; --j){
			for(k = W; k >= 0; --k){
				if(j >= F[i].v && k >= F[i].w)
					dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - F[i].v][k - F[i].w] + F[i].k);
				else dp[i][j][k] = dp[i - 1][j][k];
			}
		}
	}
	printf("%d", dp[N][V][W]);
	system("pause");
	return 0;
}
```

```C++
#include <iostream>
using namespace std;
struct Food{
	int v, w, k;
}F[55];
int N, V, W, dp[405][405];
int main() {
	scanf("%d%d%d", &V, &W, &N);
	register int i, j, k;
	for(i = 1; i <= N; ++i){
		scanf("%d%d%d", &F[i].v, &F[i].w, &F[i].k);
	}
	for(i = 1; i <= N; ++i){
		for(j = V; j >= F[i].v; --j){
			for(k = W; k >= F[i].w; --k){
				dp[j][k] = max(dp[j][k], dp[j - F[i].v][k - F[i].w] + F[i].k);
			}
		}
	}
	printf("%d", dp[N][V][W]);
	system("pause");
	return 0;
}
```



### P1164 小A点菜

$dp[i][j]$表示前$i$件商品刚好凑齐$j$元的方案数。

- 如果选择$i$件商品，则方案数加上$dp[i-1][j-val[i]$
- 如果不选择$i$件商品，则方案数加上$dp[i-1][j]$
- 初始化时$dp[i][0]=1(0\le i)$

$$
dp[i][j]=dp[i-1][j-val[i]]+dp[i-1][j]
$$

```C++
#include <iostream>
using namespace std;
int N, M, dp[105][10005], val[105];
int main() {
	scanf("%d%d", &N, &M);
	register int i, j;
	dp[0][0] = 1;
	for(i = 1; i <= N; ++i) {
		dp[i][0] = 1;
		scanf("%d", &val[i]);
	}
	for(i = 1; i <= N; ++i){
		for(j = 1; j <= M; ++j){
			if(j >= val[i]) dp[i][j] += dp[i - 1][j - val[i]];
			dp[i][j] += dp[i - 1][j];
		}
	}
	printf("%d", dp[N][M]);
	return 0;
}
```

```C++
#include <iostream>
using namespace std;
int N, M, val[105], dp[10005];
int main() {
    scanf("%d%d", &N, &M);
	register int i, j;
	dp[0][0] = 1;
	for(i = 1; i <= N; ++i) {
		dp[i][0] = 1;
		scanf("%d", &val[i]);
	}
    for(i = 1; i <= N; ++i){
        for(j = M; j >= val[i]; --j){
            dp[j] = dp[j] + dp[j - v[i]];
        }
    }
    return 0;
}
```



### P3985 不开心的金明

```C++
#include <iostream>
#include <cstdio> 
#include <algorithm>
using namespace std;

int p[102],v[102],n,w;
int f[300002],maxn,minn=9999999;
bool cmp(int x,int y){
	return x>y;
}
int main(){
	scanf("%d%d",&n,&w);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&v[i],&p[i]);
		minn=min(minn,v[i]);
		maxn=max(maxn,v[i]);
	}
	if(minn<=300){
		for(int i=1;i<=n;i++){
			for(int j=w;j>=v[i];j--){
				f[j]=max(f[j],f[j-v[i]]+p[i]);
			}
		}
		printf("%d",f[w]);
	}
	else{
		int ans=0;
		sort(p+1,p+n+1,cmp);
		for(int i=1;i<=w/maxn;i++)
			ans+=p[i];
		printf("%d",ans);
	}
	return 0;
}
```



### P1616 疯狂的采药

完全背包问题，要注意数据范围。

```C++
#include <iostream>
using namespace std;
typedef long long ll;
const int MAXM = 10010, MAXT = 10000010;
ll t, m, T[MAXM], value[MAXM], dp[MAXT];
int main() {
	scanf("%lld%lld", &t, &m);
	register int i, j;
	for(i = 1; i <= m; ++i) scanf("%lld%lld", &T[i], &value[i]);
	for(i = 1; i <= m; ++i){
		for(j = T[i]; j <= t; ++j){
			dp[j] = max(dp[j], dp[j - T[i]] + value[i]);
		}
	}
	printf("%lld", dp[t]);
	return 0;
}
```



### P2722 [USACO3.1]总分 Score Inflation

同上，完全背包问题

```C++
#include <iostream>
#define MAXN 10010
#define MAXM 100000010
using namespace std;
int m, n, T[MAXN], score[MAXN], dp[MAXM];
int main() {
	scanf("%d%d", &m, &n);
	register int i, j;
	for(i = 1; i <= n; ++i) scanf("%d%d", &score[i], &T[i]);
	for(i = 1; i <= n; ++i){
		for(j = T[i]; j <= m; ++j){
			dp[j] = max(dp[j], dp[j - T[i]] + score[i]);
		}
	}
	printf("%d", dp[m]);
	system("pause");
	return 0;
}
```



### [P1853 投资的最大效益](https://www.luogu.com.cn/problem/P1853)

总金额就是背包的空间，所以这是一个背包空间会不断变大的完全背包问题。

```C++
#include <iostream>
#define MAXS 100000000
using namespace std;
int s, n, d, w[12], v[12], dp[MAXS];
int main() {
	scanf("%d%d%d", &s, &n, &d);
	register int i, j, k;
	for(i = 1; i <= d; ++i) scanf("%d%d", &w[i], &v[i]);
	for(k = 1; k <= n; ++k){
		for(i = 1; i <= d; ++i){
			for(j = w[i]; j <= s; ++j){
				dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
			}
		}
		s += dp[s];		// 本金需要加上去年获得的利润。背包空间扩大
	}
	printf("%d", s);	// 输出最后的背包空间，即总钱数
	system("pause");
	return 0;
}
```



### P2918 [USACO08NOV]Buying Hay S

完全背包问题，最多变为了最少

```C++
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,ans=1e9;
int a[100],b[100],dp[55005];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m+5000;i++)
    dp[i]=1e9;//初始化，因为要找到一个最小值，dp[i]表示得到i磅的干草最少需要的钱数 
    for(int i=1;i<=n;i++)
    scanf("%d%d",&a[i],&b[i]);
    for(int i=1;i<=n;i++)
        for(int j=a[i];j<=m+5000;j++)//注意循环结束为m+5000，因为你只购买m千克时花费的钱不一定是最少的，5000时一坨草质量的最大值 
        	//完全背包 
        	dp[j]=min(dp[j],dp[j-a[i]]+b[i]);
    for(int i=m;i<=m+5000;i++)
    	ans=min(ans,dp[i]);//寻找哪一个既符合购买量，钱又最少 
    printf("%d",ans);//直接输出即可 
}
```



### ==P1833 樱花==

#### 混合背包问题(无优化)

- 当$P[i] == 0$，转化为完全背包
- 当$P[i]>0$，转化为多重背包

```C++
#include <iostream>
#define MAXN 10005
using namespace std;
int t, n, T[MAXN], C[MAXN], P[MAXN], dp[1005];

int main() {
	int x1, y1, x2, y2;
	scanf("%d:%d %d:%d", &x1, &y1, &x2, &y2);
	if(y1 > y2) y2 += 60, --x2;
	t = (x2 - x1) * 60 + y2 - y1;

	scanf("%d", &n);	
	register int i, j, k;
	for(i = 1; i <= n; ++i) scanf("%d%d%d", &T[i], &C[i], &P[i]);
	for(i = 1; i <= n; ++i) {
		if(P[i] == 0) {		// 完全背包
			for(j = T[i]; j <= t; ++j) 
				dp[j] = max(dp[j], dp[j - T[i]] + C[i]);
		}else{				// 多重背包
			for(k = 1; k <= P[i]; ++k){
				for(j = t; j >= k * T[i]; --j) 
					dp[j] = max(dp[j], dp[j - T[i]] + C[i]);
			}
		}
	}
	printf("%d", dp[t]);
	return 0;
}
```

#### ==二进制优化==

将使用次数为$c$的物品拆分为权值为$1, 2, 4, ...2^i,c-2^{i+1}+1$的物品。

比如$(w=2,v=3,c=13)$，可拆分为$(2,3)，(2∗2,3∗2)，(2∗4,3∗4)，(2∗6,3∗6)$，容易证明这$\log(c)$个数的物品可以拼接出$[1,c]$的所有数，所以是合法的。

```C++
#include <iostream>
using namespace std;
int n, t, a[10005],b[10005],c[10005], dp[1010];
int tp, co[1000005], v[1000005];

inline void pre(){
	for(register int i = 1; i <= n; ++i){
		int t = 1;
		while(c[i]){
			co[++tp] = t * a[i];
			v[tp] = t * b[i];
			c[i] -= t; t <<= 1;
			if(c[i] < t){	//如果剩下的不能再拆，就直接放在一起
				co[++tp] = a[i] * c[i];
				v[tp] = b[i] * c[i];
				break;
			}
		}
	}
}

int main() {
	int nx, ny, ex, ey;
	scanf("%d:%d %d:%d %d", &nx, &ny, &ex, &ey, &n);
	t = (ex * 60 + ey) - (nx * 60 + ny);
	register int i, j;
	for(i = 1; i <= n; ++i){
		scanf("%d%d%d", &a[i], &b[i], &c[i]);
		if(!c[i]) c[i] = 999999;	// 完全背包可以把他的空间记为999999
	}
	pre();	// 二进制拆分
	for(i = 1; i <= tp; ++i){	//考虑每个拆出来的物品
		for(j = t; j >= co[i]; --j){	//01背包板子
			dp[j] = max(dp[j], dp[j - co[i]] + v[i]);
		}
	}
	printf("%d", dp[t]);
	system("pause");
	return 0;
}
```



### [P5365 [SNOI2017\]英雄联盟](https://www.luogu.com.cn/problem/P5365)

多重背包问题。这里$dp[i]$表示$i$元可以获得的最大展示策略。

```C++
#include <iostream>
#define N 1000001
#define ll long long
using namespace std;
ll n, m, K[N], C[N], dp[N] = {1}, ans, qm;
int main() {
	scanf("%lld%lld", &n, &m);
	register int i, j, k;
	for(i = 1; i <= n; ++i) scanf("%lld", &K[i]);
	for(i = 1; i <= n; ++i) {
		scanf("%lld", &C[i]);
		qm += C[i] * K[i];
	}
	for(i = 1; i <= n; ++i){
		for(j = qm; j >= 0; --j){
			for(k = 0; k <= K[i] && k * C[i] <= j; ++k){
				dp[j] = max(dp[j], dp[j - k * C[i]] * k);
			}
		}
	}
	while(ans <= qm && dp[ans] < m) ans++;
	printf("%lld", ans);
	system("pause");
	return 0;
}
```



### P2347 [NOIP1996 提高组] 砝码称重

#### 多重背包问题

```C++
#include <iostream>
using namespace std;
int weight[7] = {0, 1, 2, 3, 5, 10, 20};
int Num[7], dp[1050], Co[1050], m, res, tp;

inline void pre(){
	for(register int i = 1; i <= 6; ++i){
		int t = 1;
		while (Num[i]){
			Co[++tp] = weight[i] * t;
			Num[i] -= t; t <<= 1;
			if(Num[i] < t){
				Co[++tp] = weight[i] * Num[i];
				break;
			}
		}	
	}
}

int main() {
	register int i, j, k;
	for(i = 1; i <= 6; ++i) {
		scanf("%d", &Num[i]);
		m += Num[i] * weight[i];
	}
	pre();
	for(i = 1; i <= tp; ++i){
		for(j = m; j >= Co[i]; --j){
			dp[j] = max(dp[j], dp[j - Co[i]] + Co[i]);
		}
	}
	for(i = 1; i <= m; ++i) if(dp[i] == i) ++res;
	printf("Total=%d", res);
	return 0;
}
```

#### BitSet

```C++
#include <bitset>
#include <cstdio>
int a[10], w[10] = {1, 2, 3, 5, 10, 20};
std::bitset<1010> S;
int main() {
    register int i, j;
    for(i = 0; i < 6; ++i) scanf("%d", a + i);
    S[0] = 1;
    for(i = 0; i < 6; ++i) 
        for(j = 0; j < a[i]; ++j) S |= S << w[i]; // 将s左移了w[i]位并与原来的s取了并集
    printf("Total=%d\n", S.count() - 1);	// s.count()返回s中1的个数
    return 0;
}
```



### ==P1352 没有上司的舞会==

#### 树型$DP$

$dp[x][0]$表示以$x$为根的子树，且$x$不参加舞会的最大快乐值

$dp[x][1]$表示以$x$为根的子树，且$x$参加舞会的最大快乐值

- $dp[x][0]=\sum max(dp[y][0],dp[y][1])$
- $dp[x][1]=\sum dp[y][0]+h[x]$
- $ans=max(dp[root][0],dp[root][1])$

#### 拓扑排序写法

```C++
#include <bits/stdc++.h>
#define MAXN 6005
using namespace std;
int h[MAXN], indeg[MAXN], outdeg[MAXN];   // indeg记录每个节点的入度，方便找到根节点
int dp[MAXN][2], n, root;
vector<int> father[MAXN];

void topology(){
    queue<int> que;
    register int i, j;
    for(i = 1; i <= n; ++i){
        if(!indeg[i]) {
            que.push(i);
            dp[i][1] = h[i];
        }
    }  
    while(!que.empty()){
        int q = que.front(); que.pop();
        for(i = 0; i < father[q].size(); ++i){
            j = father[q][i];
            dp[j][0] += max(dp[q][0], dp[q][1]);
            dp[j][1] += dp[q][0];
            if(--indeg[j] == 0){
                que.push(j);
                dp[j][1] += h[j];
            }
        }
    }
}

int main() {
    scanf("%d", &n);
    register int i, j, k;
    for(i = 1; i <= n; ++i) scanf("%d", &h[i]);
    for(i = 1; i < n; ++i){
        int u, v; scanf("%d%d", &u, &v);
        father[u].push_back(v);
        ++indeg[v], ++outdeg[u];
    }
    for(i = 1; i <= n; ++i) if(!outdeg[i]) {root = i; break;}
    topology();
    printf("%d", max(dp[root][0], dp[root][1]));
    return 0;
}
```

#### DFS

```C++
#include <bits/stdc++.h>
#include <queue>
#include <vector>
#define MAXN 6005
using namespace std;
int h[MAXN], indeg[MAXN], outdeg[MAXN];   // indeg记录每个节点的入度，方便找到根节点
int dp[MAXN][2], n, root;
vector<int> son[MAXN];

void f(int x){
    dp[x][0] = 0, dp[x][1] = h[x];
    for(register int i = 0; i < son[x].size(); ++i){
        int y = son[x][i];
        f(y);
        dp[x][0] += max(dp[y][0], dp[y][1]);
        dp[x][1] += dp[y][0];
    }   
}

int main() {
    scanf("%d", &n);
    register int i, j, k;
    for(i = 1; i <= n; ++i) scanf("%d", &h[i]);
    for(i = 1; i < n; ++i){
        int u, v; scanf("%d%d", &u, &v);
        son[v].push_back(u);
        ++indeg[u], ++outdeg[v];
    }
    for(i = 1; i <= n; ++i) if(!indeg[i]) {root = i; break;}
    f(root);
    printf("%d", max(dp[root][0], dp[root][1]));
    return 0;
}
```



### P2015 二叉苹果树

$dp[i][j]$表示为当前节点$i$，保留树枝条数为$j$的情况下，所留下来苹果数的最大值。

我们令左子树的树枝数最多为$k$，右子树的树枝数显然最多为$j-k$
$$
\begin{split}
dp[i][j]&=dp[ls[i]][k-1]+dp[rs[i]][j-k-1]+la[i]+ra[i],(k\neq0,k\neq j)\\
&=dp[rs[i]][j-1]+ra[i],(k=0)\\
&=dp[ls[i]][j-1]+la[i],(k=0)
\end{split}
$$

```C++
#include <iostream>
#define MAXN 105
using namespace std;
struct edge{
    int v, w, nxt;
}es[MAXN << 1];
int h[MAXN], sz[MAXN], dp[MAXN][MAXN], cnt, N, Q;

inline void insert(int u, int v, int w){
    es[++cnt].v = v;
    es[cnt].w = w;
    es[cnt].nxt = h[u];
    h[u] = cnt;
}

void dfs(int u, int fa){ // 递归遍历
    register int i, j, k;
    for(i = h[u]; i; i = es[i].nxt){
        int v = es[i].v; if(v == fa) continue;
        dfs(v, u); sz[u] += sz[v] + 1;
        // 0-1背包，所以i,j需要倒序枚举
        for(j = min(Q, sz[u]); j; --j){
            for(k = min(sz[v], j - 1); k >= 0; --k){
                dp[u][j] = max(dp[u][j], dp[u][j - k - 1] + dp[v][k] + es[i].w);
            }
        }
    }
}

int main() {
    scanf("%d%d", &N, &Q);
    register int i, j, u, v, w;
    for(i = 1; i <= N - 1; ++i){
        scanf("%d%d%d", &u, &v, &w);
        insert(u, v, w), insert(v, u, w);
    }
    dfs(1, -1);
    printf("%d", dp[1][Q]);
    return 0;
}
```



### P2014 [CTSC1997] 选课

#### 树型DP

##### 选择节点类

$$
dp[i][0]=dp[j][1]\\
dp[i][1]=max/min(dp[j][0],dp[j][1])
$$

##### 树型背包类

$$
dp[v][k]=dp[u][k]+val\\
dp[u][k]=max(dp[u][k],dp[v][k-1])
$$

```C++
/*
设dp[i][j]表示选择以i为根的子树中j个节点。
u代表当前根节点，tot代表其选择的节点的总额。
*/
void dfs(int u,int tot){
	for(int i=head[x];i;i=e[i].next){
		int v=e[i].to;
		for(int k=0;k < tot;k++)//这里k从o开始到tot-1，因为v的子树可以选择的节点是u的子树的节点数减一
			dp[v][k]=dp[u][k]+val[u];
		dfs(v,tot-1)
		for(int k=1;k<=tot;k++)
			dp[u][k]=max(dp[u][k],dp[v][k-1]);//这里是把子树的值赋给了根节点，因为u选择k个点v只能选择k-1个点。
	}
}
```

#### 代码

```C++
#include <iostream>
#define MAXN 305
using namespace std;
struct edge{
    int v, nxt;
}es[MAXN << 1];
int h[MAXN], val[MAXN], sz[MAXN], dp[MAXN][MAXN];
int cnt, N, M;

inline void insert(int u, int v){
    es[++cnt].v = v;
    es[cnt].nxt = h[u];
    h[u] = cnt;
}

void dfs(int u, int t){
    if(t <= 0) return;
    register int i, k, v;
    for(i = h[u]; i; i = es[i].nxt){
        v = es[i].v;
        for(k = 0; k < t; ++k) dp[v][k] = dp[u][k] + val[v];
        dfs(v, t - 1);
        for(k = 1; k <= t; ++k) dp[u][k] = max(dp[u][k], dp[v][k - 1]);
    }
}

int main() {
    scanf("%d%d", &N, &M);
    register int i, k, s;
    for(i = 1; i <= N; ++i){
        scanf("%d%d", &k, &val[i]);
        insert(k, i);
    }
    dfs(0, M);
    printf("%d", dp[0][M]);
    return 0;
}
```

```C++
#include <iostream>
#define MAXN 305
using namespace std;
struct edge{
    int v, nxt;
}es[MAXN << 1];
int h[MAXN], dp[MAXN][MAXN];
int cnt, N, M;

inline void insert(int u, int v){
    es[++cnt].v = v;
    es[cnt].nxt = h[u];
    h[u] = cnt;
}

int sz[MAXN];
void dfs(int u){
    sz[u] = 1;
    register int i, j, k;
    for(i = h[u]; i; i = es[i].nxt){
        int v = es[i].v;
        dfs(v);
        sz[u] += sz[v];
        for(j = min(sz[u], M + 1); j >= 1; --j){
            for(k = 0; k <= min(sz[v], j - 1); ++k){
                dp[u][j] = max(dp[u][j], dp[u][j - k] + dp[v][k]);
            }
        }
    }
}

int main() {
    scanf("%d%d", &N, &M);
    register int i, k;
    for(i = 1; i <= N; ++i){
        scanf("%d%d", &k, &dp[i][1]);
        insert(k, i);
    }
    dfs(0);
    printf("%d", dp[0][M + 1]);     // 将0节点也看为一个节点，就成为一颗树
    system("pause");
    return 0;
}
```



### 树上背包问题

#### 问题描述：

给定一棵 ![[公式]](https://www.zhihu.com/equation?tex=n) 个节点的有根树，编号为 ![[公式]](https://www.zhihu.com/equation?tex=1) 到 ![[公式]](https://www.zhihu.com/equation?tex=n) ， ![[公式]](https://www.zhihu.com/equation?tex=1) 号点为根节点且每个节点 ![[公式]](https://www.zhihu.com/equation?tex=i) 有价值 ![[公式]](https://www.zhihu.com/equation?tex=w_i) ，体积 ![[公式]](https://www.zhihu.com/equation?tex=v_i) 。背包容量为 ![[公式]](https://www.zhihu.com/equation?tex=m) ，在满足如果 ![[公式]](https://www.zhihu.com/equation?tex=u) 选了，则其所有祖先 ![[公式]](https://www.zhihu.com/equation?tex=v) 都要选的限制下，使选择的物品组合总价值和最大。

$f[i][j]$表示以$i$为根的子树里，选出体积不超过$j$的物品组合的最大价值

$O(nm^2)$算法：

```C++
for (int i = Head[now]; i; i = G[i].Next){
    if (G[i].v == father) continue;
    dfs(G[i].v, now, V - v[now]);
    for (int j = m; j >= v[now]; --j)
        for (int k = 0; k <= j - v[now]; ++k)
            f[now][j] = max(f[now][j], f[now][j - k - v[now]] + f[G[i].v][k] + w[now]);
}
```

$O(nm)$算法

```C++
Size[now] = v[now]; //初始化
for (int i = Head[now]; i; i = G[i].Next){
    if (G[i].v == father) continue;
    dfs(G[i].v, now, V - v[now]);
    Size[now] += Size[G[i].v];
    for (int j = min(V, Size[now]); j >= v[now]; --j)
        for (int k = 0; k <= min(j - v[now], Size[G[i].v]); ++k)
            f[now][j] = max(f[now][j], f[now][j - v[now] - k] + f[G[i].v][k] + w[now]);
}
```



### P1613 跑路

#### 倍增思想：

有一堆点，若两个点之间的距离之和可以达到2的n次方，那么这两个点可以用1的时间相互到达。

$f[i][j][k]$表示$i$到$j$是否能以$2^k$的距离相互到达。

```C++
#include<bits/stdc++.h>
using namespace std;
int dis[60][60],n,m;
bool G[60][60][65];
/*以上是变量说明部分，dis[i][j]表示i到j的路径/边的长度
G[i][j][k]表示，i到j是否存在一条长度为2^k的路径
如果有，为true，没有就是false*/ 
void init()
{
    memset(G,false,sizeof(G));
    memset(dis,10,sizeof(dis));
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        dis[x][y]=1;
        G[x][y][0]=true;
        /*初始化，x到y的路径（边）最短是1，也就是x到y存在
        一条长度为2^0的路径（边）*/ 
    }
}
void work()//此函数对G和dis做预处理 
{
    for(int k=1;k<=64;k++)
    //对于本题的数据，2^64已经足够。 
    for(int i=1;i<=n;i++)
    for(int t=1;t<=n;t++)
    for(int j=1;j<=n;j++)
    //枚举三个点
    if(G[i][t][k-1]&&G[t][j][k-1])
    /*如果i到t存在一条2^k-1长度的路径
    并且t到j存在一条2^k-1长度的路径
    就说明i到t，t到j都可以一秒到达，
    路程*2刚好是2的幂，也可以一秒到达*/ 
    {
        G[i][j][k]=true;
        //标记从i到j存在一条长度为2^k的路径 
        dis[i][j]=1;
        //i到j距离可以一秒到达 
    }
}
void floyd(){
    for(int k=1;k<=n;k++)
    //这里的注意点：枚举中间点的循环放在最前面 
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
    //松弛操作。 
}//Floyd图论求最短路。 
int main(){
    init();
    work();
    floyd();
    printf("%d",dis[1][n]);
    return 0;
}
```



### P1776 宝物筛选

#### 二进制优化

```C++
#include <iostream>
#define MAXW 40010
using namespace std;
struct Item{
    int v, w, m;
}I[105];
int n, W, tp, co[100005], v[100005];
long long dp[MAXW];

inline void pre(){
    register int i, t;
    for(i = 1; i <= n; ++i){
        t = 1;
        while(I[i].m){
            co[++tp] = t * I[i].w;
            v[tp] = t * I[i].v;
            I[i].m -= t, t <<= 1;
            if(I[i].m < t){
                co[++tp] = I[i].m * I[i].w;
                v[tp] = I[i].m * I[i].v;
                break;
            }
        }
    }
}

int main() {
    scanf("%d%d", &n, &W);
    register int i, j;
    for(i = 1; i <= n; ++i) scanf("%d%d%d", &I[i].v, &I[i].w, &I[i].m);
    pre();
    for(i = 1; i <= tp; ++i)
        for(j = W; j >= co[i]; --j)
            dp[j] = max(dp[j], dp[j - co[i]] + v[i]);
    printf("%lld", dp[W]);
    system("pause");
    return 0;
}
```

#### 单调队列优化

$ w$表示物品重量，$v$表示价值，$c$表示数量，我们知道朴素状态转移方程：
$$
f[i][j]=\max(f[i][j], f[i-1][j-w\times k]+v\times k),(k\le c)
$$
现在我们要把这个方程变成一个单调队列可以优化的形式，于是我们假设:$d=j\mod w[i],s=⌊j/w[i]⌋$
$$
f[i][j]=max(f[i-1][d+w\times k]-v\times k)+v\times s,(s-k\le c)
$$
之后我们枚举余数$d$，然后对于每个余数$d$都用单调队列优化即可。

```C++
#include <iostream>
#define MAX 40010
using namespace std;
int n, V, head, tail, ans;
int q[MAX], q2[MAX], dp[MAX];
int main() {
    scanf("%d%d", &n, &V);
    register int i, d, j;
    for(i = 1; i <= n; ++i){
        int v, w, c; scanf("%d%d%d",&w,&v,&c);
        if(!v) {
            ans += w * c;
            continue;
        }
        int k = V / v;
        c = min(c, k);
        for(d = 0; d < v; ++d){
            head = tail = 0;
            k = (V - d) / v;
            for(j = 0; j <= k; ++j){
                while(head < tail && dp[d + j * v] - j * w >= q2[tail -1]) --tail;
                q[tail] = j;
                q2[tail++] = dp[d + j * v] - j * w;
                while (head < tail && q[head] < j - c) ++head;
                dp[d + j * v] = max(dp[d + j * v], q2[head] + j * w);
            }
        }
    }
    printf("%d", ans + dp[V]);
    return 0;
}
```



### ==P1435 [IOI2000] 回文字串==

#### 思路1

回文串满足的条件是字符串的正序和倒序相同。如果把正序与倒序公共的部分减去，发现剩余的字符就是所要添加的字符，也就是所求的正解。

例如$ab3bd$的倒序为$db3ba$，公共子序列为$b3b$，减去得到$ad$和$da$，将这两个字串加入原串得到$adb3bda$，是回文串。

求最长公共子序列的状态转移方程为：
$$
f[i][j]=\begin{cases}f[i-1][j-1]+1,a[i]=b[j]\\\max(f[i][j-1],f[i-1][j]),else\end{cases}
$$

```C++
#include <iostream>
#include <cstring>
#define maxn 1005
using namespace std;
char s[maxn], s1[maxn];
int dp[2][maxn];
int main() {
    scanf("%s", s + 1);
    int n = strlen(s + 1);
    register int i, j;
    for(i = 1; i <= n; ++i) s1[i] = s[n - i + 1];
    for(i = 1; i <= n; ++i){
        for(j = 1; j <= n; ++j){
            if(s[i] == s1[j]) dp[i%2][j] = dp[(i-1)%2][j - 1] + 1;
            else dp[i%2][j] = max(dp[i%2][j - 1], dp[(i-1)%2][j]);
        }
    }
    printf("%d", n - dp[n%2][n]);
    system("pause");
    return 0;
}
```

#### 思路2

设$f[i][j]$为要把从$i$到$j$（包括$i$和$j$）的字符串变为回文串的最少插入字符数。

- $S[i] == S[j]$说明串的两头相等，不需要多插入什么，只需要$f[i][j] = f[i+1][j-1]$就好了，$i+1$到$ j-1$ 一段就是除两头外的最少插入字符数
- $S[i] != s[j]$说明串的两头不同，需要多插入$1$字符以保持串的回文性质，我们这次新插入的字符可能在最右边，也可能在最左边。所以需要$f[i][j] = min(f[i+1][j], f[i][j-1]) + 1$



### P1439 【模板】最长公共子序列

#### $O(n^2)$的解法

定义$f[i][j]$表示序列$X$的$i$位和序列$Y$的$j$位之前的最长公共子序列的长度，可以得到转移方程如下
$$
f[i][j]=\begin{cases}f[i-1][j-1]+1,X[i]=Y[j]\\\max(f[i][j-1],f[i-1][j]),else\end{cases}
$$

```C++
#include <iostream>
#define maxn 100005
using namespace std;
int f1[maxn], f2[maxn], dp[2][maxn];
int main() {
    int n; scanf("%d", &n);
    register int i, j;
    for(i = 1; i <= n; ++i) scanf("%d", &f1[i]);
    for(i = 1; i <= n; ++i) scanf("%d", &f2[i]);
    for(i = 1; i <= n; ++i){
        for(j = 1; j <= n; ++j){
            dp[i%2][j]=max(dp[(i-1)%2][j],dp[i%2][j-1]);
            if(f1[i] == f2[j]) dp[i%2][j]=max(dp[i%2][j],dp[(i-1)%2][j-1]+1);
        }
    }
    printf("%d", dp[n%2][n]);
    system("pause");
    return 0;
}
```

#### $O(n\log n)$优化解法

转换为 $LIS$问题：

假设有两个序列A:3 2 1 4 5, B:1 2 3 4 5。

我们不妨给它们重新标个号：把3标成a,把2标成b，把1标成c……于是变成：A: a b c d e， B: c b a d e

这样标号之后，$LCS$长度显然不会改变。但是出现了一个性质：**两个序列的子序列，一定是A的子序列。而A本身就是单调递增的。因此这个子序列是单调递增的。**

换句话说，只要这个子序列在$B$中单调递增，它就是$A$的子序列。哪个最长呢？当然是$B$的$LIS$最长。

```C++
#include <iostream>
#include <algorithm>
#define maxn 100005
using namespace std;
int f[maxn], belong[maxn], dp[maxn];
int main() {
    int n, len = 1; 
    scanf("%d", &n);
    register int i, temp;
    for(i = 1; i <= n; ++i) {scanf("%d", &temp); belong[temp] = i;}
    for(i = 1; i <= n; ++i) {scanf("%d", &temp); f[i] = belong[temp];}
    dp[1] = f[1];
    for(i = 1; i <= n; ++i){
        if(dp[len] < f[i]) dp[++len] = f[i];
        else *lower_bound(dp + 1, dp + len + 1, f[i]) = f[i];
    }
    printf("%d", len);
    return 0;
}
```



### ==最长公共字串==

有两个字符串（可能包含空格）,请找出其中最长的公共连续子串,输出其长度。(长度在$1000$以内)

$dp[i][j]$表示字符串$X$以$i$位结尾的和字符串$Y$以$j$位结尾的最长公共连续字串。
$$
dp[i][j]=\begin{cases}0,X[i]\neq Y[j]\\dp[i-1][j-1]+1,X[i]=Y[j]\end{cases}
$$

```C++
#include <iostream>
#define maxn 100005
using namespace std;
int f1[maxn], f2[maxn], dp[2][maxn];
int main() {
    int n, res = 0;
    scanf("%d", &n);
    register int i, j;
    for(i = 1; i <= n; ++i) scanf("%d", &f1[i]);
    for(i = 1; i <= n; ++i) scanf("%d", &f2[i]);
    for(i = 1; i <= n; ++i){
        for(j = 1; j <= n; ++j){
            if(f1[i] != f2[j]) dp[i%2][j] = 0;
            else dp[i%2][j] = dp[(i-1)%2][j-1]+1;
            res = max(res, dp[i%2][j]);
        }
    }
    printf("%d", res);
    system("pause");
    return 0;
}
```



### ==P1020 [NOIP1999 普及组] 导弹拦截==

求解这套系统最多能拦截多少导弹，也就是求最长单调不升子序列；

求解最少要配备多少套这种导弹拦截系统：

$Dilworth $定理推：将一个导弹描述为一个二元组$ (a,b),a $是导弹的到达顺序，$ b$为导弹高度。设二元组偏序关系 $(a1,b1)≤(a2,b2)$为 $a1<a2∧b1≤b2$，问题就是在求最少能够划分多少个全序集能将所有元素覆盖。根据 $Dilworth$ 定理，我们只需求最大反链元素个数即可，即求最大严格上升子序列元素个数。

使用upper_bound和lower_bound来优化时间复杂度到$O(n\log n)$

lower_bound会找出序列中第一个**大于等于**x的数，lower_bound只能对上升序列使用

```C++
// 找到a[1]-a[n+1]中第一个大于等于x的数，a为上升序列
int pos1 = lower_bound(a+1, a+n+1, x) - a;
// 找到a[1]-a[n+1]中第一个小于x的数
int pos1 = lower_bound(a+1, a+n+1, x, greater<int>()) - a;
```

upper_bound会找出序列中第一个**大于**x的数

```C++
// 找到a[1]-a[n+1]中第一个大于x的数，a为上升序列
int pos1 = upper_bound(a+1, a+n+1, x) - a;
// 找到a[1]-a[n+1]中第一个小于等于x的数
int pos1 = upper_bound(a+1, a+n+1, x, greater<int>()) - a;
```

#### ==代码==

```C++
#include <iostream>
#include <algorithm>
#define maxn 100005
using namespace std;
int f[maxn], dp1[maxn], dp2[maxn];
int main() {
    int cnt = 1, len1 = 1, len2 = 1;
    while(~scanf("%d", &f[cnt++])); --cnt;
    dp1[1] = f[1];  // 用于求不上升序列长度
    dp2[1] = f[2];  // 用于求上升序列长度
    for(register int i = 2; i <= cnt; ++i){ //从f[2]开始枚举每个数
        if(dp1[len1] >= f[i]) dp1[++len1] = f[i]; //如果满足要求(不上升)就加入d1
        else{  // 否则用f[i]替换dp1中的一个数
            *upper_bound(dp1 + 1, dp1 + 1 + len1, f[i], greater<int>()) = f[i];
        }
        if(dp2[len2] < f[i]) dp2[++len2] = f[i];
        else *lower_bound(dp2 + 1, dp2 + 1 + len2, f[i]) = f[i];
    }
    printf("%d\n%d", len1, len2);
    system("pause");
    return 0;
}
```



### P1091 [NOIP2004 提高组] 合唱队形

#### $O(n^2)$的时间复杂度

对于序列中的$i$位置，求出$1-i$的最长单调递增子序列和$i+1-n$的最长单调递减子序列，得到的结果就是最大的合唱队形。

$f[i]$表示到$i$为止最长的上升子序列的长度，初始化时$f[i]=1$
$$
f[i]=\max_{j=1}^{i-1}f[j]+1,f[j]+1>f[i]\&\& a[j]<a[i]
$$

```C++
#include <iostream>
using namespace std;
int f[105], dp1[105], dp2[105];
int main() {
    int n; scanf("%d", &n);
    register int i, j;
    for(i = 1; i <= n; ++i) {
        scanf("%d", &f[i]);
        dp1[i] = dp2[i] = 1;
    }
    for(i = 2; i <= n; ++i){
        for(j = 1; j < i; ++j){
            if(f[j] < f[i] && dp1[i] < dp1[j] + 1) dp1[i] = dp1[j] + 1;
        }
    }
    for(i = n - 1; i >= 1; --i){
        for(j = n; j > i; --j){
            if(f[j] < f[i] && dp2[i] < dp2[j] + 1) dp2[i] = dp2[j] + 1;
        }
    }
    int res = 0;
    for(i = 1; i <= n; ++i) res = max(res, dp1[i] + dp2[i] - 1);
    printf("%d", n - res);
    return 0;
}
```

#### $O(n\log n)$的时间复杂度

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
int f[105], dp[105], dp1[105], dp2[105];
int main() {
    int n, res = 0; scanf("%d", &n);
    register int i, j, len;
    for(i = 1; i <= n; ++i) scanf("%d", &f[i]);
    dp[1] = f[1], dp1[1] = dp2[n] = 1;
    for(i = 2, len = 1; i <= n; ++i){
        if(dp[len] < f[i]) dp[++len] = f[i];
        else *lower_bound(dp + 1, dp + len + 1, f[i]) = f[i];
        dp1[i] = len;
    }
    memset(dp, 0, sizeof dp);
    dp[1] = f[n];
    for(i = n - 1, len = 1; i >= 1; --i){
        if(dp[len] < f[i]) dp[++len] = f[i];
        else *lower_bound(dp + 1, dp + len + 1, f[i]) = f[i];
        dp2[i] = len; 
    }
    for(i = 1; i <= n; ++i){
        res = max(res, dp1[i] + dp2[i] - 1);
    }
    printf("%d", n - res);
    return 0;
}
```



### P1077 [NOIP2012 普及组] 摆花

##### 将问题转换成：

有$n$个数$c_1,c_2,\dots, c_n,0\le c_i\le a_i$，求有多少种方案数满足$\sum_{i=1}^nc_i=m$

##### 动态规划：

定义$f[i][j]$表示前$i$个数总和为$j$的方案数：
$$
f[i][j] = \sum_{k=1}^{n}f[i-1][j-c_k]
$$

```c++
#include <iostream>
#define mod 1000007
using namespace std;
int n, m, w[105], dp[2][105];
int main() {
    scanf("%d%d", &n, &m);
    register int i, j, k, t = 0;
    for(i = 1; i <= n; ++i) scanf("%d", &w[i]);
    dp[0][0] = 1;
    for(i = 1; i <= n; ++i){
        t = 1 - t;
        for(j = 0; j <= m; ++j){
            dp[t][j] = 0;
            for(k = 0; k <= min(w[i], j); ++k)
                dp[t][j] = (dp[t][j] + dp[1-t][j-k]) % mod;
        }
    }
    printf("%d", dp[t][m]);
    return 0;
}
```

##### 背包问题

```C++
#include <iostream>
#define mod 1000007
using namespace std;
int n, m, w[105], dp[105];
int main() {
    scanf("%d%d", &n, &m);
    register int i, j, k;
    for(i = 1; i <= n; ++i) scanf("%d", &w[i]);
    dp[0] = 1;
    for(i = 1; i <= n; ++i)
        for(j = m; j >= 0; --j)
            for(k = 1; k <= min(j, w[i]); ++k) // 多重背包，从1开始
                dp[j] = (dp[j] + dp[j - k]) % mod;
    printf("%d", dp[m]);
    system("pause");
    return 0;
}
```

##### 前缀和优化

```C++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 105, mod = 1000007;
int n, m, f[maxn], sum[maxn], a[maxn];
int main(){
    scanf("%d%d", &n, &m);
    register int i, j, k;
    for(i = 1; i <= n; ++i) scanf("%d", &a[i]);
	f[0] = 1;
    for(i=0; i<=m; i++) sum[i] = 1;
    for(i=1; i<=n; i++){
    	for(j=m; j>=1; j--){
    		int t = j - min(a[i], j) - 1;
    		if(t < 0) f[j] = (f[j] + sum[j-1])%mod;
    		else f[j] = (f[j] + sum[j-1] - sum[t] + mod)%mod;
		}
		for(j=1; j<=m; j++) sum[j] = (sum[j-1] + f[j])%mod;
	}
    cout<<f[m]<<endl;
    return 0;
}
```



### P1095 [NOIP2007 普及组] 守望者的逃离

跑步与闪现同时进行，当闪现的距离大于跑步的距离时，更新跑步的距离

```C++
#include<cstdio> 
#include<cstring>
#include<iostream> 
#include<algorithm>
#include<cmath>
using namespace std;
int main()
{
    int m,s,t,now=0;
    cin>>m>>s>>t;
    int s1=0,s2=0;//存放跑步能走的距离和用闪烁能走的距离
    for(int i=1;i<=t;i++)//一个个时间去推
    {
        s1+=17;//闪现和跑步分批进行
        if(m>=10) {s2+=60;m-=10;}//能够闪现这肯定要闪现的，
        else m+=4;//没蓝这一回合就用来回蓝
        if(s2>s1) s1=s2;//闪现的快了就把跑步的替换成闪现的
        if(s1>s){//跑出去了就输出当前时间
            cout<<"Yes"<<endl<<i<<endl;
            return 0;
        }
    }
    cout<<"No"<<endl<<s1<<endl;//时间都用完了还没跑出去，输出“No”和s1的值，（由于闪现可走距离一旦大于跑步的跑步的距离就会被替换，这时跑的距离远的一定是s1）
}
```



### ==P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles==

$dp[i][j]$表示到达第$i$层第$j$个数时的最大值
$$
dp[i][j]=max(dp[i-1][j-1],dp[i-1][j])+f[i][j]
$$

```C++
#include <iostream>
#define N 1005
using namespace std;
int f[N][N], dp[N][N];

int main() {
    int n, res = 0; scanf("%d", &n);
    for(register int i = 1; i <= n; ++i){
        for(register int j = 1; j <= i; ++j) {
            scanf("%d", &f[i][j]);
            dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + f[i][j];
            if(i == n) res = max(res, dp[n][j]);
        }
    }
    system("pause");
    return 0;
}
```

```C++
#include <bits/stdc++.h>
using namespace std;
int dp[1001] = {-1}, map[1001];
int read() {	// 读入优化
  int x = 0, f = 1;
  char ch = getchar();
  while (ch < '0' || ch > '9') {
    if (ch == '-') f = -1;
    ch = getchar();
  }
  while (ch >= '0' && ch <= '9') {
    x = x * 10 + ch - '0';
    ch = getchar();
  }
  return x * f;
}
int main() {
    int MAX = 0;
    int n; scanf("%d", &n);
    for (register int i = 0; i < n; ++i) {
        for (register int j = 0; j <= i; ++j) map[j] = read();
        for (register int j = i; j >= 0; --j) {
            dp[j] = max(dp[j], dp[j-1]) + map[j];
            if (i == n-1) MAX = max(MAX, dp[j]);
        }
    }
    printf("%d", MAX);
    return 0;
}
```



### 方格取数

#### 题目描述

设有$ N×N$ 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。如下图所示：

![](https://cdn.acwing.com/media/article/image/2019/09/12/19_764ece6ed5-2.gif)

某人从图中的左上角 $A$ 出发，可以向下行走，也可以向右行走，直到到达右下角的 $B$ 点。

在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字$0$）。

此人从 $A$ 点到 $B$ 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。第一行为一个整数 $N$，表示 $N×N$ 的方格图。

接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数。

行和列编号从 1 开始。

一行“000000”表示结束。

#### **输出格式**

输出一个整数，表示两条路径上取得的最大的和。

#### **数据范围**

$N≤10$

#### 思想

我们想想如何表示状态表示：

在上面的题中，我们只走一次，但是在这个图中，我们要走两次。

我们可以试着让他们同时出发。

设 $f[i1][j1][i2][j2]$，为两条道路分别从$ (1,1)$走到$ (i1,j1),(i2,j2)$的所有方案中的最大值。

由上面的题我们知道，一条道路有两种情况，两条道路的情况便是它们自由组合得到的数字。

也就是说:
$$
f[i][j][k][l]=max(f[i−1][j][k−1][l],f[i][j−1][k−1][l],f[i−1][j][k][l−1],f[i][j−1][k][l−1])+w[i][j]+w[k][l]
$$
现在考虑题中的另一个限制条件：每个格子中的数只能被取一次。也就是说,当$ (i,j)=(k,l)$ 时，我们只加一次 $w$即可。

然后是对状态的优化。

这两条路线有一个很大的共同点：它们的步数应当相同。也就是说$ i+j=k+l$应当成立。

据此，我们可以优化掉一维的状态：令$ S=i+j=k+l$那么我们可以用$ f[S][i][j]$ 表示：从$ (1,1)$开始分别走到$ (i,S−i),(j,S−j)$的所有方案中取得的最大值，$S∈[1,2n]$。

#### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
const int N=100;
int f[N][N][N], w[N][N];

int main(){
	int n,x,y,z;
	scanf("%d",&n); while(scanf("%d%d%d",&x,&y,&z)!=EOF&&x&&y&&z) w[x][y]=z;
	for(int k=1;k<=2*n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++){
				f[k][i][j]=max(max(f[k-1][i][j-1],f[k-1][i-1][j]),max(f[k-1][i-1][j-1],f[k-1][i][j]))+w[i][k-i];
				if(i!=j) f[k][i][j]+=w[j][k-j];
			}
	printf("%d",f[2*n][n][n]);
	return 0;
}
```



### K取方格数

#### 题目描述

在一个$N×N$ 的矩形网格中，每个格子里都写着一个非负整数。可以从左上角到右下角安排 $K$ 条路线，每一步只能往下或往右，沿途经过的格子中的整数会被取走。若多条路线重复经过一个格子，只取一次。求能取得的整数的和最大是多少。

#### 输入格式

第一行包含两个整数 $N$ 和 $K$。

接下来 $N$ 行，每行包含 $N$ 个不超过 $1000$ 的整数，用来描述整个矩形网格。

#### 输出格式

输出一个整数，表示能取得的最大和

#### 数据范围

$1\le N \le50,0\le K\le10$

#### 代码

将每个格子看做点，向右边和下边连单向边，我们发现这个题被转化成了在一个有向图中最大化一个什么东西。由于多条路径，最短路不大可做，我们考虑网络流。

每条边能够随便通过，所以我们将边的容量设为正无穷。由于每个点还有使用限制，我们套路地拆点。首先连一条容量为$ 1$ 的边，表示这个点只能被取一次权值，权值我们自然使用费用来表达；再连一条容量为 $+∞$ 的边，表示这个点能够无限次通过。

最后我们如何限制路径条数？

建立源点、汇点，源点连向左上角，右下角连向汇点，容量为 $k$。

```C++
#include <bits/stdc++.h>
using namespace std;

const int N=2e4+10, M=4e5+10, INF=1e8+10;

int n,k,S,T;
int head[N],ver[M],nxt[M],cc[M],ww[M],tot=0;
void add(int x,int y,int c,int d){
	ver[tot]=y; cc[tot]=c; ww[tot]=d; nxt[tot]=head[x]; head[x]=tot++;
	ver[tot]=x; cc[tot]=0; ww[tot]=-d; nxt[tot]=head[y]; head[y]=tot++;
}
int q[N],d[N],pre[N],incf[N];
bool vis[N];

inline int get(int x,int y) {return (x-1)*n+y;}

bool spfa(){
	int hh=0,tt=1;
	memset(d,-0x3f,sizeof d);
	memset(incf,0,sizeof incf);
	q[0]=S; d[S]=0,incf[S]=INF;
	while(hh!=tt){
		int x=q[hh++];
		if(hh==N) hh=0;
		vis[x]=0;

		for(int i=head[x];~i;i=nxt[i]){
			int y=ver[i];
			if(cc[i] && d[y]<d[x]+ww[i]){
				d[y]=d[x]+ww[i];
				pre[y]=i;
				incf[y]=min(cc[i],incf[x]);
				if(!vis[y]){
					q[tt++]=y;
					if(tt==N) tt=0;
					vis[y]=1;
				}
			}
		}
	}
	return incf[T]>0;
}

int EK(){
	int cost=0;
	while(spfa()){
		int tmp=incf[T];
		cost+=tmp*d[T];
		for(int i=T;i!=S;i=ver[pre[i]^1]){
			cc[pre[i]]-=tmp;
			cc[pre[i]^1]+=tmp;
		}
	}
	return cost;
}

int main(){
	scanf("%d%d",&n,&k);
	memset(head,-1,sizeof head);
	S=0,T=n*n*2+100; int B=n*n+5;
	add(S,1,k,0);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			int x; scanf("%d",&x);
			int pos=get(i,j);
			add(pos,B+pos,1,x); add(pos,B+pos,INF,0);
			if(i+1<=n) add(B+pos,get(i+1,j),INF,0);
			if(j+1<=n) add(B+pos,get(i,j+1),INF,0);
		}
	}
	add(B+get(n,n),T,k,0);
	printf("%d",EK());
	return 0;
}
```



### ==友好城市==

#### 题目描述

$Palmia$国有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的$N$个城市。

北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。

每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。

编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航线不相交的情况下，被批准的申请尽量多。

#### **输入格式**

第 $1$ 行，一个整数 $N$ ，表示城市数。

第 $2$ 行到第 $n+1$ 行，每行两个整数，中间用 $1$ 个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。

#### **输出格式**

仅一行，输出一个整数，表示政府所能批准的最多申请数。

#### **数据范围**

$1≤N≤5000,0≤xi≤10000$

#### 思想

- 一条数轴上的给定点向另外一个平行数轴上的给定点连边。
- 一个点只有一个对应的点
- 连边之间不能有交叉
- 求最多能连边的点对数目

以上方的轴为 A 轴，另一根为 B 轴，那么将 A 轴上的点的顺序作为基准， B 轴上对应的点的坐标是单调递增的。

也就是说，我们将友好城市对按照其中一边的城市坐标排序，最大批准数方案就是另外一根轴上恒坐标的最长上升子序列长度。

#### 代码

```C++
#include <iostream>
#include <algorithm>
#define maxn 5005
#define P pair<int, int>
using namespace std;
P h[maxn];
int dp[maxn], len = 1;

int main() {
    int N; scanf("%d", &N);
    for(register int i = 1; i <= N; ++i) {
        int u, v; scanf("%d%d", &u, &v);
        h[i] = P(u, v);
    }
    sort(h + 1, h + N + 1);
    dp[1] = h[1].second;
    for(register int i = 2; i <= N; ++i){
        if(dp[len] < h[i].second) dp[++len] = h[i].second;
        else *lower_bound(dp + 1, dp + len + 1, h[i].second) = h[i].second;
    }
    printf("%d", len);
    return 0;
}
```



### 导弹拦截系统

#### 题目描述

为了对抗附近恶意国家的威胁，R 国更新了他们的导弹防御系统。

一套防御系统的导弹拦截高度要么一直 严格单调 上升要么一直 严格单调下降。例如，一套系统先后拦截了高度为 3 和高度为 4 的两发导弹，那么接下来该系统就只能拦截高度大于 4 的导弹。

给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，就可以将它们全部击落。

#### 输入格式

输入包含多组测试用例。

对于每个测试用例，第一行包含整数 $n$，表示来袭导弹数量。

第二行包含 $n$ 个不同的整数，表示每个导弹的高度。

当输入测试用例 $n=0$ 时，表示输入终止，且该用例无需处理。

#### 输出格式

对于每个测试用例，输出一个占据一行的整数，表示所需的防御系统数量。

#### 代码

```C++
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n;
int poi[N];
int up[N],down[N];
int ans=1145141919;

void dfs(int u,int l1,int l2)
{
	if(l1+l2>=ans) return ;//最优化剪枝
	if(u==n) {ans=l1+l2; return ;}
	int tmp;

	/*将其放入上升序列中*/
	if(poi[u]>up[l1]) tmp=up[l1+1],up[l1+1]=poi[u],dfs(u+1,l1+1,l2),up[l1+1]=tmp;
	else{
		int l=lower_bound(up+1,up+1+l1,poi[u])-up;
		tmp=up[l]; up[l]=poi[u]; dfs(u+1,l1,l2);
		up[l]=tmp;
	}

	/*将其放入下降序列中*/
	if(poi[u]<down[l2]) tmp=down[l2+1],down[l2+1]=poi[u],dfs(u+1,l1,l2+1),down[l2+1]=tmp;
	else{
		int l=lower_bound(down+1,down+1+l2,poi[u],greater<int>())-down;
		tmp=down[l]; down[l]=poi[u]; dfs(u+1,l1,l2);
		down[l]=tmp;
	}
}

int main()
{
	while(scanf("%d",&n)!=EOF&&n)
	{
		for(int i=1;i<=n;i++)
			scanf("%d",&poi[i]);
		ans=n;
		memset(down,0x3f,sizeof down);
		dfs(1,0,0);
		printf("%d\n",ans);
	}
	return 0;
}
```



### 设计密码

#### 题目描述

你现在需要设计一个密码 $S$，$S$ 需要满足：

$S$ 的长度是$ N$；
$S$ 只包含小写英文字母；
$S$ 不包含子串 $T$；
例如：$abc$ 和 $abcde$ 是 $abcde$ 的子串，$abd$ 不是 $abcde$ 的子串。

请问共有多少种不同的密码满足要求？

由于答案会非常大，请输出答案模 $10^9+7$ 的余数。

#### **输入格式**

第一行输入整数 $N$，表示密码的长度。

第二行输入字符串 $T$，$T$中只包含小写字母。

#### **输出格式**

输出一个正整数，表示总方案数模 $10^9+7$ 后的结果。

#### **数据范围**

$1≤N≤50 1≤|T|≤N$，$|T| $是 $T$ 的长度。

#### 思路

- 状态设计：

  $f(i,j)$ 表示构造 $i$ 长度的密码串，且与题目给出的字符串匹配到 $j$ 位的方案数量。

- 状态计算：

  $f(i+1,t)=∑_{k∈{a,b,…,z}}f(i,j)$，即枚举第$ i$ 位上的字符 $k $为 $a→z$，所有能匹配到的位置 $t$ 上的状态之和。类似于刷表法，每个状态 $f(i,j)$ 将它能够更新到的 $f(i+1,t)$ 更新。

#### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

const int N=100,mod=1e9+7;
char ch[N];
int f[N][N],nxt[N];
int n;

int main()
{
	cin>>n>>(ch+1);
	int m=strlen(ch+1);
	for(int i=2,j=0;i<=m;i++)
	{
		while(j&&ch[i]!=ch[j+1]) j=nxt[j];//不相等则退回一位
		if(ch[i]==ch[j+1]) ++j;//相等则携手共进
		nxt[i]=j;//nxt[i]：以 i 为终点的后缀与前缀相等的最长长度
	}

	f[0][0]=1;
	for(int i=0;i<n;i++)//枚举构造的位数
	{
		for(int j=0;j<m;j++)//枚举匹配到的位置
		{
			for(char k='a';k<='z';k++)//枚举这个位置上的取值
			{
				int tmp=j;//小心不要把枚举的 j 修改掉了
				while(tmp && k !=ch[tmp+1]) tmp=nxt[tmp];//回跳
				if(k==ch[tmp+1]) ++tmp;//向下匹配
				if(tmp<m) f[i+1][tmp]=(f[i+1][tmp]+f[i][j])%mod;//累加方案数
			}
		}
	}
	int res=0;
	for(int i=0;i<m;i++) res=(res+f[n][i])%mod;
	cout<<res;
	return 0;
}
```



### ==国王(状压DP——棋盘式DP)==

#### 题目描述

在 $n×n$ 的棋盘上放 $k$ 个国王，国王可攻击相邻的 $8$ 个格子，求使它们无法互相攻击的方案总数。

#### **输入格式**

共一行，包含两个整数 $n$ 和 $k$。

#### **输出格式**

共一行，表示方案总数，若不能够放置则输出 $0$。

#### **数据范围**

$1≤n≤10, 0≤k≤n^2$

#### 思路

按行枚举，我们发现，**当我们在试图摆第 $i$ 行的棋子时，这一行哪些位置能摆完全取决于上一行的摆法**，与上上行完全没有关系。这就提示我们只关心上一行怎么摆。我们可以将每一行表示成一个 01 串，$0$ 表示这个位置没摆国王；$1$ 表示这个位置摆了国王。可以将这个 01 串看做二进制表示，将其压缩成一个十进制数。

状态设计：设 $f(i,j,state)$ 表示确定完了前 i 行，用了 j 个棋子，第 i 行的状态是 state 的所有方案数。

。。。。

1. $a\&b=0$。
2. $a, b, (a|b)$不能有相邻的 1。

只要满足以上两个条件，我们的状态就是合法的。也就是说，已经摆完前 i 行，状态为 $a$ ， 且已经摆了 j 个国王的所有方案都可以由已经摆完了前 $i−1$ 行，并且第$ i−1$ 行状态为$ b$ 且摆了 $j−count(a)$ 个国王的所有方案转移过去。也就是 $f(i−1,j−count(a),b) $。

#### 代码

```C++
#include <iostream>
#include <vector>
#define ll long long
#define N 15
using namespace std;
int n, m;
ll f[N][N*N][1<<(N-4)];
vector<int> state;  // 合法状态
vector<int> head[1<<(N-4)];     // 状态转移
int id[1<<(N-4)], cnt[1<<(N-4)];

// ~x是按位取反，-x是按位取反后加一:x & -x == x & (~x + 1)
int lowbit(int x) {return x & -x;}
int count(int x){
    int res = 0;
    while(x) x -= lowbit(x), ++res;
    return res;
}
int main() {
    scanf("%d%d", &n, &m);
    register int i, j, a, b;
    for(i = 0; i < (1 << n); ++i){ //预处理合法状态
        if(i & (i >> 1)) continue;  // 为true表示有连续的1存在
        state.push_back(i);
        id[i] = state.size() - 1;   // 记录这个数在state中是第几个
        cnt[i] = count(i);  // cnt[i]记录i中1的个数
    }
    for(i = 0; i < state.size(); ++i){ //预处理状态转移关系
        for(j = 0; j < state.size(); ++j){
            a = state[i], b = state[j];
            if((a&b)==0 && ((a|b)&((a|b)>>1))==0) head[i].push_back(j);
        }
    }
    f[0][0][0] = 1;
    for(i = 1; i <= n + 1; ++i)
        for(j = 0; j <= m; ++j)
            for(a = 0; a < state.size(); ++a)
                for(b = 0; b < head[a].size(); ++b){
                    int t = head[a][b], c = cnt[state[a]];
                    if(j >= c) f[i][j][a] += f[i-1][j-c][t];
                }
    printf("%lld", f[n+1][m][0]);
    return 0;
}
```



### 玉米田(状压DP——棋盘式DP)

#### 题目描述

农夫约翰的土地由 $M×N$ 个小方格组成，现在他要在土地里种植玉米。非常遗憾，部分土地是不育的，无法种植。而且，相邻的土地不能同时种植玉米，也就是说种植玉米的所有方格之间都不会有公共边缘。现在给定土地的大小，请你求出共有多少种种植方法。土地上什么都不种也算一种方法。

#### 输入格式

第 1 行包含两个整数 M 和 N。

第 $2…M+1$ 行：每行包含 N 个整数 0 或 1，用来描述整个土地的状况，1 表示该块土地肥沃，0 表示该块土地不育。

#### 输出格式

输出总种植方法对 $10^8$ 取模后的值。

#### 数据范围

$1\le M,N\le12$

#### 思路

当前行的状态仍然只能被上一行影响到。

- 状态表示：
  $f(i,st)$ 为摆了前 $i$ 行且第 $i$ 行状态为 $st$ 的所有方案数。

对于状态计算，我们仍然是找最后一个不同点。最后一行的状态都是一样的，我们要根据倒数第二行的状态来分类。我们要从上一行的状态中找到能够正确转移到当前状态的状态。

假设第 i 行的状态为 a，第 i−1 行状态为 b。由于这里的限制是不能有公共边，所以合法的状态转移要满足的条件是：

1. a&b=0
2. a,b 不能有相邻的 1

只要 b 能满足上述条件，那么 f(i−1,b) 就能合法地转移到 f(i,a) 。预处理方式参考上面。

#### 代码

```C++
#include <iostream>
#include <vector>
#define mod 100000000
#define ll long long
using namespace std;
int n, m, f[13][1<<12 + 2], is[13];
vector<int> vec, head[1<<12 + 2];

int main() {
    scanf("%d%d", &m, &n);
    register int i, j, k, a, b;
    for(i = 1; i <= m; ++i)
        for(j = 0; j < n; ++j){
            int x; scanf("%d", &x);
            is[i] += (!x) * (1 << j);
        }
    for(i = 0; i < (1 << n); ++i)
        if(!(i&(i>>1))) vec.push_back(i);
    for(i = 0; i < vec.size(); ++i)
        for(j = 0; j < vec.size(); ++j){
            a = vec[i], b = vec[j];
            if(!(a&b)) head[i].push_back(j);
        } 
    f[0][0] = 1;
    for(i = 1; i <= m + 1; ++i)
        for(j = 0; j < vec.size(); ++j){
            if(!(vec[j]&is[i]))
                for(k = 0; k < head[j].size(); ++k)
                    f[i][j] = (f[i][j] + f[i-1][head[j][k]]) % mod;
        }
    printf("%d", f[m+1][0]);

    return 0;
}
```



### 炮兵阵地(状压DP——棋盘式DP)

#### 题目描述

司令部的将军们打算在 $N×M$ 的网格地图上部署他们的炮兵部队。

一个 $N×M$ 的地图由 $N $行 $M$ 列组成，地图的每一格可能是山地（用 $H$ 表示），也可能是平原（用 PP 表示），如下图。

在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：

![1185_1](https://www.acwing.com/media/article/image/2019/02/16/19_d512cdba31-1185_1.jpg)

如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。

图上其它白色网格均攻击不到。

从图上可见炮兵的攻击范围不受地形的影响。

现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。

#### 输入格式

第一行包含两个由空格分割开的正整数，分别表示 $N$ 和 $M$；

接下来的 $N$ 行，每一行含有连续的 $M$ 个字符( $P$ 或者 $H$ )，中间没有空格。按顺序表示地图中每一行的数据。

#### **输出格式**

仅一行，包含一个整数 $K$，表示最多能摆放的炮兵部队的数量。

#### 数据范围

$N\le100,M\le100$

#### 思路

此时我们的状态涉及到了前两行，所以我们要关心前两行的状态。

- 状态设计：设 f(b, a, i) 为摆到第 i 行，第 i 行状态为 a，第 i−1 行状态为 b 的最大方案。

思考限制条件，一个棋子附近横竖两格都不能放置棋子，并且有一些格子不能放置棋子，假设第 i 行状态是 a ，第 i−1 行状态是 b，第 i−2 行状态是 c，第 i 行各个格子的可用情况为 g[i] ( 0 为可放 11 为不可放)，那么：

1. $(a\&b)|(a\&c)|(b\&c)=0$
2. $(a\&g[i])|(b\&g[i−1])|(c\&g[i−2])=0$
3. 相邻两个 1 之间至少隔两个 0。
4. 状态转移方程为$dp[b][a][i]=\max(dp[b][a][i],dp[c][b][i-1]+count(i))$

算算时间复杂度 $O(n2^{3m})$ 看起来过不了。

但是实际上在本题的强限制下，有效状态少得多。我们将状态转移预处理即可。

#### 代码

```C++
#include <iostream>
#include <vector>
#define maxn 105
using namespace std;
int N, M, is[maxn], f[2][1<<10][1<<10]; 
vector<int> vec;

inline int lowbit(int x) {return x & -x;}
inline int count(int x){
    int res = 0;
    while(x) x -= lowbit(x), ++res;
    return res;
}
inline int check(int x){
    for(register int i = 0; i < M; ++i)
        if(((x>>i)&1) && ((x>>(i+1)&1) || (x>>(i+2)&1))) return 0;
    return 1;
}
int main() {
    scanf("%d%d", &N, &M);
    register int i, j, k, u;
    for(i = 1; i <= N; ++i)
        for(j = 0; j < M; ++j){
            char c; cin >> c;
            if(c=='H') is[i] += (1<<j);
        }
    for(i = 0; i < (1 << M); ++i)
        if(check(i)) vec.push_back(i);
    for(i = 1; i <= N + 2; ++i)
        for(j = 0; j < vec.size(); ++j) // 当前行
            for(k = 0; k < vec.size(); ++k) //上一行
                for(u = 0; u < vec.size(); ++u) {
                    int a = vec[j], b = vec[k], c = vec[u];
                    if((a&b)|(b&c)|(a&c)) continue;
                    if((is[i]&a)|(is[i-1]&b)) continue;
                    f[i&1][j][k] = max(f[i&1][j][k], f[(i-1)&1][k][u]+count(a));
                }
    printf("%d", f[(N+2)&1][0][0]);
    system("pause");
    return 0;
}
```



### 环形石子合并

#### 题目描述

将 n 堆石子绕圆形操场排放，现要将石子有序地合并成一堆。

规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。

请编写一个程序，读入堆数 n 及每堆的石子数，并进行如下计算：

1. 选择一种合并石子的方案，使得做 n−1 次合并得分总和最大。
2. 选择一种合并石子的方案，使得做 n−1 次合并得分总和最小。

#### 输入格式

第一行包含整数 n，表示共有 n 堆石子。

第二行包含 n 个整数，分别表示每堆石子的数量。

#### **输出格式**

输出共两行：

第一行为合并得分总和最小值，

第二行为合并得分总和最大值。

#### **数据范围**

$1≤n≤200$

#### 思路

对于环形，我们有一个非常非常 常见的技巧：破环为链。

什么是破环为链？我们**将链从一个地方断开，得到一个序列，然后再将这条链复制一遍接在后面。这样，我们所有在环中可能出现的区间就全部存在了**。

设状态 $f(i,j)$ 表示所有将区间 $[i,j]$ 内全部石子全部合并的方案得到分数的最大/小值。

我们用不同方法把 $[i,j]$ 划分成两个集合，得到数个左右端点分别为$ i,j $的子区间对 $([i,k],[k,j])$。仍然找最后一个不同点。这些方案的不同就是区间的分界点不同。我们将子区间对两边的区间答案合并起来即可。

也就是说 $f(i,j)=\min\or \max\{f(i,k)+f(k+1,j)\}+str(i,j)$ 其中 $str(i,j)$ 是区间$ [i,j] $中石子的总数。

最后统计答案的时候，我们合并的区间长度最大是 $n$ ，所以要枚举所有长度为 $n$ 的区间取最值。

这类一维区间上的 $DP$ 一般都使用迭代的方式，迭代循环也基本固定：

```C++
for(int len = 1; len <= n; ++i)	// 枚举长度
    for(int l = 1; l + n - 1 <= n << 1; ++l){	// m
        int r = l + len - 1;
        /** do something */
    }
```

#### 代码

```C++
#include <iostream>
#include <cstring>
using namespace std;
int S[405], dp1[405][405], dp2[405][405];

int main() {
    int n; scanf("%d", &n);
    register int i, k, len;
    for(i = 1; i <= n; ++i) {
        scanf("%d", &S[i]);
        S[n + i] = S[i];
    }
    for(i = 1; i <= (n << 1); ++i) S[i] += S[i - 1];
    memset(dp2, 0x3f sizeof dp2);
    for(len = 1; len <= n; ++len){
        for(i = 1; i + len - 1 < (n << 1); ++i){
            for(k = i; k < i + len - 1; ++k) {
                if(len == 1) dp1[i][i + len - 1] = dp2[i][i + len -1] = 0;
                dp1[i][i + len - 1] = max(dp1[i][k], dp1[k+1][i + len - 1]) + S[i + len - 1] - S[i - 1];
                dp2[i][i + len - 1] = min(dp2[i][k], dp2[k+1][i + len - 1]) + S[i + len - 1] - S[i - 1];
            }
        }
    }
    int ans1 = 0, ans2 = 1e8;
    for(len = 1; len <= n; ++len){
        ans1 = max(ans1, dp1[i][i + n - 1]);
        ans2 = min(ans2, dp2[i][i + n - 1]);
    }
    printf("%d\n%d", ans1, ans2);
    return 0;
}
```



### 数位DP

#### 定义

数位dp(Digit Entry DP)是一种计数用的dp，一般就是要哦统计区间`[l,r]`内满足一些条件的数的个数。所谓数位dp，字面意思就是在数位上进行dp。数位的含义：一个数有个位、十位、百位、千位......数的每一位就是数位啦！

#### 思想

数位dp的实质就是换一种暴力枚举的方式，使得新的枚举方式满足dp的性质，然后记忆化就可以了。

#### 模板

```
typedef long long ll;
int a[20];
ll dp[20][state];   //不同题目状态不同
ll dfs(int pos,int state,bool lead,bool limit)       //变量，状态，前导0，数位上界；注意不是每题都要判断前导零
{
    if(pos==0) return 1;    //递归边界，一般一种递归到结束只能产生一种情况
    if(!limit && !lead && dp[pos][state]!=-1) return dp[pos][state];    //记忆化
    int up=limit?a[pos]:9;  //枚举上界
    ll ans=0;               //计数
    for(int i=0;i<=up;i++)  //枚举，然后把不同情况的个数加到ans就可以了
    {
        if() ...
        else if()...        //一下条件
        ans+=dfs(pos-1,/*状态转移*/,lead && i==0,limit && i==a[pos]) //最后两个变量传参都是这样写的
        //state状态转移要保证i的合法性，比如不能有62，那么当pre==6&&i==2就不合法，这里用state记录pre是否为6即可。
    }
    if(!limit && !lead) dp[pos][state]=ans;
    return ans;
}
ll solve(ll x){
    int tot=0;
    while(x)
    {
        a[++tot]=x%10;
        x/=10;
    }
    return dfs(tot/*从最高位开始枚举*/,/*一系列状态 */,true,true);//刚开始最高位都是有限制并且有前导零的，显然比最高位还要高的一位视为0嘛
}
int main(){
    ll le,ri;
    while(~scanf("%lld%lld",&le,&ri)){
        //初始化dp数组为-1,这里还有更加优美的优化,后面讲
        printf("%lld\n",solve(ri)-solve(le-1));
    }
}
```



### 度的数量(数位DP)

#### 题目描述

求给定区间 $[X,Y]$ 中满足下列条件的整数个数：这个数恰好等于 $K$ 个互不相等的 $B$ 的整数次幂之和。

例如，设 $X=15,Y=20,K=2,B=2$，则有且仅有下列三个数满足题意：
$$
17=2^4+2^0\\18=2^4+2^1\\20=2^4+2^2
$$

#### **输入格式**

第一行包含两个整数 X 和 Y，接下来两行包含整数 K 和 B。

#### **输出格式**

只包含一个整数，表示满足条件的数的个数。

#### **数据范围**

$1≤X≤Y≤2^{31}−1,1≤K≤20,2≤B≤10$

#### 思想

解释一下题意，我们们要统计在 $[L,R]$ 中，有多少整数在 B 进制下只有恰好 k 个 1。

可以通过在 B 进制下逐位填 1 来构造一个合法的数。

我们可以设状态 $f(k)$ 表示区间 $[1,k]$ 中满足条件的整数有多少个。

首先将其转为一个 B 进制数 $K_{(B)}=a_{n-1}a_{n-2}a_{n-3}\dots a_0$。

然后我们开始从高到低填数。

对于第 i 位 $a_i$，假设我们已经填了 last 个 1 ，总共需要填 k 个 1；根据原数当前位 $a_i$ 的大小情况枚举情况讨论：

假设我们要填在这一位的数是 $a_i^′$。

- $a_i=0$：这一位只能填 0，没得选，我们要继续看下一个数 $a_{i−1}$ 。
- $a_i=1$:我们讨论这一位填0还是填1：
  - $a_i^′=0$ 那么后面的位数我们能够随便填，总共有 i 个位置，有 k−last 个 1 要填，方案数就是$C_i^{k−last}$。
  - $ai′=1$ 我们就要看下一位怎么填。
- $a_i>1$：当前位无论填 1 还是填 0 后面的位数都可以随便填，也就是说，总共的方案数有 $C^{k−last−1}_i+C^{k−last}_i $。
- 边界情况：当我们一直填下去，到 $a_0$ 时，若 last=k 也就是刚好填 k 个 1 的时候，这也是一种方案。

#### 代码

```C++
#include <iostream>
#include <vector>
#define ll long long
#define N 40
using namespace std;
ll C[N][N];
int k, b;

void init(){    // 预处理组合数
    for(register int i = 0; i < N; ++i)
        for(register int j = 0; j <= i; ++j){
            if(j == 0) C[i][j] = 1;
            else C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
        }
}

ll dp(ll n){
    if(!n) return 0;    // 特判0
    vector<int> nums;
    while (n) nums.push_back(n % b), n /= b;
    ll last = 0, res = 0;
    for(register int i = nums.size() - 1; i >= 0; --i){
        int x = nums[i];
        if(x){
            res += C[i][k - last];
            if(x > 1) {
                if(k - last - 1 >= 0) res += C[i][k - last - 1];
                break;
            }else{
                ++last;
                if(last > k) break;
            }
        }
        if(!i && last == k) ++res;
    }
    return res;
}

int main() {
    init();
    int x, y; scanf("%d%d%d%d", &x, &y, &k, &b);
    printf("%d", dp(y) - dp(x - 1));
    return 0;
}
```

