# 动态规划（“以前的”）

### 1.1题目特点：

#### 计数问题

- 有多少种方式走到右下角
- 有多少种方法选出k个数使得和是Sum

#### 求最值

- 从左上角走到右下角路径的最大数字和
- 最长上升子序列长度

#### 求存在性

- 取石子游戏，先手是否必胜
- 能不能选出$k$个数使得和是$Sum$

### 1.2常见类型：

#### **坐标型动态规划(20%)**

最简单的动态规划类型，给定一个序列或者网络，需要找到序列中某个/些或网络中的某条路径

- 某种性质最大/最小
- 计数
- 存在性

**动态规划方程f[i]中的下标i表示以$a_i$结尾的满足条件的子序列的性质，f[i]\[j]中的下标i,j表示以格子(i,j)为结尾的满足条件的路径的性质。**

#### **序列型动态规划(20%)**

给定一个序列，动态规划方程f[i]中的**下标i表示前i个元素a[0],a[1],...,a[i - 1]的某种性质**，初始化中，f[0]表示空序列的性质。

#### **划分型动态规划(20%)**

#### **区间型动态规划(15%)**

#### 背包型动态规划(10%)

有一个背包，背包有最大承重，商店有若干物品，每个物品有重量和价值，目标：在不撑爆背包的前提下：

- 装下最多重量物品
- 装下最大总价值的物品
- 有多少种方式正好带走满满一书包物品

#### 最长序列型动态规划(5%)

#### 博弈型动态规划(5%)

博弈为两方游戏，一方先下，在一定规则下先后出招，满足一定条件后一方取胜。

#### 综合型动态规划(5%)

### 1.3动态规划组成部分

#### 确定状态：

解动态规划时候需要开一个数组，数组的每个元素$f[i]$或者$f[i][j]$代表什么。

**需要两个意识：**

- **最后一步**
- **子问题**

#### 转移方程:

#### 初始条件和边界情况：

#### 计算顺序：

数量大的依赖数量小的，就从小到大计算

### 2.1例题一(最值型动态规划)：

#### 问题：

你有三种硬币，分别面值2元，5元，7元，每种硬币都有足够多。买一本书需要27元。如何用**最少的硬币组合**正好付清，不需要对方找钱。

#### 思考：

##### 最后一步：

最终策略肯定是$K$枚硬币$a_1,a_2,......,a_k$面值加起来等于27.所以一定有最后一枚硬币$a_k$，除掉这枚硬币，前面硬币的面值加起来$27-a_k$

##### 子问题：

最少用多少枚硬币可以拼出$27-a_k$​​。规模更小。$a_k$只能是2,5,7

##### 定义状态：

**设状态f(x) = 最少用多少枚硬币拼出x**

如果$a_k$是2,f(27) = f(27-2) + 1

如果$a_k$是5,f(27) = f(27 - 5) + 1

如果$a_k$是7,f(27) = f(27-7) + 1

**因为硬币数最小，所以f(27) = min{f(27-2) + 1,  f(27 - 5) + 1, f(27-7) + 1}**

##### 转移方程:

设状态f[x] = 最少用多少枚硬币拼出x

对于任意的x,有f(x) = min{f(x-2) + 1,  f(x - 5) + 1, f(x-7) + 1}

##### 初始条件和边界情况：

如果不能拼出Y，就定义f[Y] = 正无穷

初始条件:f[0] = 0

##### 评价：

每一步尝试三种硬币，一共27步，与递归算法相比，没有任何重复计算。时间复杂度$27 *3$

```java
/**
 * @param A 硬币的币值构成的数组，如[2,5,7]
 * @param M 需要硬币面值拼凑出的钱数
 * @return
 */
#include <bits/stdc++.h>
using namespace std;
int coinChange(int[] A, int N, int M){
	int f[] = new int[M + 1];
	int i, j;
	f[0] = 0;
	for(i = 0; i <= M; i++){
		f[i] = INT_MAX;
		for(j = 0; j < N; j++){
			if(i >= A[j] && f[i - A[j]] != INT_MAX && f[i - A[j]] + 1 < f[i]){
				f[j] = f[i - A[j]] + 1;
			}
		}
	}
	if(f[M] == INT_MAX) return -1;
	else return f[M];
}
int main(){
	return 0;
} 
```

### 2.2例题二(计数型)：

#### 问题：

给定m行n列的网格，有一个机器人从左上角$(0,0)$出发，每一步可以向下或者向右走一步。问有多少种不同的方式走到右下角。

#### 思考：

##### 最后一步

无论机器人用何种方式到达右下角，总有最后挪动的一步：向右或者向下。

**右下角坐标设置为(m - 1, n - 1),那么前一步机器人一定是在(m - 2, n- 1)或者(m - 1, n - 2)**

##### 子问题

如果机器人有X种方式走到(m - 2, n - 1), 有Y种方式走到(m - 1, n - 2)，则机器人有X + Y种方式走到(m - 1, n - 1)

##### 定义状态：

状态：设f\[i][j]为机器人有多少种方式从左上角走到(i, j)

f\[m - 1][n - 1\] = f\[m - 2]\[n - 1] + f\[m - 1][n - 2];

##### 转移方程：

f\[i][j] = f\[i - 1][j] + f\[i][j - 1];

##### 初始条件和边界情况：

初始条件：f\[0][0] = 1;

边界情况：i = 0或者j = 0,则前一步只能有一个方向过来,f\[i\]\[j\] = 1;

##### 计算顺序：

计算第0行：f\[0][0],f\[0][1].......,f\[0][j]

计算第1行：f\[1][0],f\[1][1].......,f\[1][j]

。。。

计算第i行:f\[i][0],f\[i][1].......,f\[i][j]

##### 评价：

时间复杂度O(MN),空间复杂度O(MN)

```java
/**
 * @param m,n positive integer (1 <= n, m <= 100)
 * @return an integer
 */
#include <bits/stdc++.h>
using namespace std;
int uniquePaths(int m, int n){
	int f[m][n];
	memset(f, 0, sizeof f);
	int i, j;
	for(i = 0; i < m; i++){
		for(j = 0; j < n; j++){
			if(i == 0 || j == 0) f[i][j] = 1;
			else f[i][j] = f[i - 1][j] + f[i][j - 1];
		}
	}
	return f[m - 1][n - 1];
}
int main(){
  return 0;
}
```

### 2.3例题三(存在性)：

#### 问题：

有n块石头分别在x轴的0,1,...,n - 1位置，一只青蛙在石头0，想跳到石头n - 1,如果青蛙在第i块石头上，它**最多可以向右跳**距离$a_i$,问青蛙能否跳到石头n - 1上。

例子：

输入：a = [2, 3, 1, 1, 4]

输出：True

输入：a = [3, 2, 1, 0, 4]

输出：False

#### 思考：

##### 确定状态：

如果青蛙能够跳到最后一块石头$n - 1$,我们考虑它跳的最后一步，这一步是从石头i跳过来，i < n - 1;

需要满足两个条件：

- 青蛙可以跳到石头i
- $n - 1 - i <= a_i$

##### 子问题：

青蛙能不能跳到石头i (i < n - 1)

##### 定义状态：

状态：设f[j]表示青蛙能不能跳到石头j

##### 状态转移方程：

$f[j] = OR_{0\leq i<j}(f[i]\quad AND\quad i+ a[i]\geq j)$

$OR_{0\le i<j}$表示上一个跳到石头i，并且只要满足一个

##### 初始条件和边界情况：

f[0] = True；无边界情况。

##### 计算顺序：

从小到大，时间复杂度O(N * N),空间复杂度O(N)

```java
#include <bits/stdc++.h>
using namespace std;
bool canJump(int[] A, int n){
	bool f[n];
	for(int j = 1; j < n; j++){
		f[j] = false;
		for(int i = 0; i < j; i++){
			if(f[i] && i + A[i] >= j){
				f[j] = true;
				break;
			}
		}
	}
	return f[n - 1];
}
int main(){
	return 0;
}
```

### 3.1坐标型动态规划1：

#### 问题：

给定$m$行$n$列的网格，有一个机器人从左上角$(0,0)$出发，每一步都可以向下或者向右走一步。网格中有些地方有障碍，机器人不能通过障碍格。问有多少种不同的方式走到右下角。

![动态规划](D:\JAVA项目\图片\动态规划.png)

##### 最后一步

无论机器人用何种方式到达右下角，总有最后挪动的一步：向右或者向下。

**右下角坐标设置为$(m - 1, n - 1),$那么前一步机器人一定是在(m - 2, n- 1)或者(m - 1, n - 2)**

##### 子问题

如果机器人有X种方式走到(m - 2, n - 1), 有Y种方式走到(m - 1, n - 2)，则机器人有X + Y种方式走到(m - 1, n - 1)

##### 定义状态：

状态：设f\[i][j]为机器人有多少种方式从左上角走到(i, j)

f\[m - 1][n - 1\] = f\[m - 2]\[n - 1] + f\[m - 1][n - 2];

##### 转移方程：

f\[i][j] = f\[i - 1][j] + f\[i][j - 1];

##### 初始状态和边界：

如果左上角(0,0)或者$(m - 1, n - 1)$有障碍，直接输出0

如果(i,j)格有障碍，f[i]\[j] = 0，表示机器人不能走到此格。

初始条件：f[0][0\]  = 1;

```java
public int uniquePathsWithObstacles(int[][] A){
    int m = A.length;
    if (m == 0){
        return 0;
    }
    int n = A[0].length;
    int[][] f = new int[m][n];
    int i, j;
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            if (A[i][j] == 1){ //obstacle
                f[i][j] = 0;
            }else{
                if (i == 0 && j == 0){
                    f[i][j] = 1;
                }else{
                    f[i][j] = 0;
                    if (i - 1 >= 0){
                        f[i][j] += f[i - 1][j];
                    }
                    if (j - 1 >= 0){
                        f[i][j] += f[i][j - 1];
                    }
                }
            }
        }
    }
    return f[m - 1][n - 1];
}
```

### 3.2序列型动态规划1:

#### 问题：

有一排N栋房子，每栋房子要漆成三种颜色中的一种：红、绿、蓝。任何两栋相邻的房子不能漆成相同的颜色。第i栋房子染成红色、蓝色、绿色的花费分别是cost\[i][0],cost\[i][1],cost[i\][2]。问最少要花多少钱油漆这些房子？

##### 抽象：

...前i个...最小/方法数/可行性

#### 思路：

##### 最后一步：

最优策略中房子$N-1$一定染成了红、蓝、绿中的一种。

不知道$N-2$​是什么颜色，就把它记录下来。

##### 子问题：

分别记录油漆前$N-1$​栋房子并且房子$N-2$​是红色、蓝色、绿色的最小花费。

求油漆前$N$栋房子并且房子$N-1$是红色、蓝色、绿色的最小花费。

##### 定义状态：

设油漆前i栋房子并且房子i - 1是红色、蓝色、绿色的最小花费为$f[i][0],f[i][1],f[i][2]$

- 注意：下标是从0开始计算。
- 序列型动态规划都是如此定义。

##### 转移方程：

f\[i][0] = min{f\[i - 1][1] , f[i - 1]\[2]} + cost[i - 1]\[0]

f\[i][1] = min{f\[i - 1][0], f[i - 1]\[2]} + cost[i - 1]\[1]

f\[i][2] = min{f\[i - 1][1], f[i - 1]\[0]} + cost[i - 1]\[2]

- cost[i - 1]\[0]表示第i - 1栋染成红色的花费，第i - 1栋房子是前i栋房子的最后一栋房子，因为房子下标从0开始。

##### 初始条件：

f[0]\[0] = f[0]\[1] = f[0\][2] = 0,即不油漆任何房子花费为0

无边界情况。

##### 计算顺序：

从小到大，计算f[N]\[0],f[N]\[1],f[N]\[2]的最小值，时间复杂度为O(N),空间复杂度为O(N)

```java
/**
 * @param costs n x 3 cost matrix
 * @return an integer, the minimum cost to paint all houses
 */
public int minCost(int[][] costs){
    int n = costs.length;
    if (n == 0){
        return 0;
    }
    int[][] f = new int[n + 1][3];
    int i, j;
    //init
    f[0][0] = f[0][1] = f[0][2] = 0;
    for (i = 1; i < n; i++) {
        for (j = 0; j < 3; j++) {
            f[i][j] = Math.min(f[i - 1][(j + 1) % 3], f[i - 1][(j + 2) % 3]) + costs[i - 1][j];
        }
    }
    return Math.min(f[n][0],Math.min(f[n][1],f[n][2]));
}
```

### 3.3划分型动态规划1：

#### 问题：

有一段由A-Z组成的字母串信息被加密成数字串，加密方式为$A->1，B->2,...,Z->26$，给定加密后的数字串$S[0...N-1]$,问有多少种方式解密成字母串。

例如：输入12，可以解密成AB或者L

#### 思路：

##### 最后一步：

对应最后一个字母，这个字母加密时变成1,2,...或者26

##### 子问题：

设数字串长度为N，要求数字串前N个字符的解密方式数，需要知道数字串前N - 1和N - 2个字符的解密方式数。

##### 定义状态：

状态：设数字串前i个数字解密成字母串有f[i]种方式

状态转移方程：f[i] = f\[i - 1](要求S[i - 1]必须对应一个字母) + f\[i - 2](要求S[i - 2,i - 1]必须对应两个字母)

##### 初始条件：

f[0] = 1,即空串有1种方式解密，解密成空串。

##### 计算顺序：

$f[0],f[1]...,f[n]$

时间复杂度和空间复杂度都是$O(N)$

```java
/**
 * @param ss a string, encoded message
 * @return an integer, the number of ways decoding.
 */
public int numDecoding(String ss){
    char[] s = ss.toCharArray();
    int n = s.length;
    if (n == 0){
        return 1;
    }
    int[] f = new int[n + 1];
    //init
    f[0] = 1;
    int i, t;
    for (i = 1; i <= n; i++) { //first i digits
        t = s[i - 1] - '0';
        if (t >= 1 && t <= 9){
            //last digit
            f[i] = f[i - 1];
        }
        if (i >= 2){
            //last two digits
            t = s[i - 2] + s[i - 1] - '0';
            if (t >= 10 && t <= 26){
                f[i] += f[i - 2];
            }
        }
    }
    return f[n];
}
```

### 3.4坐标型动态规划2

#### 问题：

给定a[0],...,a[n - 1],找到最长的连续子序列i, i + 1, i + 2,....,j,使得a[i] < a[i + 1] <...<a[j]或者a[i] > a[i + 1] > ... > a[j],输出长度$j - i + 1$

输入：[5,1,2,3,4];输出：4

#### 简化：

对于$a[i] > a[i + 1] > ... > a[j]$,可以讲序列倒过来，就转化为可以求连续上升子序列了，所以**只需要考虑最长连续递增子序列**。

#### 思路：

##### 最后一步：

对于最优策略，一定有最后一个元素$a[j]$

第一种情况：最优策略中最长连续上升子序列就是$\{a[j]\}$,答案为1

第二种情况：子序列长度大于1，最优策略中a[j]前一个元素肯定是$a[j - 1]$，这种情况一定是$a[j - 1] < a[j]$

那么它选中的以$a[j - 1]$结尾的连续上升子序列一定是最优的。

##### 定义状态：

设$f[j] = $以$a[j]$结尾的最长连续上升子序列的长度

转移方程：$f[j] = max\{1,f[j - 1] + 1|j > 0\quad and\quad a[j - 1] < a[j]\}$

##### 没有初始条件

##### 计算顺序

依次计算$f[0],f[1],f[2],....f[n - 1]$，结果是其中的最大值，算法时间复杂度和空间复杂度都是$O(n)$

```java
/**
 * @param A an array of Integer
 * @return an integer
 */
private void calc(int[] A, int n){
    int[] f = new int[2];
    int i, j;
    int old, now = 0;
    for (i = 0; i < n; i++) {
        old = now;
        now = 1 - now;
        //option 1
        f[now] = 1;
        //option 2
        if (i > 0 && A[i - 1] < A[i]){
            f[now] = f[old] + 1;
        }
        result = Math.max(result, f[now]);
    }
}
int result = 0;
public int longestMonotoneContinuousSubsequence(int[] A){
    int n = A.length;
    if (n == 0){
        return 0;
    }
    calc(A, n);
    int i = 0, j = n - 1, t = 0;
    while (i < j){
        t = A[i];
        A[i] = A[j];
        A[j] = t;
        ++i;
        --j;
    }
    calc(A, n);
    return result;
}
```

### 3.5坐标型动态规划3

#### 问题：

给定m行n列的网格，每个格子$(i,j)$里都是一个非负数A[i]\[j],求一个从左上角到右下角的路径，每一步只能向下或者向右走，使得路径上的格子的数字之和最小。输出最小数字和。

#### 思路：

##### 最后一步：

右下角坐标设置为(m - 1, n - 1),那么前一步一定是在(m - 2, n - 1)或者(m - 1,n - 2)。

##### 确定状态：

设置状态：从\[0, 0\]走到\[i, j\]的路径的最小数字总和为f[i]\[j]

##### 状态转移方程：

f\[i\]\[j\] = min{f\[i - 1]\[j], f\[i]\[j - 1]} + A\[i]\[j]

##### 初始条件：

f[o]\[o] = A[0]\[0]

当i = 0时和当j = 0时作为边界处理

时间复杂度和空间复杂度都是O(MN)

##### 空间优化：

根据状态转移方程，计算第$i$行时，只需要第i行和第$i - 1$行的f

**所以，只需要保存两行的f值：f[i]\[0...n - 1]和f[i - 1]\[0...n - 1]**

**对于网格上的动态规划，如果f[i]\[j]只依赖于本行的f[i]\[x]与前一行的f[i - 1]\[y],那么就可以采用滚动数组的方法压缩空间，空间复杂度为O(N)**

**如果网格行数少列数多，那么就可以逐列计算，滚动数组的长度为行数，空间复杂度为O(M)**

利用**滚动数组**实现：

- 计算f[0]\[0],...,f[0]\[n - 1],计算f[1]\[0],...,f[1]\[n - 1]
- 计算f[2]\[0...n - 1]时，把值写在f[0]\[n - 1]的数组里。

```java
public int minPathSum(int[][] A){
    if (A == null || A.length == 0|| A[0].length == 0){
        return 0;
    }
    int n = A[0].length;
    int[][] f = new int[2][n];
    int old, now = 0;
    int i, j, t1, t2;
    for (i = 0; i < A.length; i++) {
        old = now;
        //rolling array
        now = 1 - now; // row %= 2;
        for (j = 0; j < n; j++) {
            if (i == 0 && j == 0){
                f[now][j] = A[i][j];
                continue;
            }
            if (i > 0){
                t1 = f[old][j];
            }else{
                t1 = Integer.MAX_VALUE;
            }
            if (j > 0){
                t2 = f[now][j - 1];
            }else{
                t2 = Integer.MAX_VALUE;
            }
            f[now][j] += Math.min(t1, t2);
        }
    }
    return f[now][n - 1];
}
```

### 3.6坐标型动态规划4

#### 问题：

有一个$M\times N$的网格，每个格子可能是空的，可能有一个敌人，可能有一堵墙，**只能在某个空格子里面放一个炸弹**，炸弹会炸死所有同行同列的敌人，但是不能穿透墙，问最多可以炸死多少个敌人。

![EnemyBomb](D:\JAVA项目\图片\EnemyBomb.png)

输入：如图；输出：3

#### 分析：

每个炸弹可以往四个方向传播爆炸力，我们可以分析一个方向，然后举一反三。即如果在一个空地放一个炸弹，最多向上能炸死多少敌人。

#### 思路：

##### 确定状态：

我们假设有敌人或者有墙的格子也可以放置炸弹。

- 有敌人的格子：格子里的敌人被炸死，并继续向上爆炸。
- 有墙的格子：炸弹不能炸死任何敌人。

在(i, j)格放一个炸弹，它向上能够炸死的敌人数是：

- (i, j)格为空地，(i - 1, j)格向上能炸死的敌人数
- (i, j)格为敌人, (i - 1, j)格向上能炸死的敌人数 + 1
- (i, j)格为墙，能炸死的敌人数为0

##### 确定状态：

-Up[i]\[j]表示(i, j)格放一个炸弹向上能炸死的敌人数

##### 转移方程：

Up[i]\[j]:

- Up[i - 1]\[j]，如果(i, j)格是空地
- Up[i - 1]\[j] + 1, 如果(i, j)格是敌人
- 0, 如果(i, j)格是墙

##### 初始条件：

Up[0]\[j] = 0，如果(o,j)格不是敌人

Up[0]\[j] = 1,如果(0, j)是敌人

##### 四个方向：

类似计算Down[i]\[j],Left[i]\[j],Right[i]\[j]，注意计算顺序会改变

$(i, j)$如果是空地，放一个炸弹最多炸死的敌人是：Up\[i\]\[j\] + Down\[i]\[j] + Left\[i\]\[j\] + Right\[i\]\[j\]

时间复杂度和空间复杂度为$O(MN)$

```java
/**
 * @param A Given a 2D grid, each cell is either 'W','E' or '0'
 * @return
 */
public int maxKilledEnemies(char[][] A){
    if (A == null || A.length == 0 || A[0].length == 0){
        return 0;
    }
    int m = A.length;
    int n = A[0].length;
    int[][] f = new int[m][n];
    //how many enemies can be killed by a bomb put at grid(i, j)
    int[][] res = new int[m][n];
    int i, j;
    //UP
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            if (A[i][j] == 'E'){
                f[i][j] = 1;
            }
            if (i > 0){
                f[i][j] += f[i - 1][j];
            }
            res[i][j] += f[i][j];
        }
    }
    //Down
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            f[i][j] = 0;
            if (A[i][j] == 'E'){
                f[i][j] = 1;
            }
            if (i < m - 1){
                f[i][j] += f[i + 1][j];
            }
            res[i][j] += f[i][j];
        }
    }
    //LEFT
    for (i = m - 1; i >= 0; i--) {
        for (j = 0; j < n; j++) {
            f[i][j] = 0;
            if (A[i][j] == 'E'){
                f[i][j] = 1;
            }
            if (j > 0){
                f[i][j] += f[i][j - 1];
            }
            res[i][j] += f[i][j];
        }
    }
    //RIGHT
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            f[i][j] = 0;
            if (A[i][j] == 'E'){
                f[i][j] = 1;
            }
            if (j < n - 1){
                f[i][j] += f[i][j + 1];
            }
            res[i][j] += f[i][j];
        }
    }
    int result = 0;
    for (i = 0; i < m; i++) {
        for (j = n - 1; j >= 0; j--) {
            if (A[i][j] == '0') {
                result = Math.max(result, res[i][j]);
            }
        }
    }
    return result;
}
```

### 3.7序列+位操作型动态规划

#### 问题1：

给定N，要求输出0,1,...,N的每个数的二进制表示里的1的个数。

输入:5;输出$[0, 1, 1, 2, 1, 2]$

### 思路：

##### 最后一步：

要求N的二进制表示中有多少个1，在N的二进制去掉最后一位$N mod 2$，设置新的数Y = $X >> 1$

##### 确定状态：

设f[i]表示i的二进制中有多少个1.

**知识点：和位操作相关的动态规划一般用值作状态。**

##### 状态转移方程：

$f[i] = f[i >> 1] + i \% 2$

$i >> 1$也可以写成$i / 2$

时间复杂度和空间复杂度都是$O(N)$

```java
public int[] countBits(int num){
    int[] f = new int[num + 1];
    int i;
    f[0] = 0;
    for (i = 1; i <= num; i++) {
        f[i] = f[i >> 1] + i & 1;
    }
    return f;
}
```

### 4.1序列型动态规划1

#### 问题：

有一排N栋房子，每栋房子要油漆成K种颜色的一种。任何两栋相邻的房子不能漆成相同的颜色。第i栋房子染成第j种颜色的花费是cost\[i\]\[j\]。问最少要花多少钱油漆这些房子？

#### 问题分析：

需要记录油漆前i栋房子并且房子i - 1是颜色1，颜色2，。。。，颜色k 的最小花费为f[i]\[1],f[i]\[2],...,f[i]\[k]

#### 转移方程：

f[i]\[1] = min{f[i - 1\][2] + cost[i - 1]\[1], f[i - 1\][3] + cost[i - 1]\[1],...,f[i - 1\][K] + cost[i - 1]\[1]}

f[i]\[2] = min{f[i - 1\][1] + cost[i - 1]\[2], f[i - 1\][3] + cost[i - 1]\[2],...,f[i - 1\][K] + cost[i - 1]\[2]}

f[i]\[K] = min{f[i - 1\][1] + cost[i - 1]\[K], f[i - 1\][2] + cost[i - 1]\[K],...,f[i - 1\][K - 1] + cost[i - 1]\[K]}

$f[i][j] = min_{m \ne j}\{f[i - 1][m]\} + cost[i - 1][j]$

$min_{k\ne j}f[i - 1][m]$的求法

- 如果最小值是第i个元素，次小值是第j个元素
	- 如果除掉的元素不是第i个，剩下的最小值就是第i个元素。
	- 如果除掉的元素是第i个，那么剩下的最小值就是第j个元素。

如果最小值是f[i - 1]\[a],次小值是f[i - 1]\[b]，则
$$
f[i][j]=\begin{cases}f[i-1][a]+cost[i-1][j]\quad j=1,2,3,...,a-1,a+1,...,K\\f[i-1][b]+cost[i-1][a]\quad j=a\end{cases}
$$
直接计算的时间复杂度为$O(NK^2)$

```java
/**
 * param A n x k cost matrix
 * @return an integer, the minimum cost to point all houses
 */
public int minCostII(int[][] A){
    if(A == null || A.length == 0){
        return 0;
    }
    int n = A.length;
    int K = A[0].length;
    int[][] f = new int[n + 1][K];
    //min1是最小值，min2是次小值
    int min1, min2;
    //j1是最小值的纵坐标，j2是次小值的纵坐标
    int j1 = 0, j2 = 0;
    int i, j, k;
    for (i = 1; i <= n; i++){
        //calculate min1, min2
        min1 = min2 = Integer.MAX_VALUE;
        for (j = 0; j < K; j++){
            if (f[i - 1][j] < min1){
                min2 = min1;
                j2 = j1;
                min1 = f[i - 1][j];
                j1 = j;
            }else{
                if (f[i - 1][j] < min2){
                    min2 = f[i - 1][j];
                    j2 = j;
                }
            }
        }
        for (j = 0; j < K; j++) {
            if (j != j1){
                f[i][j] = f[i - 1][j1] + A[i - 1][j];
            }else{
                f[i][j] = f[i - 1][j2] + A[i - 1][j];
            }
        }
    }
    int res = Integer.MAX_VALUE;
    for (j = 0; j < K; j++) {
        res = Math.min(res, f[n][j]);
    }
    return res;
}
```

### 4.2序列型动态规划2

#### 问题：

有一排N栋房子(0~N-1)，房子i里面有A[i]个金币，一个窃贼想要选择一些房子偷金币，，但不能偷任何挨着的两家， 问窃贼最多可以偷多少金币。

#### 思路：

##### 最后一步：

窃贼的最优策略中，有可能偷或者不偷最后一栋房子N - 1

不偷房子N - 1,最优策略就是前N - 1栋房子的最优策略。

偷房子N - 1,仍然需要知道在前N - 1栋房子中最多能偷多少金币，但是，需要保证不偷第N - 2栋房子。

##### 确定状态：

设f[i]\[0]为不偷房子i - 1前提下，前i栋房子最多能偷多少金币。

设f[i]\[1]为不偷房子i - 1前提下，前i栋房子最多能偷多少金币。

f[i]\[0] = max{f[i - 1]\[0],f[i - 2]\[1]}

f[i]\[1] = f[i - 1]\[0] + A[i - 1]

##### 简化表示：

设f[i]为窃贼在前i栋房子最多能偷多少金币。

$f[i]=max\{f[i-1],f[i-2]+A[i-1]\}$

##### 初始条件：

$f[0] = 0$

$f[1] = A[0]$

$f[2] = max{A[0],A[1]}$

```java
/**
 * @param A an array of non-negative integers
 * @return The maximum amount of money you can rob tonight
 */
public long houseRobber(int[] A){
    if (A == null || A.length <= 0){
        return 0;
    }
    int n = A.length;
    long[] f = new long[3];
    f[0] = 0;
    f[1] = A[0];
    for (int i = 2; i <= n; i++) {
        f[i % 3] = Math.max(f[(i - 1) % 3], f[(i - 2) % 3] + A[i - 1]);
    }
    long temp = f[1] > f[2] ? f[1] : f[2];
    return f[0] > temp ? f[0] : temp;
}
```

### 4.2序列型动态规划3

#### 问题：

有**一圈**N栋房子(0~N-1)，房子i里面有A[i]个金币，一个窃贼想要选择一些房子偷金币，但不能偷任何挨着的两家， 问窃贼最多可以偷多少金币。

#### 思路：

如果没偷房子0,最优策略就是窃贼对于房子1 ~ N - 1的最优策略

如果没偷房子N - 1,最优策略就是窃贼对于房子0 ~ N -2的最优策略

取最大值。

### 4.3序列型动态规划4

#### 问题：

已知后面N天一支股票的每天的价格$P_0,P_1,...,P_{N-1}$,可以最多买一股卖一股，求最大利润。

#### 思路分析：

从0到N - 1枚举j，即第几天卖，时刻保存当前为止$(0\~j-1)$的最低价格$P_i$,最大的$P_j-P_i$为答案。

```java
public double buyAndSellStock(double[] A){
    if (A == null || A.length <= 0){
        return 0;
    }
    int n = A.length;
    double min = 0;
    double[] f = new double[n + 1];
    f[0] = 0;
    f[1] = 0;
    for (int i = 2; i < n; i++) {
        min = Math.min(min, A[i - 1]);
        f[i] = Math.max(f[i - 1], A[i - 1] - min);
    }
    return f[n];
}
```

### 4.4序列型动态规划5

#### 问题

已知后面N天一支股票的每天的价格$P_0,P_1,...,P_{N-1}$,可以买卖一股任意多次，但任何时候手中最多持有一股，求最大利润。

#### 思路：

最优策略是如果今天的价格比明天价格低，就今天买，明天卖。

```java
public int maxProfit(int[] A){
    int res = 0;
    for (int i = 0; i <= A.length - 1; i++) {
        if (A[i + 1] - A[i] > 0){
            res += A[i + 1] - A[i];
        }
    }
    return res;
}
```

### 4.5序列型动态规划6

#### 问题：

给定一支股票N天的价格，可以进行最多两次买和两次卖，每次买卖都是一股，不能在卖光自己手中的股票之前买入，但可以同一天卖完后买入。问最大收益。

#### 思路：

##### 最后一步

最优策略中，最后一次卖发生在第j天。枚举最后一次买发生在第几天

##### 记录状态：

不知道有没有买过，就记录下来。

![股票买卖](D:\JAVA项目\图片\股票买卖.png)

##### 确定状态：

股票收盘当天买，红利不算。

![股票买卖1](D:\JAVA项目\图片\股票买卖1.png)

![股票买卖2](D:\JAVA项目\图片\股票买卖2.png)

##### 转移方程：

$f[i][j]$:前i(第$i - 1$天)结束后，处于阶段j,最大获利。

阶段1,3,5--手中无股票的状态：$f[i][j] = max\{f[i - 1][j], f[i - 1][j - 1] +P_{i -1} + P_{i - 2}\}$​

阶段2，4--手中有股票的状态：

$f[i][j]=max\{f[i-1][j]+P_{i-1}-P_{i-2},f[i-1][j-1],f[i-1][j-2]+P_{i-1}-P_{i-2}\}$

##### 初始条件和边界情况：

刚开始处于阶段1：

- $f[0][1] = 0$
- $f[0][2]=f[0][3]=f[0][4]=f[0][5]=-\infin$

如果$j - 1 < 1$或$j - 2 < 1$或$i - 2 < 0$

答案是$max\{f[N][1],f[N][3],f[N][5]\}$​

利用滚动数组

```java
/**
 * @param A prices:Given on integer array
 * @return Maximum profit
 */
public int maxProfit(int[] A){
    int n = A.length;
    if (n == 0){
        return 0;
    }
    int[][] f = new int[n + 1][5 + 1];
    int i, j, k;
    //init
    f[0][1] = 0;
    f[0][2] = f[0][3] = f[0][4] = f[0][5] = Integer.MIN_VALUE;
    for (i = 1; i <= n; i++) {
        //1, 3, 5
        for (j = 1; j <= 5; j += 2) {
            f[i][j] = f[i - 1][j];
            //下标一定不能越界，并且不能超过整数的表数范围
            if (j > 1 && i > 1 && f[i - 1][j -1] != Integer.MIN_VALUE){
                f[i][j] = Math.max(f[i - 1][j - 1] + A[i - 1] - A[i - 2], f[i][j]);
            }
        }
        //2, 4
        for (j = 2; j <= 5; j += 2) {
            f[i][j] = f[i - 1][j - 1];
            if (i > 1 && f[i - 1][j] != Integer.MIN_VALUE){
                f[i][j] = Math.max(f[i][j], f[i - 1][j] + A[i - 1] - A[i - 2]);
            }
            if (j > 2 && i > 1 && f[i - 1][j -2] != Integer.MIN_VALUE){
                f[i][j] = Math.max(f[i][j], f[i - 1][j - 2] + A[i - 1] - A[ i - 2]);
            }
        }
    }
    return Math.max(Math.max(f[n][1], f[n][3]), f[n][5]);
}
```

### 4.6序列型动态规划7

#### 问题：

给定一支股票N天的价格，可以进行**最多K次买和K次卖**，每次买卖都是一股，不能在卖光自己手中的股票之前买入，但可以同一天卖完后买入。问最大收益。

#### 思路：

首先如果K很大,$K > \frac{N}{2}$，题目就可以化简成序列型动态规划5,每次买入当且仅当价格比下一天低。

##### 记录阶段：

![股票买卖4](D:\JAVA项目\图片\股票买卖4.png)

##### 转移方程：

$f[i][j]$:前i(第$i - 1$天)结束后，处于阶段j,最大获利。

阶段$1,3,5,...,2K+1$--手中无股票的状态：$f[i][j] = max\{f[i - 1][j], f[i - 1][j - 1] +P_{i -1} + P_{i - 2}\}$​

阶段$2,4,...,2K$--手中有股票的状态：

$f[i][j]=max\{f[i-1][j]+P_{i-1}-P_{i-2},f[i-1][j-1],f[i-1][j-2]+P_{i-1}-P_{i-2}\}$

##### 初始条件和边界情况：

刚开始处于阶段1：

- $f[0][1] = 0$
- $f[0][2]=f[0][3]=f[0][4]=f[0][5]=...=f[0][2K+1]\infin$​

如果$j - 1 < 1$或$j - 2 < 1$或$i - 2 < 0$

答案是$max\{f[N][1],f[N][3],f[N][5],...,f[N][2K+1]\}$​

时间复杂度为$O(NK)$，空间复杂度为$O(NK)$,优化后可以是$O(K)$

```java
public int maxProfit2(int K, int[] A){
    int n = A.length;
    if (n == 0){
        return 0;
    }
    int[][] f = new int[2][2 * K + 1 + 1];
    int i, j, k;
    int now, before;
    //equivalent to any timeII
    if (K > n){
        int result = 0;
        for (i = 0; i < n - 1; i++) {
            result += Math.max(A[i + 1] - A[i], 0);
        }
        return result;
    }
    //init
    f[0][1] = 0;
    for (k = 2; k < K; k++) {
        f[0][k] = Integer.MIN_VALUE;
    }
    for (i = 1; i <= n; i++) {
        now = i % 2;
        before = (i + 1) % 2;
        //1, 3, 5
        for (j = 1; j <= 2 * K + 1; j += 2) {
            f[now][j] = f[before][j];
            //下标一定不能越界，并且不能超过整数的表数范围
            if (j > 1 && f[before][j -1] != Integer.MIN_VALUE){
                f[now][j] = Math.max(f[before][j - 1] + A[i - 1] - A[i - 2], f[now][j]);
            }
        }
        //2, 4
        for (j = 2; j <= 2 * K + 1; j += 2) {
            f[now][j] = f[before][j - 1];
            if (f[before][j] != Integer.MIN_VALUE){
                f[now][j] = Math.max(f[now][j], f[before][j] + A[i - 1] - A[i - 2]);
            }
            if (j > 2 && f[before][j -2] != Integer.MIN_VALUE){
                f[now][j] = Math.max(f[now][j], f[before][j - 2] + A[i - 1] - A[ i - 2]);
            }
        }
    }
    int res = Integer.MIN_VALUE;
    for (i = 1; i < 2 * K + 1; i += 2) {
        res = Math.max(res, f[0][i]);
        res = Math.max(res, f[1][i])
    }
    return res;
}
```

### 5.1最长序列型动态规划1

#### 问题

给定$a[0],...,a[n - 1]$,找到最长子序列$0< i_1< i_2<...<i_k<n$​,使得$a[i_1]<a[i_2]<...<a[i_K]$​,输出$K$​。

例子：​​

输入：$[4,2,4,5,3,7]$

输出：$4$

#### 思路：

##### 最后一步：

对于最优策略，一定有最后的元素$a[j]$​

- 最优策略中最长上升子序列就是${a[j]}$,答案是$1$

- 子序列长度大于1，那么最优策略中$a[j]$​前一个元素是$a[i]$​,并且$a[i]<a[j]$​

因为不确定最优策略中$a[j]$前一个元素$a[i]$是哪个，需要枚举每个$i$,求以$a[i]$结尾的最长上升序列。

##### 确定状态：

设f[i]表示以a[i]为结尾的最长上升子序列的长度。

##### 状态转移方程：

$$
f[j]=max\{1,f[i]+1|i<j\quad and\quad a[i]<a[j]\}
$$

##### 初始条件：

空，答案是$max\{f[0],f[1],f[2],...,f[n-1]\}$​

时间复杂度为$O(n^2)$,空间复杂度为$O(n)$

```java
/**
 * @param nums:The integer array
 * @return: The length of LTS
 */
public int LTS(int[] nums){
    if (nums == null || nums.length <= 0){
        return 0;
    }
    int n = nums.length;
    int[] f = new int[n];
    int i, j;
    int res = 0;
    for (i = 0; i < n; i++) {
        f[i] = 1;
        for (j = 0; j < i; j++) {
            if (nums[i] > nums[j]){
                f[i] = Math.min(f[i], f[j] + 1);
            }
        }
        res = Math.max(res, f[i]);
    }
    return res;
}
```

### 5.2最长序列型动态规划2

#### 问题：

给定N个信封的长度和宽度，如果一个信封的长和宽都分别小于另一个信封的长和宽，则这个信封可以放入另一个信封。问最多可以嵌套多少个信封。

例子：

输入:$[[5,4],[6,4],[6,7],[2,3]]$

输出：$3([2,3]=>[5,4]=>[6,7])$

#### 思路：

二维转一维考虑。

将所有信封按照长度一维进行升序排序:$E_0,E_1,...,E_{n-1}$

如果信封$E_i$能够放入$E_j$​里，就一定有$i<j$,排序后，如果一个信封$E_j$是最外层的信封，那么它里面的第一层信封$E_i$一定满足$i<j$

##### 最后一步：

设最优策略中最后一个信封，即最外层的信封，是$E_i$​,考虑次外层信封是哪个，一定是某个$E_j,j<i$​

##### 确定状态：

设f[i]表示以$E_i$​为最外层信封时最多的嵌套层数。

##### 转移方程:

$f[i]=max\{1,f[j]+1|E_j能够放在E_i里，i > j\}$

```java
/**
 * @param A envelops a number of envelopes with widths and heights
 * @return the maximum number of envelopes
 */
public int maxEnvelopes(int[][] A){
    if (A == null || A.length <= 0){
        return 0;
    }
    Arrays.sort(A, (o1, o2) -> {
        if (o1[0] == o2[0]){
            return Integer.compare(o1[1],o2[2]);
        }else{
            return Integer.compare(o1[0], o2[0]);
        }
    });
    int n = A.length;
    int i, j, res = 0;
    int[] f = new int[n];
    for (i = 0; i < n; i++) {
        f[i] = 1;
        for (j = 0; j < i; j++) {
            if (A[j][0] < A[i][0] && A[j][1] < A[i][2]){
                f[i] = Math.max(f[i], f[j] + 1);
            }
        }
        res = Math.max(res, f[i]);
    }
    return res;
}
```

### 5.3划分型动态规划1

#### 问题：

给定一个正整数n，问最少可以将n分为多少个完全平方数的和

#### 思路：

##### 确定状态：

关注最优策略中最后一个完全平方数$j^2$,最优策略中$n-j^2$​一定被划分为最少的完全平方数之和。

状态：$f[i]$​表示i最多可以被划分为多少个完全平方数之和。

##### 状态转移方程:

$$
f[i]=min_{1\le j^2\le i}\{f[i - j^2]+1\}
$$

##### 初始条件：

$f[0] = 0$

时间复杂度为$O(n^\frac{3}{2})$

```java
/**
 * @param n a positive integer
 * @return an integer
 */
public int numSquares(int n){
    int[] f = new int[n + 1];
    f[0] = 0;
    for (int i = 1; i <= n; i++) {
        f[i] = Integer.MAX_VALUE;
        for (int j = 1; j <= (int)Math.sqrt(i); j++) {
            f[i] = Math.min(f[i], f[i - j * j] + 1);
        }
    }
    return f[n];
}
```

### 5.4划分型动态规划2

#### 问题：

给定一个字符串S[0..N-1],要求将这个字符串划分成若干段，每一段都是一个回文串，求最少划分多少次。

#### 思路：

##### 确定状态

关注最优策略中最后一段回文串，设为$S[j..N-1]$

需要知道S前j个字符$[0..j-1]$最少可以划分成几个回文串。

##### 状态转移方程：

设f[i]为S前i个字符S[0..i-1]最少可以划分成多少个回文串。
$$
f[i]=min_{j=0,..,i-1}\{f[j]+1|S[j..i-1]是回文串\}
$$

##### 生成回文串：

从中间开始，向量表扩展，每次左右两端加上同样的字符。

记录回文串：isPalin[i]\[j]表示S[i]\[j]是否是回文串。

##### 初始条件：

空串可以被分成0个回文串，f[0]=0

答案是f[N]-1

```java
public int minCut(String ss){
    char[] s = ss.toCharArray();
    int n = s.length;
    if (n == 0){
        return 0;
    }
    boolean[][] isPalin = new boolean[n][n];
    int i, j, t;
    for (t = 0; t < n; t++) {
        //odd-length
        i = j = t;
        while (i >= 0 && j < n && s[i] == s[j]){
            isPalin[i][j] = true;
            --i;
            ++j;
        }
        //even-length
        i = t;
        j = t + 1;
        while (i >= 0 && j < n && s[i] == s[j]){
            isPalin[i][j] = true;
            --i;
            ++j;
        }
    }
    int[] f = new int[n + 1];
    f[0] = 0;
    for (i = 1; i <= n; i++) {
        f[i] = Integer.MAX_VALUE;
        for (j = 0; j < i; j++) {
            if (isPalin[j][i - 1]){
                f[i] = Math.min(f[i], f[j] + 1);
            }
        }
    }
    return f[n] - 1;
}
```

### 5.5划分型动态规划3

#### 问题：

有N本书需要被抄写，第i本书有$A[i]$页，$i=0,1,..,N-1$​,有K个抄写员，每个抄写员可以抄写连续的若干本书​,一分钟一页，最少需要多少时间抄写所有书。

#### 思路：

需要找到一种分段方式，分成不超过K段，使得所有段的数字之和的最大值最小

##### 确定状态：

最后一个抄写员抄写了第j本到第N - 1本书，需要知道前面K- 1个人最少需要多少时间抄写完前j本书。

状态：f[k]\[i]为k个抄写员最少需要多少时间抄完前i本书。

- 因为需要记录是第几个抄写员

##### 状态转移方程：

$$
f[k][i]=min_{j=0,..,i}\{max\{f[k-1][j],A[j]+...+A[i-1]\}\}
$$

##### 初始条件：

如果$K>N$，直接赋值$K = N$

$f[0][0] = 0, f[0][1] = f[0][2] = ... = f[0][N] =$​ 正无穷

$f[k][0]  = 0$​

时间复杂度是$O(N^2K)$，空间复杂度$O(NK)$,​

```java
public int copyBooks(int[] A, int K){
    int n = A.length;
    if (n == 0){
        return 0;
    }
    if (K > n){
        K = n;
    }
    int[][] f = new int[K + 1][n + 1];
    int i, j, k;
    f[0][0] = 0;
    for (j = 1; j <= n; j++) {
        f[0][j] = Integer.MAX_VALUE;
    }
    int sum = 0;
    for (k = 1; k <= K; k++) {
        f[k][0] = 0;
        for (i = 0; i < 1; i++) {
            f[k][i] = Integer.MAX_VALUE;
            for (j = i; j >= 0; j--) {
                f[k][i] = Math.min(f[k][i], Math.min(sum, f[k - 1][j]));
                sum += A[j - 1];
            }
        }
    }
    return f[K][n];
}
```

### 6.1博弈型动态规划1

#### 问题：

有一排N个石子，ALice,Bob两人轮流取石子，每次一个人可以从最右边取走1个或2个石子，取走最后石子的人取胜，问先手Alice是否必胜。

#### 思路：

##### 确定状态：

博弈动态规划**通常从第一步分析，而不是最后一步**。因为局面越来越简单，石子数越来越少。

面对N个石子，先手Alice第一步可以拿1个或2个石子，后手Bob面对N- 1石子或者N-2个石子。

后手Bob面对N-1石子，这和一开始Bob是先手，N-1情况的情况。

##### 必胜和必败的概念：

如果取完1个或2个石子后，能让剩下的局面先手必败，则当前先手必胜。

如果不管怎么走，剩下的局面都是对方必胜，则当前先手必败。

##### 转移方程：

f[i] = f[i - 1] == false OR f[i - 2] == false;

##### 初始条件：

f[0] = false;

```java
//DP解法
public boolean firstWillWin1(int n){
    if (n == 0){
        return false;
    }
    if (n <= 2){
        return true;
    }
    boolean[] f = new boolean[n + 1];
    f[0] = false;
    f[1] = f[2] = true;
    for (int i = 3; i < n; i++) {
        f[i] = (f[i - 1] == false) || (f[i - 2] == false);
    }
    return f[n];
} 
//数学解法
public boolean firstWillWin2(int n){
    return n % 3 != 0;
}
```

### 6.2背包问题1

#### 问题：

给定N个物品，重量分别为正整数$A_0,A_1,...,A_{N-1}$​,一个背包最大承重为正整数M，最多能带走多重物品。

#### 思路：

**背包问题中，数组大小和总承重有关。**

##### 确定状态：

f[i]\[w]表示能否用**前i个物品**拼出重量w

f[i]\[w] = f[i - 1]\[w] OR f[i - 1]\[w - $A_{i-1}$​]

##### 初始条件：

f[0]\[0] = true

f[0]\[1...M] = false

时间复杂度为$O(MN)$

```java
public int backPack(int m, int[] A){
    int n = A.length;
    if (n == 0){
        return 0;
    }
    boolean[][] f = new boolean[n + 1][m + 1];
    f[0][0] = true;
    int i, j;
    for (j = 1; j <= m; j++) {
        f[0][j] = false;
    }
    for (i = 1; i <= n; i++) {
        for (j = 0; j <= m; j++) {
            f[i][j] = f[i - 1][j];
            if (j > A[i - 1]) {
                f[i][j] = f[i][j] || f[i - 1][j - A[i - 1]];
            }
        }
    }
    for (j = m; j >= 0; j--) {
        if (f[n][j]){
            return j;
        }
    }
    return 0;
}
```

### 6.3背包问题2

#### 问题：

给定N个正整数:$A_0,A_1,...,A_{N-1}$,一个正整数Target，求有多少种组合加起来是Target，每个$A_i$只能用一次。

#### 思路：

确定状态：

状态：设f[i]\[w]=用前i个物品有多少种方式拼出重量w。

f[i]\[w] = f[i - 1]\[w] + f[i - 1]\[w - $A_{i-1}$]

答案是$f[N][Target]$

##### 空间优化：

可以只开一个数组，然后按照$f[i][target],...,f[i][0]$的顺序更新。

```java
public int backPack1(int[] A, int T){
    int i, j;
    int n = A.length;
    if (n == 0){
        return 0;
    }
    int[] f = new int[T + 1];
    f[0] = 1;
    for (i = 1; i <= n; i++) {
        for (j = T; j >= 0; j--) {
            if (i >= A[i - 1]){
                f[j] += f[j - A[i - 1]];
            }
        }
    }
    return f[T];
}
```

### 7.1序列动态规划1

#### 问题：

给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。

在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当$0 <= i < A.length $时 C[i] = A[i]，且当 i >= 0 时 $C[i+A.length] = C[i]$​

此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 C[i], C[i+1], ..., C[j]，不存在 i <= k1, k2 <= j 其中 k1 % A.length = k2 % A.length）

##### 示例 1：

输入：[1,-2,3,-2]
输出：3
解释：从子数组 [3] 得到最大和 3

##### 示例 2：

输入：[5,-3,5]
输出：10
解释：从子数组 [5,5] 得到最大和 5 + 5 = 10

##### 示例 3：

输入：[3,-1,2,-1]
输出：4
解释：从子数组 [2,-1,3] 得到最大和 2 + (-1) + 3 = 4

##### 示例 4：

输入：[3,-2,2,-3]
输出：3
解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3
示例 5：

输入：[-2,-3,-1]
输出：-1
解释：从子数组 [-1] 得到最大和 -1

##### 提示：

-30000 <= A[i] <= 30000
1 <= A.length <= 30000

#### 7.1.1**$Kadane$ 算法**

对于一个给定数组 A，$Kadane $算法可以用来找到 A 的最大子段和。这里，我们只考虑非空子段。

$Kadane $算法基于动态规划。令 $dp[j] $为以 $A[j] $结尾的最大子段和。也就是，

$$
dp[j]=max{A[i]+A[i+1]+...+A[j]}
$$
那么，以 j+1 j结尾的子段（例如 $A[i], A[i+1] + ... + A[j+1]$）最大化了 $A[i] + ... + A[j] $的和，当这个子段非空那么就等于 dp[j] 否则就等于 0。所以，有以下递推式：

$$
dp[j+1]=A[j+1]+max(dp[j],0)
$$



