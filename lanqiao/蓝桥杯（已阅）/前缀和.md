# 前缀和和差分

什么是前缀和？前缀和是一个数组的某项下标之前(包括此项元素)的所有数组元素的和。

设 `b[]` 为前缀和数组，`a[]` 为原数组，根据这句话可以得到前缀和的定义式和递推式：

|            |                            定义式                            |                            递推式                            |
| :--------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 一维前缀和 | ![b[i] = \sum_{j=0}^{i}a[j]](https://math.jianshu.com/math?formula=b%5Bi%5D%20%3D%20%5Csum_%7Bj%3D0%7D%5E%7Bi%7Da%5Bj%5D) | ![b[i] = b[i-1] + a[i]](https://math.jianshu.com/math?formula=b%5Bi%5D%20%3D%20b%5Bi-1%5D%20%2B%20a%5Bi%5D) |
| 二维前缀和 | ![b[x][y] = \sum_{i=0}^{x}\sum_{j=0}^{y}a[i][j]](https://math.jianshu.com/math?formula=b%5Bx%5D%5By%5D%20%3D%20%5Csum_%7Bi%3D0%7D%5E%7Bx%7D%5Csum_%7Bj%3D0%7D%5E%7By%7Da%5Bi%5D%5Bj%5D) | ![b[x][y] = b[x-1][y] + b[x][y-1] - b[x-1][y-1] + b[x][y]](https://math.jianshu.com/math?formula=b%5Bx%5D%5By%5D%20%3D%20b%5Bx-1%5D%5By%5D%20%2B%20b%5Bx%5D%5By-1%5D%20-%20b%5Bx-1%5D%5By-1%5D%20%2B%20b%5Bx%5D%5By%5D) |

### ==P2671 [NOIP2015 普及组] 求和==

根据题目，我们可以设有三个下标，他们分别是$x,y,z$，要满足$x<y<z$且$y-x=z-y$

由此，我们得到$2y=z+x$，可知$z+x$必须是一个偶数，即$z,x$同为奇数或同为偶数。

用分组思想，把每个颜色分为一组，再在每个颜色中按奇偶分组，所以一共有$2m$组

设一个分组里有$k$个数，这个分组中的下标分别是$x[1],x[2],\dots, x[k]$，数分别是$y[1],y[2],\dots,y[k]$
$$
\begin{split}
ans&=\sum_{i=1}^{k-1}\sum_{j=i+1}^{k}(x_i+x_j)\times (y_i+y_j)\\
&=\sum_{i=1}^kx_i\times((k-2)\times y_i+\sum_{j=1}^k y_j)
\end{split}
$$
然后事先将$\sum_{j=1}^k y_j$求出，用时调用就行了。

```C++
#include <iostream>
#define MAXN 100005
#define MOD 10007
using namespace std;
int n, m, ans;
// S[i][j]表示颜色为0，编号为 偶数的个数
int Num[MAXN], Col[MAXN], S[MAXN][2], Sum[MAXN][2]; 
int main() {
    scanf("%d%d", &n, &m);
    register int i;
    for(i = 1; i <= n; ++i) scanf("%d", &Num[i]);
    for(i = 1; i <= n; ++i){
        scanf("%d", &Col[i]);
        ++S[Col[i]][i % 2];
        Sum[Col[i]][i % 2] = (Sum[Col[i]][i % 2] + Num[i]) % MOD;
    }
    for(i = 1; i <= n; ++i){
        ans = (ans + i * ((S[Col[i]][i % 2] - 2) * Num[i] % MOD + Sum[Col[i]][i % 2])) % MOD;
    }
    printf("%d", ans);
    system("pause");
    return 0;
}
```



### ==P1115 最大子段和==

假设$dp[i]$表示以$a_i$结尾的连续字段和的最大值。
$$
dp[i]=max(dp[i-1]+a[i],a[i])
$$

```C++
#include <iostream>
#define MAXN 200010
#define MINN -1e12
#define ll long long 
using namespace std;
int n;
ll res = MINN, pre;
ll max(ll a, ll b) {return a > b ? a : b;}

int main() {
    scanf("%d", &n);
    for(register int i = 1; i <= n; ++i) {
        int temp; scanf("%d", &temp);
        pre = max(temp, temp + pre);
        res = max(res, pre);
    }
    printf("%lld", res);
    system("pause");
    return 0;
}
```



### ==P3397 地毯==

#### 暴力解法

```C++
#include <iostream>
using namespace std;
int n, m, f[1005][1005];
int main() {
    scanf("%d%d", &n, &m);
    register int x1, y1, x2, y2, i, j;
    while(m--){
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        for(i = x1; i <= x2; ++i)
            for(j = y1; j <= y2; ++j) ++f[i][j];
    }
    for(i = 1; i <= n; ++i){
        for(j = 1; j <= n; ++j) printf("%d ", f[i][j]);
        printf("\n");
    }
    system("pause");
    return 0;
}
```

#### 差分

假设我们现在要给[2,5]这个区间加一。原来的序列是：

```
0 0 0 0 0 0 0 0
```

这时候我们在2上面打 +1 标记， 6 上面打 -1 标记。那么现在的序列是：

```
0 +1 0 0 0 -1 0
```

有什么用呢？从左往右扫描这个数组，记录当前经过的标签之和。这个和就是对应那个数的答案。

这样，对于每个区间加操作，只需要$O(1) $的时间打上标记。

现在把问题拓展到二维。假设我们要覆盖[(2,2),(5,5)] ，那么标记便可以这样打：

```cpp
0 0 0 0 0 0
0 +1 0 0 0 -1
0 +1 0 0 0 -1
0 +1 0 0 0 -1
0 +1 0 0 0 -1
0 0 0 0 0 0
```

即在每一行都按照一维的方式来操作

```cpp
int sum=0,i,j;
   for(i=1;i<=n+1;i++)
      for(j=1;j<=n+1;j++)
         sum+=flag[i][j],real[i][j]=sum;
```

之后 real 数组里就存了最后的矩阵。输出即可。

时间复杂度为$O(mn+n^2)$

```C++
#include <iostream>
using namespace std;
int n, m, f[1005][1005];
int main() {
    scanf("%d%d", &n, &m);
    register int x1, y1, x2, y2, i, j;
    while(m--){
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        for(i = x1; i <= x2; ++i){ // 对每一行进行差分
            ++f[i][y1], --f[i][y2 + 1]; // 差分
        }
    }
    for(i = 1; i <= n; ++i){
        for(j = 1; j <= n; ++j) {
            f[i][j] += f[i][j - 1]; // B[I]+A[I-1]=A[I]
            printf("%d ", f[i][j]);
        }
        printf("\n");
    }
    system("pause");
    return 0;
}
```



### P1719 最大加权矩形

```C++
#include <iostream>
using namespace std;
int n, dp[125][125];
int main() {
    scanf("%d", &n);
    register int i, j, k, t, tmp;
    for(i = 1; i <= n; ++i){
        for(j = 1; j <= n; ++j){
            scanf("%d", &tmp);
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + tmp;
        }
    }
    int res = -99999999;
    for(i = 1; i <= n; ++i)
        for(j = 1; j <= n; ++j)
            for(k = i; k <= n; ++k)
                for(t = j; t <= n; ++t)
                    res = max(res, dp[k][t] + dp[i - 1][j - 1] - dp[k][j - 1] - dp[i - 1][t]);
    printf("%d", res);
    system("pause");
    return 0;
}

```



### P2004 领地选择

```C++
#include <iostream>
using namespace std;
int N, M, C, f[1005][1005];
int main() {
    scanf("%d%d%d", &N, &M, &C);
    register int i, j, k, t;
    for(i = 1; i <= N; ++i)
        for(j = 1; j <= M; ++j) {
            scanf("%d", &k);
            f[i][j] = f[i - 1][j] + f[i][j - 1] - f[i - 1][j - 1] + k;
        }
    int res = -0x7fffffff;
    pair<int, int> ans;
    for(i = 1; i <= N - C + 1; ++i){
        for(j = 1; j <= M - C + 1; ++j){
            if(f[i+C-1][j+C-1]-f[i-1][j+C-1]-f[i+C-1][j-1]+f[i-1][j-1] > res){
                res = f[i+C-1][j+C-1]-f[i-1][j+C-1]-f[i+C-1][j-1]+f[i-1][j-1];
                ans = make_pair(i, j);
            }
        }
    }
    printf("%d %d", ans.first, ans.second);
    system("pause");
    return 0;
}
```

