## 算法模板

## 图论算法模板

### 1.单源最短路问题

##### ==1.堆优化的Dijistra算法==

- 时间复杂度为$O(|E|\log|V|)$

```C++
//前式链向星
#include <iostream>
#include <string.h>
#include <queue>
using namespace std;
typedef pair<int, int> P;   // 前一个是距离，后一个是节点编号
const int MAX_N = 1000;
const int MAX_M = 2000;
const int INF = 0x3f3f3f3f;

struct  edge{
    int next;//下一条边的编号
    int w;//权重
    int v;//终点
}E[MAX_M << 1];
bool vis[MAX_N];
int dis[MAX_N], h[MAX_N];
int cnt, n, m;//编号：随着插入变化

void init(){
    memset(vis, false, sizeof vis);
    for(int i = 1; i <= n; i++) dis[i] = INF;
}

void insert(int u, int v, int w){
    E[++cnt].v = v;
    E[cnt].w = w;
    E[cnt].next = h[u];
    h[u] = cnt;
}

void dijkstra(int s){
    init();
    dis[s] = 0;
    priority_queue<P, vector<P>, greater<P> > que; // 升序排列
    que.push(P(0, s));

    while(!que.empty()){
        P p = que.top(); que.pop();
        int v = p.second;
        if(vis[v]) continue;
        vis[v] = true;
        for(int e = h[v]; e; e = E[e].next){
            int u = E[e].v, w = E[e].w;
            if(!vis[u] && dis[v] + w < dis[u]){
                dis[u] = dis[v] + w;
                que.push(P(dis[u], u));
            }
        }
    }
}

int main(){
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= m; i++){
        int u, v, w; scanf("%d%d%d", &u, &v, &w);
        // 无向图需要加入两条边
        insert(u, v, w);
        insert(v, u, w);
    }
    dijkstra(1);    // 起始点设置为1
    for(int i = 1; i <= n; i++){
        printf("%d ", dis[i]);
    }
    system("pause");
    return 0;
}
```

##### 2.Bellman-ford算法

- 时间复杂度为$O(|V|\times|E|)$
- 该算法只在有负边时使用

```C++
#include <iostream>
using namespace std;
typedef pair<int, int> P;   // 前一个是距离，后一个是节点编号
const int MAX_N = 1000;
const int MAX_M = 2000;
const int INF = 0x3f3f3f3f;

struct edge{
    int u, v, w;
} es[MAX_M << 1];

int dis[MAX_N], n, m, cnt = 1;

void Bellman(int s){
    for(int i = 1; i <= n; i++) dis[i] = INF;   // 初始化很重要
    dis[s] = 0;
    while(1){
        bool update = false;
        for(int i = 1; i < cnt; i++){
            edge e = es[i];
            if(dis[e.u] != INF && dis[e.u] + e.w < dis[e.v]){
                dis[e.v] = dis[e.u] + e.w;
                update = true;
            }
        }
        if(!update) break;
    }
}

int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= m; i++){
        int u, v, w; scanf("%d%d%d", &u, &v, &w);
        es[cnt].u = u; es[cnt].v = v; es[cnt].w = w;
        cnt++;
        es[cnt].v = u; es[cnt].u = v; es[cnt].w = w;
        cnt++;
    }
    Bellman(1);
    // for(int i = 1; i <= n; i++) {
    //    printf("%d ", dis[i]);
    // }
    system("pause");
    return 0;
}
```

- Bellman-Ford算法判断负圈

```C++
bool find_negative_loop(){
    for(int i = 1; i <= n; i++) dis[i] = 0;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j < cnt; j++){
            edge e = es[j];
            if(dis[e.v] > dis[e.u] + e.w){
                dis[e.v] = dis[e.u] + e.w;
                // 如果第n次任然更新，则存在负圈。
                if(i == n) return true;
            }
        }
    }
}
```

##### 3.Floyd算法

```C++

```



### 2.网络流问题

#### 1.最大流算法

##### Ford-Fulkerson算法(不推荐使用)

- 时间复杂度为$O(|E||f|)$，其中$f$是最后最大流问题的解，即最大流的流量。
- 首先对图中所有顶点对的流大小清零，此时的网络流大小也为0。在每次迭代中，通过寻找一条“增广路径”(augument path)来增加流的值。增广路径可以看作是源点s到汇点t的一条路径，并且沿着这条路径可以增加更多的流。迭代直至无法再找到增广路径位置，此时必然从源点到汇点的所有路径中都至少有一条边的满边（即边的流的大小等于边的容量大小）。

```C++
#include <iostream>
#include <vector>
#include <string.h>
using namespace std;
const int MAX_N = 3000;
const int MAX_M = 6000;
const int INF = 0x7fffffff;
struct edge{
    int to;     // 终点
    int cap;    // 容量
    int rev;    // 反向边
};
vector<edge> G[MAX_N];  // 图的邻接表表示
bool used[MAX_N];       // dfs中用到的访问标记

// 向图中添加一条从s到t容量为cap的边
void add_edge(int from, int to, int cap){
    G[from].push_back(edge{to, cap, (int)G[to].size()});
    G[to].push_back(edge{from, 0, (int)G[from].size() - 1});
}

// 通过DFS寻找增广路
int dfs(int v, int t, int f){
    if(v == t) return f;
    used[v] = true;
    for(int i = 0; i < G[v].size(); i++){
        edge &e = G[v][i];
        if(!used[e.to] && e.cap > 0){
            int d = dfs(e.to, t, min(f, e.cap));
            if(d > 0){
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
}

// 求解求s到t的最大流
int max_flow(int s, int t) {
    int flow = 0;
    while(1){
        memset(used, 0, sizeof used);
        int f = dfs(s, t, INF);
        if(f == 0) return flow;
        flow += f;
    }
}

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= m; i++){
        int u, v, c; scanf("%d%d%d", &u, &v, &c);
        add_edge(u, v, c);
    }
    printf("%d\n", max_flow(1, 5));
    system("pause");
    return 0;
}
```

##### Edmonds-Karp算法(不推荐使用)

- 时间复杂度为$O(|V||E|^2)$
- 基础的最大流算法，每次BFS寻找最短路进行增广，找出一条残余路径就可以了。然后对残余网络进行增广，不要忘记正向增广，相当于负向减少，也要在图中保存记录。最后求一个割集来得到最大流。

```C++
#include <iostream>
#include <string.h>
#include <queue>
using namespace std;
int m, n, cap[205][205], pre[205], flow[205][205];
bool vis[205];
bool bfs(int s, int t) {
    memset(pre, -1, sizeof(pre));
    memset(vis, false, sizeof(vis));
    queue<int> q;
    
    q.push(s);
    vis[s] = true;
    while(!q.empty()) {
        int now = q.front();
        q.pop();
        for(int i = 1;i <= n; i++) {
            if(vis[i] == false && i != now && cap[now][i] - flow[now][i] > 0) {
                q.push(i);
                pre[i] = now;
                vis[i] = true;
                if(i == t) return true;	//找到了 
            }
        }
    }
    return false;
}
int max_flow(int s, int t) {
    int ans = 0;
 
    while(bfs(s, t)) {
        int delta = 0x7fffffff;
        for(int i = t; i != s; i = pre[i]) {
            delta = min(delta, cap[pre[i]][i] - flow[pre[i]][i]);
        }
        for(int i = t; i != s; i = pre[i]) {
            flow[pre[i]][i] += delta;
            flow[i][pre[i]] -= delta;
        }
        ans += delta;	//这是一个结论 记住就行 
    }
    return ans;
}
int main() {
    scanf("%d%d", &m, &n);
    for(int i = 1;i <= m;i++) {
        int x,y,rl;
        cin>> x >> y>> rl;
        //必须是+= 超级阴人.....没有看到一处到另一处不止一条排水沟 
        cap[x][y] += rl;
        cap[y][x] += rl;
        flow[x][y] = 0;
        flow[y][x] += rl;
    }
    cout << max_flow(1,n);
    return 0;
}
```

##### Dinic算法(推荐使用)

- 时间复杂度为$O(|V|^2|E|)$
- 网络流最大流的优化算法之一，每一步对原图进行分层，然后用DFS求增广路。

```C++
#include <iostream>
#include <queue>
#include <string.h>
using namespace std;
int s,t,n,m,tot,first[10005],step[10005];
const int INF = 0x7fffffff;
struct Edge {
    int to;
    int next;
    int flow;
    int cap;
    //很多人没有加上flow这个元素 用一个cap就代替了delta 然而我不喜欢 我的写法好理解一点 
}edge[400005];
void addedge(int x,int y,int flow,int cap) {
    edge[tot].to=y;
    edge[tot].flow=flow;
    edge[tot].cap=cap;
    edge[tot].next=first[x];
    first[x] = tot++;
    //注意区分tot在前和后的区别....详见我的那篇记录易错点的博客 
}
bool bfs(int s,int t) {
    memset(step,-1,sizeof(step));
    step[s]=1;
    queue<int> q;
    q.push(s);
    
    while(!q.empty())
    {
        int now=q.front();
        q.pop();
        for(int u = first[now]; ~u; u=edge[u].next)
        {
            int vis=edge[u].to;
            if(edge[u].cap-edge[u].flow>0&&step[vis]==-1)//这里有一个代替vis数组的感觉
            {
                step[vis]=step[now]+1;
                q.push(vis);
            } 
        }
    } 
    return step[t]!=-1;
} 
int dfs(int s,int t,int flow)	//flow是原点到当前点的剩余流量 
{
    if(s==t)	return flow;	 
    int addflow=0;
    for(int i=first[s];i!=-1&&addflow<=flow;i=edge[i].next) {
        int vis=edge[i].to;
        if(step[vis]==step[s]+1&&edge[i].cap-edge[i].flow>0) {
        //这这条路径上流量用了，下条路径的可以流过去的就少了(一个点的几个边) 相当于是防止这个流量用完了
            int delta=dfs(vis,t,min(flow-addflow,edge[i].cap-edge[i].flow));
            addflow+=delta; 
            edge[i].flow+=delta;
            edge[i^1].flow-=delta;	//2^1=3,3^1=2 求反向边编号 
        } 
    }
    return addflow;
}
int max_flow(int s,int t) {
    int ans=0;
    while(bfs(s,t)) ans+=dfs(s,t,INF);
    return ans;
}
int main() {
    cin>> n>> m >> s>> t;   // s是源点，t是汇点
    memset(first,-1,sizeof(first));
	for(int i=1;i<=m;i++)	edge[i].next=-1;
    for(int i=1;i<=m;i++) {
        int x,y,rl;
        cin>>x>>y>>rl;
        addedge(x,y,0,rl);
        addedge(y,x,rl,rl);
    }
    cout << max_flow(s,t);
    system("pause");
    return 0;
}
```

##### ISAP算法

```C++

```

##### HLPP预留推进算法

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 2e3, INF = 2147483647;
struct E {
    int to, flow, back;
};
vector<E> edge[N];
int n, m, s, t, d[N], l[N], v[N], num[N];
priority_queue<pair<int, int>> Q;
inline void push(int x) {
    Q.push(make_pair(d[x], x));
}
inline int hlpp(int s, int t) {
    d[s] = n;
    l[s] = INF;
    v[s] = 1;
    push(s);
    num[0] = n - 1;

    while (!Q.empty()) {
        int x = Q.top().second;
        Q.pop();

        if (!l[x] || x == t) continue;

        vector<E> &e = edge[x];

        for (int i = 0; i < edge[x].size() && l[x]; i++)
            if (e[i].flow && (x == s || d[x] == d[e[i].to] + 1)) {
                int tmp = min(e[i].flow, l[x]);

                if (!tmp) continue;

                if (x != s) l[x] -= tmp;

                l[e[i].to] += tmp;
                e[i].flow -= tmp;
                edge[e[i].to][e[i].back].flow += tmp;

                if (e[i].to != s && !v[e[i].to])
                    v[e[i].to] = 1, push(e[i].to);
            }

        if (x != s && l[x]) {
            if (!--num[d[x]]) {
                int a = d[x];

                for (int i = 1; i <= n; i++)
                    if (d[i] >= a && i != s && i != t)
                        d[i] = n, l[i] = 0;

                continue;
            }

            int tmp = n;

            for (int i = 0; i < edge[x].size(); i++)
                if (e[i].flow)
                    tmp = min(tmp, d[e[i].to] + 1);

            num[d[x] = tmp]++;
            push(x);
        }

        v[x] = 0;
    }

    return l[t];
}
int main() {
    scanf("%d%d%d%d", &n, &m, &s, &t);

    for (int i = 0; i < m; i++) {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        edge[x].push_back((E) {
            y, z, edge[y].size()
        });
        edge[y].push_back((E) {
            x, 0, edge[x].size() - 1
        });
    }

    printf("%d\n", hlpp(s, t));
    system("pause");
    return 0;
}
```

#### 2.最小费用最大流算法

在总容量最大的前提下，总费用最小的流。

```C++
#include <iostream>
#include <vector>
#include <string.h>
#include <queue>
using namespace std;
const int maxn = 5000;
const int INF = 0x7fffffff;
struct Edge{
    int from, to, cap, flow, cost;
};

struct MCMF{
    int n, m, s, t;
    vector<Edge> edges;
    vector<int> G[maxn];
    int inq[maxn];  // 是否在队列中
    int d[maxn];    // Bellman-ford
    int p[maxn];    // 上一条弧
    int a[maxn];    // 可改进量
    void init(){
        for(int i = 0; i < n; i++) G[i].clear();
        edges.clear();
    }

    void AddEdge(int from, int to, int cap, int cost){
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }
    bool BellmanFord(int s, int t, int &flow, int &cost){
        for(int i = 0; i < n; i++) d[i] = INF;
        memset(inq, 0, sizeof inq);
        d[s] = 0; inq[s] = 1; p[s] = 0; a[s] = INF;
        
        queue<int> Q;
        Q.push(s);
        while (!Q.empty()) {
            int u = Q.front(); Q.pop();
            inq[u] = 0;
            for(int i = 0; i < G[u].size(); i++){
                Edge &e = edges[G[u][i]];
                if(e.cap > e.flow && d[e.to] > d[u] + e.cost){
                    d[e.to] = d[u] + e.cost;
                    p[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to]) {
                        Q.push(e.to); inq[e.to] = 1;
                    }
                }
            }
        }
        if(d[t] == INF) return false;   // s-t不连通，失败退出
        flow += a[t];
        cost += d[t] * a[t];
        int u = t;
        while(u != s){
            edges[p[u]].flow += a[t];
            edges[p[u] ^ 1].flow -= a[t];
            u = edges[p[u]].from;
        }
        return true;
    }

    int MinCost(){
        int flow = 0, cost = 0;
        while(BellmanFord(s, t, flow, cost));
        return cost;
    }
};
int main() {
    MCMF e;
    scanf("%d%d%d%d", &e.n, &e.m, &e.s, &e.t);
    e.init();
    for (int i = 0; i < e.m; i++) {
         int x, y, z, a;
         scanf("%d%d%d%d", &x, &y, &z, &a);
         e.AddEdge(x, y, z, a);
         e.MinCost();
    }
    return 0;
}
```



### 3.2-SAT问题

- 给定一个布尔方程，判断是否存在一组布尔变量的真值指派整个方程为真的问题。
- 将布尔方程转换为合取范式，



### 4.最小生成树

#### 1.==堆优化Prim算法（无向图）==

- 时间复杂度为$O(|E|\log |V|)$

```c++
#include <iostream>
#include <string.h>
#include <queue>
using namespace std;
typedef pair<int, int> P;   // 前一个是距离，后一个是节点编号
const int MAX_N = 1000;
const int MAX_M = 2000;
const int INF = 0x7fffffff;

struct edge {
    int next;
    int w;
    int v;
}E[MAX_M << 1];
bool vis[MAX_N];
int dis[MAX_N], h[MAX_N];
int cnt, n, m, res;

void init() {
    memset(vis, false, sizeof vis);
    for(int i = 1; i <= n; i++) dis[i] = INF;
}

void insert(int u, int v, int w){
    E[++cnt].v = v;
    E[cnt].w = w;
    E[cnt].next = h[u];
    h[u] = cnt;
}

void Prim(int s) {
    init();
    dis[s] = 0;
    priority_queue<P, vector<P>, greater<P> > que; // 升序排列
    que.push(P(0, s));
    int num = 0;

    while(!que.empty()) {
        P p = que.top(); que.pop();
        int v = p.second;
        if(vis[v]) continue;
        vis[v] = true;
        res += dis[v];
        if(++num == n) break;
        for(int e = h[v]; e; e = E[e].next) {
            int u = E[e].v, w = E[e].w;
            if(!vis[u] && w < dis[u]) { // 这里的条件和Dijstra算法不同
                dis[u] = w;
                que.push(P(dis[u], u));
            }
        }
    }
}

int main(){
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= m; i++){
        int u, v, w; scanf("%d%d%d", &u, &v, &w);
        // 无向图需要加入两条边
        insert(u, v, w); insert(v, u, w);
    }
    Prim(1);    // 起始点设置为1
    printf("%d\n", res);
    system("pause");
    return 0;
}
```

#### 2.==Kruskal算法（无向图）==

- 算法的时间复杂度为$O(|E|\log |V|)$

```C++
#include <iostream>
#include <algorithm>
using namespace std;
const int MAX_N = 1000;
const int MAX_M = 3000;
int par[MAX_N], rank1[MAX_N], res, n, m, cnt;
struct edge{
    int from, to, cost;
    bool operator<(const edge& e) const{
        return cost < e.cost;
    }
}es[MAX_M << 1];

void init(){
    for(int i = 1; i <= n; i++){
        par[i] = i;
        rank1[i] = 0;
    }
}

int find(int x){
    if(x == par[x]) return x;
    return par[x] = find(par[x]);
}

void unite(int x, int y){
    x = find(x); y = find(y);
    if(x == y) return;
    if(rank1[x] < rank1[y]) par[x] = y;
    else {
        par[y] = x;
        if(rank1[x] == rank1[y]) rank1[x]++;
    }
}

bool same(int x, int y){
    return find(x) == find(y);
}

void kruskal() {
    sort(es, es + cnt);
    init();
    for(int i = 0; i < cnt; i++){
        edge e = es[i];
        if(!same(e.from, e.to)){
            unite(e.from, e.to);
            res += e.cost;
        }
    }
}

int main() {
    scanf("%d%d", &n, &m);
    for(int i = 0; i < m; i++) {
        int u, v, w; scanf("%d%d%d", &u, &v, &w);
        es[cnt].from = u; es[cnt].to = v; es[cnt].cost = w;
        cnt++;
        es[cnt].from = v; es[cnt].to = u; es[cnt].cost = w;
        cnt++;
    }
    kruskal();
    printf("%d\n", res);
    system("pause");
    return 0;
}
```

#### 最小树形图（有向图的最小生成树）

[(27条消息) 最小树形图（有向图的最小生成树）_softwareX4的博客-CSDN博客_有向图的最小生成树](https://blog.csdn.net/softwareX4/article/details/98949960?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=2)

##### 树形图定义：

从根节点出发可以到达所有其他点（所以图首先要联通）

##### 最小树形图定义：

设G=(V,E)是一个有向图，如果具有下述性质：

- G中不包含有向环
- 存在一个顶点vi，它不是任何弧的终点，而V的其他顶点都恰好是唯一的一条弧的终点，则称G是以vi为根的树形图。

最小树形图就是有向图G=(V,E)中以vi为根的树形图中权值和最小的那个。显而易见，对于不同的vi，得到的最小树形图是不一样的，甚至有可能不存在。

#### 3.朱刘算法：

##### 算法思想：

1. 求最短弧集合E；**从所有以vi(i≠0)为终点的弧中取一条最短的，若对于点vi，没有入边，则不存在最小树形图，算法结束；如果能取，则得到由n-1个点和n-1条边组成的图G的一个子图G'，该子图的权值一定是最小的，但是不一定是一棵树。**
2. 判断集合E中有没有有向环，如果有转步骤3，否则转4；
3. 收缩点，把有向环收缩成一个点，并且对图重新构建，包括边权值的改变和点的处理，之后再转步骤1；
4. 展开收缩点，求得最小树形图；

![img](https://cdn.luogu.com.cn/upload/pic/22859.png)

##### 时间复杂度：$O(nm)$

##### 代码

```C++
#include <iostream>
using namespace std;
const int M = 1e4 + 10;
const int N = 105;
const int INF = 0x7fffffff;
struct Edge{
	int u, v, w;
}E[M];
// root是最小树形图的根节点
int n, m, root;
// pre[i]表示i节点最小入边的源点
// ine[i]表示i节点最小入边的长度
int pre[N], ine[N], vis[N], id[N];

int zhuliu(){
	int ans = 0;
	while(1){	// 循环
		for(int i = 1; i <= n; i++) ine[i] = INF;	// 初始化
		for(int i = 1; i <= m; i++){	// 遍历每条边
			int u = E[i].u, v = E[i].v;	
			if(u != v && E[i].w < ine[v]){ // 对每个点找到最小入边
				ine[v] = E[i].w;
				pre[v] = u;
			}
		}
		for(int i = 1; i <= n; i++){ // 存在除根节点外的节点没有入边，无解
			if(i != root && ine[i] == INF) return -1;
		}
		int cnt = 0;
		for(int i = 1; i <= n; i++) vis[i] = id[i] = 0;
		for(int i = 1; i <= n; i++){
			if(i == root) continue;
			ans += ine[i];
			int v = i;
			// 将所有能到达i节点的节点j，vis[j]=i
			// 如果vis[i]=i说明存在环
			while(vis[v] != i && !id[v] && v != root) { // 找环
				vis[v] = i;
				v = pre[v];
			}
			// 如果没有环， v == root
			if(!id[v] && v != root){
				id[v] = ++cnt;	// 将环上的点标记为同一点，缩点
				for(int u = pre[v]; u != v; u = pre[u]){
					id[u] = cnt;
				}
			}
		}
		if(cnt == 0) break;		// 如果无环，得到解
		// 不在环中的点，重新编号
		for(int i = 1; i <= n; i++){
			if(!id[i]) id[i] = ++cnt;
		}
		for(int i = 1; i <= m; i++){
			int u = E[i].u, v = E[i].v;
			E[i].u = id[u], E[i].v = id[v];
			if(!id[u] != id[v]) E[i].w -= ine[v];	// 修改边权
		}
		root = id[root];	// 缩点之后根节点的编号
		n = cnt;	// 缩点之后的点数
	}
	return ans;
}

int main() {
	system("pause");
	return 0;
}
```

#### 4.Tarjan优化朱刘算法

##### 算法过程：

1. 枚举每个**原图**中的节点$x$，然后不停地把边$(pre[x],x)$加入最小树形图，答案累加$in[x]$，在某一时刻发现出现了环，删除该环内部所有边，然后暴力把每个指向该环的边$(u,v)$，令边权减去$in[v]$然后将这个环缩成一个点,然后迭代进行，直至到达根节点$r$，这样还是$O(nm)$。
2. 考虑优化，我们对于每个点$x$建一棵左偏树$T_x$，然后我们就可以在$O(1)$的时间复杂度查询一个节点的最小入边，缩环的时候直接合并左偏树即可，边权减打标记即可,因此我们需要很好的实现标记下放，一次对环的合并我们不妨及做$log(n)$，每个节点属于哪个环可以用并查集路径压缩+按秩合并，删除节点可以用延迟删除$(N_5)$

##### 时间复杂度：$O(m+n\log n)$

```C++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#define il inline
#define ri register
#define Size 100050
using namespace std;
int fa[Size],cnt,is[Size];
il int find(int);
il void read(int&),Union(int,int);
struct leftist{
	struct point{
		int l,r,d,v,t,to;
	}a[Size]={{0,0,-1,0,0,0}};
	int r[Size];
	il void merge(int&x,int&y){
		if(!x||!y){x^=y;return;}
		if(a[x].v>a[y].v)x^=y^=x^=y;
		a[y].t-=a[x].t,a[y].v-=a[x].t;
		merge(a[x].r,y);
		if(a[a[x].l].d<a[a[x].r].d)
			a[x].l^=a[x].r^=a[x].l^=a[x].r;
		a[x].d=a[a[x].r].d+1;
	}
	il void spread(int&p){
		a[a[p].l].t+=a[p].t,a[a[p].r].t+=a[p].t;
		a[a[p].l].v+=a[p].t,a[a[p].r].v+=a[p].t;
		a[p].t=0;
	}
	il void pop(int&x){
		spread(x),merge(a[x].l,a[x].r),x=a[x].l;
	}
	il point*top(int&x){
		while(r[x]&&!(find(a[r[x]].to)^x))pop(r[x]);
		if(!r[x])puts("-1"),exit(0);
		a[r[x]].to=find(a[r[x]].to);
		return &a[r[x]];
	}
}L;
int pre[Size];
int main(){
	int n,m,r,ans(0);leftist::point*temp;
	read(n),read(m),read(r),cnt=n,is[r]=r;
	for(int i(1),u,v,w;i<=m;++i)
		read(u),read(v),read(w),
			L.a[i]={0,0,0,w,0,u},
			L.merge(L.r[v],u=i);
	for(int i(1);i<=n<<1;++i)fa[i]=i;
	for(int i(1),j(i);i<=n;j=++i)
		while(!is[j]){
			while(!is[j])
				is[j]=i,j=(temp=L.top(j))->to,
					ans+=temp->v;if(is[j]^i)break;
			while(~is[j])
				is[j]=-1,j=pre[j]=(temp=L.top(j))->to,
					temp->t-=temp->v,temp->v=0;++cnt;
			while(is[j]^i)is[j]=i,Union(j,cnt),j=pre[j];
			j=cnt;
		}return printf("%d",ans),0;
}
il void Union(int u,int v){
	if((u=find(u))^(v=find(v)))
		L.merge(L.r[v],L.r[u]),fa[u]=v;
}
il int find(int x){
	return x^fa[x]?fa[x]=find(fa[x]):x;
}
il void read(int&x){
	x^=x;ri char c;while(c=getchar(),c<'0'||c>'9');
	while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
}
```

#### 无根图的树形图

不限定根结点的树形图，我们可以虚拟一个0号根节点，并向各个点连一条权值为$sum(w)+1$的边，因为权值很大，所以最终结果一定只包含一条这样的边；但是如果答案大于$sum+sum+1$，其实是无解的，这样相当于两个点不联通，只好多选一条大边；否则答案是$ans-sum-1$

如果要输出编号最小的根节点，多解的情况一定是有环，而超级源点最后选择的一条出边一定就是最优解（多加的边按照点的编号排序）；所以我们就在找边的时候加上一句就好了；

```C++
if (u == root) pos = i;
```

那么答案即为$pos-m-1$（$pos$为边的编号）



### 5.==拓扑排序(判环)==

DAG，有向五环图

```C++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;
const int MAX_N = 1000;
const int MAX_M = 3000;
struct edge {
    int next;
    int v;
}E[MAX_M];
int h[MAX_N], indegree[MAX_N];//所有点的所有连接边的第一条，入度
int cnt, n, m;//n是顶点数，m边数
vector<int> topo;   // 拓扑排序序列

void insert(int u, int v){
    E[++cnt].v = v;
    E[cnt].next = h[u];
    h[u] = cnt;
}

bool toposort(){
    int sum = 0;
    queue<int> que;
    for(int i = 1; i <= n; i++){
        if(indegree[i] == 0){
            que.push(i); sum++;
            topo.push_back(i);
        }
    }

    while (!que.empty()) {
        int now = que.front(); que.pop();
        for (int i = h[now]; i; i = E[i].next) {
            int v = E[i].v;
            if(--indegree[v] == 0){
                topo.push_back(v);
                que.push(v);
                sum++;
            }
        }      
    }
    
    return sum == n;
}

int main(){
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= m; i++){
        int u, v; scanf("%d%d", &u, &v);
        insert(u, v); 
        indegree[v]++;
    }
    if(!toposort()){
        puts("The graph has loop!");
    }else{
        for(auto i : topo) printf("%d ", i);
        printf("\n");
    }
    system("pause");
    return 0;
}
```



### 6.二分图

##### 1.==染色法判断二分图==

- 时间复杂度为$O(|V|+|E|)$

```C++
#include <iostream>
using namespace std;
const int MAX_N = 1000;
const int MAX_M = 2000;

struct edge{
    int next;
    int w;
    int v;
}E[MAX_M << 1];
bool vis[MAX_N];//是否访问过
int h[MAX_N], color[MAX_N]; // 这里是二染色，值为1/-1
int cnt, n, m;

void insert(int u, int v, int w){
    E[++cnt].v = v;
    E[cnt].w = w;
    E[cnt].next = h[u];
    h[u] = cnt;
}

bool dfs(int i, int c){//染色，看有没有冲突
    color[i] = c;
    for(int e = h[i]; e; e = E[i].next){
        int v = E[i].v;
        if(vis[v] && color[v] == c) return false;
        if(!vis[v] && !dfs(v, -c)) return false;
    }
    return true;
}

int main(){
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= m; i++){
        int u, v, w; scanf("%d%d%d", &u, &v, &w);
        // 无向图需要加入两条边
        insert(u, v, w);
        insert(v, u, w);
    }
    for(int i = 1; i <= n; i++){
        if(color[i] == 0){ // 未染色
            if(!dfs(i, 1)) puts("It's not a bipartite graph!");
        }
    }
    puts("It's a bipartite graph!");
    system("pause");
    return 0;
}
```

##### 2.二分图最大匹配

- 二分图最大匹配可以转化为最大流问题
- 算法时间复杂度为$O(|V||E|)$

```C++
#include <iostream>
#include <vector>
#include <string.h>
using namespace std;
const int MAX_V = 5000;
int V;  // 顶点数
vector<int> G[MAX_V];   // 图的邻接表表示
bool used[MAX_V];       // DFS中用到的访问标记
int match[MAX_V];       // 所匹配的顶点

void add_edge(int u, int v){
    G[u].push_back(v);
    G[v].push_back(u);
}

// 通过DFS寻找增广路
bool dfs(int v){
    used[v] = true;
    for (int i = 0; i < G[v].size(); i++) {
        int u = G[v][i], w = match[u];
        if(w < 0 || !used[w] && dfs(w)){
            match[v] = u; match[u] = v;
            return true;
        }
    }
    return false;
}

// 求解二分图的最大匹配
int bipartite_matching(){
    int res = 0;
    memset(match, -1, sizeof match);
    for (int v = 0; v < V; v++) {
        if (match[v] < 0) {
            memset(used, 0, sizeof used);
            if (dfs(v)) res++;           
        }      
    }
    return res;
}

int main() {
    return 0;
}
```

- 最小点覆盖=最大匹配数，最小点覆盖：从图中选出最少的点，使得图中任意一边的两个端点至少有一个被选中
- 最大独立集=图中点的个数-最大匹配数，最大独立集：从一个图中选出最多的点，使得选出的点之间没有边
- 最大团（最大完全子图）=补图的最大独立集，最大团：从一个图中选出最多的点，使得每两个点之间都有边



### 7.==Tarjan算法==

(Tarjan 算法是基于深度优先搜索的，用于求解图的连通性问题的算法)

#### 求解SCC

```C++
#include <iostream>
#include <vector>
#include <stack>
#define ll long long
using namespace std;
const int N{10005},M{100005};
int n, m;
vector<int> v[N];        //原图
vector<int> dag[N]; 	//缩点后的DAG
int ru[N] = {0}, chu[N] = {0}; 	//记录DAG中每个点的入度、出度

stack<int>s;    // 临时栈
bool inStack[N];    // 判断节点是否在栈中
//dfn[i]是i的编号，low[i]表示i能到达的最小编号，id[i]是i属于的连通分量的编号
int dfn[N], low[N], id[N];  
int timeStamp = 0, scc = 0;     //时间戳，强连通分量编号
void tarjan(int u){
    dfn[u] = low[u] = ++timeStamp;
    s.push(u); inStack[u] = true;
    for(auto nxt : v[u]){
        if(!dfn[nxt]){
            tarjan(nxt);
            low[u] = min(low[u], low[nxt]);
        }else if(inStack[nxt]){
            low[u] = min(low[u], dfn[nxt]);
        }
    }
    if (dfn[u] == low[u]) {
        int now; scc++;
        do{
            now = s.top(); s.pop();
            inStack[now] = false;
            id[now] = scc;
        }while(now != u);
    } 
} // end tarjan

//缩点之后，id越小拓扑序越靠后
void shrinkPoint(){
    for(int i = 1; i <= n; i++){
        for(auto nxt : v[i]){
            if(id[i] != id[nxt]) {
                dag[id[i]].push_back(id[nxt]);
                ru[id[nxt]]++; chu[id[nxt]]++;
            }
        }
    }
}   // 缩点，将强连通分量看作一个点

void execute(){
    for(int i = 1; i <= n; i++){
        if(!dfn[i]) tarjan(i);
    }
    shrinkPoint();
}   // 执行Tarjan算法和缩点

```

- 运用SCC来求解点权之和最大的路径

```C++
#include <iostream>
#include <vector>
#include <stack>
#define ll long long
using namespace std;
const int N{10005},M{100005};
int n, m;
int score[N];           // 点权,记录每个点的权值
vector<int> v[N];       //原图

int score2[M] = {0}; 		//DAG点权
vector<int> dag[N]; 	//缩点后的DAG
int ru[N] = {0}, chu[N] = {0}; 	//记录DAG中每个点的入度、出度

int f[N] = {0};     //f[i]代表以i为终点可获得的最大值

stack<int>s;    // 临时栈
bool inStack[N];    // 判断节点是否在栈中
//dfn[i]是i的编号，low[i]表示i能到达的最小编号，id[i]是i属于的连通分量的编号
int dfn[N], low[N], id[N];  
int timeStamp = 0, scc = 0;     //时间戳，强连通分量编号
void tarjan(int u){
    dfn[u] = low[u] = ++timeStamp;
    s.push(u); inStack[u] = true;
    for(auto nxt : v[u]){
        if(!dfn[nxt]){
            tarjan(nxt);
            low[u] = min(low[u], low[nxt]);
        }else if(inStack[nxt]){
            low[u] = min(low[u], dfn[nxt]);
        }
    }
    if (dfn[u] == low[u]) {
        int now; scc++;
        do{
            now = s.top(); s.pop();
            inStack[now] = false;
            id[now] = scc;
        }while(now != u);
    } 
} // end tarjan

//缩点之后，id越小拓扑序越靠后
void shrinkPoint(){
    for(int i = 1; i <= n; i++){
        score2[id[i]] += score[i]; // 缩点时计算SCC的点权
        for(auto nxt : v[i]){
            if(id[i] != id[nxt]) {
                dag[id[i]].push_back(id[nxt]);
                ru[id[nxt]]++; chu[id[nxt]]++;
            }
        }
    }
}   // 缩点，将强连通分量看作一个点

void execute(){
    for(int i = 1; i <= n; i++){
        if(!dfn[i]) tarjan(i);
    }
    shrinkPoint();
}   // 执行Tarjan算法和缩点

int dp(){
    for(int i = scc; i >= 1; i--){
        f[i] += score2[i];
        for(auto nxt : dag[i]){
            f[nxt] = max(f[nxt], f[i]);
        }
    }
    int ans = 0;
    for(int i = scc; i >= 1; i--){
        if(chu[i] == 0) ans = max(ans, f[i]);
    }
    return ans;
}

int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= m; i++){
        int x, y; scanf("%d%d", &x, &y);
        v[x].push_back(y);
    }
    execute();
    printf("%d\n", dp());
    return 0;
}
```

- 求解最大强连通子图

```C++
#include <bits/stdc++.h>  
using namespace std;  
#define ll long long  
#define debug(x) {cerr<<#x<<" = "<<(x)<<endl;}  
const int N{5005};  
  
int n,m;  
vector<int>v[N];  
int dfn[N], low[N], id[N], size[N];  
int timeStamp=0, scc=0;  
stack<int>s;  
bool inStack[N];  
  
void tarjan(int u) {  
    low[u] = dfn[u] = ++timeStamp;  
    s.push(u); inStack[u] = true;  
    for(auto nxt:v[u]）{  
        if(!dfn[nxt]) {  
            tarjan(nxt);  
            low[u] = min(low[u], low[nxt]);  
        }  
        else if(inStack[nxt]) low[u] = min(low[u], dfn[nxt]);  
    }  
    if(dfn[u]==low[u]) {  // 栈中节点属于一个SCC
        int now; scc++;  
        do {  
            now = s.top(); s.pop();  
            id[now] = scc;  
            inStack[now] = false;  
            size[scc]++;  
        } while(now!=u);  
    }  
}  
  
int main() {  
    ios::sync_with_stdio(false);  
    cin>> n>> m;  
    for(int i=1;i<=m;i++) {  
        int x,y,opt; cin>>x>>y>>opt; //opt==1单向，2双向
        v[x].push_back(y);  
        if(opt==2) v[y].push_back(x);  
    }  
    for(int i=1;i<=n;i++)  
        if(!dfn[i]) tarjan(i);  
    int maxSize = -1, maxId; 
    for(int i=1;i<=n;i++) {  
        if(maxSize < size[id[i]]) {  
            maxSize = size[id[i]];  
            maxId = id[i];  
        }  
    }  
    cout<<maxSize<<endl;  
    for(int i=1;i<=n;i++) {  
        if(id[i]==maxId) cout<<i<<" ";  
    }  
    return 0;  
}  
```

- 有向图最少加多少边形成强连通分量：
  - 先用Tarjan算法求SCC、缩点
  - 缩点后的图入度为0的点有p个，出度为0的点有q个，则答案为$max(p,q)$
  - 注意当$SCC=1$时，不需要加边，答案为0

```C++
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		int temp;
		while (scanf("%d", &temp) && temp) {
			v[i].push_back(temp);
		}
	}
	execute();
	int p = 0, q = 0;
	for (int i = 1; i <= scc; i++) {
		if (in[i] == 0) p++;
		if (out[i] == 0) q++;
	}
	int res = (scc == 1) ? 0 : max(p, q);
	printf("%d\n%d\n", p, res);
	return 0;
}
```



#### 求解割点

```C++
#include <bits/stdc++.h>  
using namespace std;  
#define ll long long  
#define debug(x) {cerr<<#x<<" = "<<(x)<<endl;}  
const int N{20005};  
int n,m;  
bool isCut[N];  
int dfn[N], low[N], child[N];  
int timeStamp = 0;  
vector<int> v[N];  
  
void tarjan(int u, int fa) {//此节点，祖先节点  
    dfn[u] = low[u] = ++timeStamp;  
 
    for(auto nxt:v[u]){  
        if(!dfn[nxt]) {  
            tarjan(nxt, fa);  
            low[u] = min(low[u], low[nxt]);  
            if(low[nxt]>=dfn[u] && u!=fa) //下一个点能到达自己前面的点，则自己至关重要  
                isCut[u] = true;  
            if(u==fa) //祖先节点==自己，则该节点是根节点，其连接的点就是他儿子  
                child[u]++;  
        }  
        else low[u] = min(low[u], dfn[nxt]);  
    }  
    if(child[u]>=2 && u==fa) //是根节点，并且有至少两个儿子，则至关重要  
        isCut[u] = true;  
}  
  
int main() {  
    ios::sync_with_stdio(false);  
    cin>>n>>m;  
    for(int i=1;i<=m;i++){  
        int x,y; cin>>x>>y;  
        v[x].push_back(y);  
        v[y].push_back(x);  
    }  
    for(int i=1;i<=n;i++){  
        if(!dfn[i]) tarjan(i,i);  
    }  
    int cut = 0;  
    for(int i=1;i<=n;i++)  
        if(isCut[i]) cut++;  
    cout<<cut<<endl;  
    for(int i=1;i<=n;i++)  
        if(isCut[i]) cout<<i<<" ";  
    return 0;  
}  

```



#### 求解桥

- 在一张无向图中，判断边$e$（其对应的两个节点分别为$ u $与$ v$）是否为桥：$dfn[u]<low[v]$

```C++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>

using namespace std;

const int SIZE = 100010;
int head[SIZE], ver[SIZE * 2], Next[SIZE * 2];
int dfn[SIZE], low[SIZE];
int n, m, tot, num;
bool bridge[SIZE * 2];

void add(int x, int y) {
    ver[++tot] = y, Next[tot] = head[x], head[x] = tot; // 链式前向星
}

void tarjan(int x, int in_edge) {
    dfn[x] = low[x] = ++num;
    for (int i = head[x]; i; i = Next[i]) {
        int y = ver[i];
        if (!dfn[y]) {
            tarjan(y, i);
            low[x] = min(low[x], low[y]);
            if (low[y] > dfn[x]) bridge[i] = bridge[i ^ 1] = true;
        }
        else if (i != (in_edge ^ 1)) low[x] = min(low[x], dfn[y]);
    }
}

int main() {
    // [[0,1],[1,2],[2,0],[1,3]]
    cin >> n >> m;
    tot = 1;
    for (int i = 1; i <= m; i++) {
        int x, y; scanf("%d%d", &x, &y);
        add(x, y), add(y, x);
    }
    for (int i = 1; i <= n; i++)
        if (!dfn[i]) tarjan(i, 0);
    for (int i = 2; i < tot; i += 2)
        if (bridge[i]) printf("%d %d\n", ver[i ^ 1], ver[i]);
    system("pause");
    return 0;
}
```



#### 求解BCC(block)

- BCC中无割点
- BCC之间有公共点，则公共点一定是割点。
- 割点一定属于至少两个BCC,非割点属于一个BCC

```C++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;
const int maxn = 300;
// bccno表示每个节点所在的bcc编号
// bcc_cnt表示bcc的数目
// bcc[i]表示编号为i(1 <= i <= bcc_cnt)的bcc包含的节点
int pre[maxn], iscut[maxn], bccno[maxn], dfs_clock, bcc_cnt;
vector<int> G[maxn], bcc[maxn];
struct Edge{int u, v;};
stack<Edge> S;

int dfs(int u, int fa){
    int lowu = pre[u] = ++dfs_clock;
    int child = 0;
    for(int i = 0; i < G[u].size(); i++){
        int v = G[u][i];
        Edge e = Edge{u, v};
        if (!pre[v]) {      // 没有访问过v
            S.push(e);
            child++;
            int lowv = dfs(v, u);
            lowu = min(lowu, lowv);     // 用后代的low更新自己
            if(lowv >= pre[u]){
                iscut[u] = true;
                bcc_cnt++; bcc[bcc_cnt].clear();    //bcc从1开始编号
                while(1){
                    Edge x = S.top(); S.pop();
                    if(bccno[x.u] != bcc_cnt){
                        bcc[bcc_cnt].push_back(x.u);
                        bccno[x.u] = bcc_cnt;
                    }
                    if(bccno[x.v] != bcc_cnt){
                        bcc[bcc_cnt].push_back(x.v);
                        bccno[x.v] = bcc_cnt;
                    }
                    if(x.u == u && x.v == v) break;
                }
            }
        }else if(pre[v] < pre[u] && v != fa){
            S.push(e);
            lowu = min(lowu, pre[v]); // 用反向边更新自己
        } 
    }
    if(fa < 0 && child == 1) iscut[u] = 0;
    return lowu;
}

void find_bcc(int n){
    // 调用结束后S保证为空，所以不需要清空
    memset(pre, 0, sizeof pre);
    memset(iscut, 0, sizeof iscut);
    memset(bccno, 0, sizeof bccno);
    dfs_clock = bcc_cnt = 0;
    for(int i = 0; i < n; i++){
        if(!pre[i]) dfs(i, -1);
    }
}
```

#### 求解LCA

```

```



### 8.欧拉路径和欧拉回路

#### 判断

若图G中存在这样一条路径，使得它恰好通过G中每条边一次，则称该路径为欧拉路径。若该路径为一个环路，则称为欧拉回路。

1. 具有欧拉回路的图称为欧拉图。欧拉图是所有顶点入度和出度相等的有向弱连通图；没有奇度顶点的连通图
2. 只有欧拉路径但不具有欧拉回路的图称为半欧拉图。半欧拉图性质：有且仅有两个奇度顶点的无向连通图

```C++
// 判断无向图中是否存在欧拉路径和欧拉回路
#include <bits/stdc++.h>
using namespace std;
const int MAX_M = 10000;
const int MAX_N = 200;
struct edge{
	int v, next;
	int len;
}E[MAX_M];
int p[MAX_N], eid, n, m;
int degree[MAX_N];	// 表示每个节点的入度 

void init(){
	memset(p, -1, sizeof p);
	eid = 0;
	memset(degree, 0, sizeof degree);
}

void insert(int u, int v){
	E[eid].v = v;
	E[eid].next = p[u];
	p[u] = eid++;
}

// 判断无向图是否是连通图
int cnt;
bool vis[MAX_N];
void dfs(int u){
	vis[u] = true;
	cnt++;
	for(int i = p[u]; ~i; i = E[i].next){
		int v = E[i].v;
		if(!vis[v]) dfs(v);
	}
}

// 判断欧拉路
void euler(){
	dfs(1);
	if(cnt != n) {
		printf("不是连通图");
		return; 
	}
	int cntodd = 0;
	for(int i = 1; i <= n; i++){
		for(degree[i] % 2) cntodd++;
	}
	if(cntodd == 0) printf("Euler Circuit!\n");
	else if(cntodd == 2) printf("Euler path!\n");
	else printf("不是欧拉半图\n"); 
}
 
int main(){
	init();
	scanf("%d%d", &n, &m);
	for(int i = 0; i < m; i++){
		int u, v;
		scanf("%d%d", &u, &v);
		degree[v]++;
		degree[u]++;
		insert(u, v);
		insert(v, u);
	}
	return 0;
}
```

```C++
// 判断有向图是否有欧拉路和欧拉回路
#include <bits/stdc++.h>
using namespace std;
const int MAX_M = 10000;
const int MAX_N = 200;
struct edge{
	int v, next;
	int len;
}E[MAX_M];
int p[MAX_N], eid, n, m;
int degree[MAX_N];	// 表示每个节点的入度 

void init(){
	memset(p, -1, sizeof p);
	eid = 0;
	memset(degree, 0, sizeof degree);
}

void insert(int u, int v){
	E[eid].v = v;
	E[eid].next = p[u];
	p[u] = eid++;
}

// 判断欧拉路
int euler(){
	int first = 0, last = 0;
	for(int i = 1; i <= n; i++){
		if(degree[i] < -1 || degree[i] > 1) {
			printf("没有欧拉路径");
			return 0;
		}
		else if(degree[i] == -1){
			if(first != 0){
				printf("没有欧拉路径");
				return 0;
			}else{
				first = i;
			}
		}else if(degree[i] == 1){
			if(last != 0){
				printf("没有欧拉路径");
				return 0;
			}else{
				last = i;
			}
		}
	}
	if(first == 0 && last == 0){ // 所有顶点的出度和入度相等 
		printf("It has an euler circuit\n");
		return 1;
	}else if(first != 0 && last != 0){ // 至多有两个顶点的入度和出度绝对值差1（若有两个这样的顶点，则必须其中一个出度大于入度，另一个入度大于出度）,其他顶点的入度与出度相等
		printf("It has an euler path\n");
		return 1;
	}else{
		printf("It has no euler path\n");
		return 0;
	}
}
 
int main(){
	init();
	scanf("%d%d", &n, &m);
	for(int i = 0; i < m; i++){
		int u, v;
		scanf("%d%d", &u, &v);
		degree[v]++;
		degree[u]--;
		insert(u, v);
	}
	return 0;
}
```

#### 求解

找到一个合适的顶点出发进行dfs时。当搜到一个顶点u时：

1. 如果此时没有顶点与该顶点相连，就将u加入路径中并回溯
2. 如果有顶点v与顶点u相连，那么就删除无向边<u, v>，并继续搜索顶点v。将所有和u相邻的顶点遍历完后将u加入到路径中。



## 9.基环树（环套树）

[参考资料](https://www.codetd.com/article/7620085)

#### 9.1概念

众所周知，Ｎ个点的树有Ｎ－１条边．若在树上任意添加一条边，则会形成一个环，除了环之外，其余部分由若干棵子树构成。我们把这种Ｎ个点Ｎ条边的连通无向图，即在树上加一条边构成的恰好包含一个环的图，称为“基环树”。如果不保证连通，那么Ｎ个点Ｎ条边的无向图也可能是若干棵基环树组成的森林，简称为“基环树森林“。

在有向图中，我们也有类似的概念。Ｎ个点、Ｎ条边、每个节点有且仅有一条入边的有向图就好像以“基环”为中心，有向外扩展的趋势，故称为“外向树”。Ｎ个点、Ｎ条边、每个节点有且仅有一条出边的有向连通图就好像以“基环”为中心，有向内收缩的趋势，故称为“内向树”。外向树和内向树也经常统称为“基环树”。如果不保证连通，那么Ｎ个点、Ｎ条边、每个节点有且仅有一条出（入）边的有向图也可能是“内（外）向树森林”的形态。

**求解基环树相关问题的方法一般都是先找出图中唯一的环，把环作为基环树的广义“根节点”，把除了环之外的部分按照若干棵树处理，再考虑与环一起计算。**

#### 9.4扣环（基环树处理的第一步）

```C++
struct edge{
    int nxt, v, w;
}es[M << 1];
int head[N], tot;
int vis[N], cnt, loop[N], dist[N], inl[N], rt;
int getLoop(int pos, int fa){
    if(vis[pos]){
        rt = pos;
        return 1;
    }
    vis[pos] = 1;
    int tmp;
    for(int i = head[pos]; i; i = es[i].nxt){
        if(es[i].v == fa) continue;
        if(tmp = getLoop(es[i].v, pos), tmp){
            
        }
    }
}
```

#### 9.3基环树直径



#### 9.4基环树DP



## 动态规划

### 动态规划基础

##### 最长公共子序列

假设两个字符串分别为$S_1$与$S_2$，同时创建一个二维数组$c$储存不同状态下的最优解，即最长公共子序列长度。子序列允许不连续

##### 最优二叉搜索树

给二叉搜索树的每个节点定义一个权值，问如何安排使得权值和深度的乘积最小。

##### 最长连续不下降子序列

求出给定序列的一个最长的连续子序列，满足这个序列中的后一个元素 **不小于** 前一个元素。

##### 最长不下降子序列

求出给定序列的一个最长子序列，满足这个序列中的后一个元素 **不小于** 前一个元素。不要求子序列连续考虑一下$O(n\log n)$的算法

```C++
// C++ Version
for (int i = 0; i < n; ++i) scanf("%d", a + i);
memset(dp, 0x1f, sizeof dp);
mx = dp[0];
for (int i = 0; i < n; ++i) {
  *std::upper_bound(dp, dp + n, a[i]) = a[i];
}
ans = 0;
while (dp[ans] != mx) ++ans;
```

##### DAG中的最长简单路径

$dp[i]=max(dp[j]+1),(j,i)\in E$

##### 最长回文子序列

##### 最长回文子串



### 记忆化搜索

##### 记忆化搜索的特征：

- 不依赖任何 **外部变量**
- 答案以返回值的形式存在，而不能以参数的形式存在（就是不能将 dfs 定义成 `dfs(pos,tleft,nowans)`，这里面的 `nowans` 不符合要求）。
- 对于相同一组参数，dfs 返回值总是相同的

山洞里有$M$株不同的草药，采每一株都需要一些时间$t_i$，每一株也有它自身的价值$v_i$。给你一段时间$T$，在这段时间里，你可以采到一些草药。让采到的草药的总价值最大。

```C++
// C++ Version
int n, t;
int tcost[103], mget[103];
int mem[103][1003];

int dfs(int pos, int tleft) {
  if (mem[pos][tleft] != -1) return mem[pos][tleft];
  if (pos == n + 1) return mem[pos][tleft] = 0;
  int dfs1, dfs2 = -INF;
  dfs1 = dfs(pos + 1, tleft);
  if (tleft >= tcost[pos]) dfs2 = dfs(pos + 1, tleft - tcost[pos]) + mget[pos];
  return mem[pos][tleft] = max(dfs1, dfs2);
}

int main() {
  memset(mem, -1, sizeof(mem));
  cin >> t >> n;
  for (int i = 1; i <= n; i++) cin >> tcost[i] >> mget[i];
  cout << dfs(1, t) << endl;
  return 0;
}
```



### 背包DP



### 区间DP

### DAG上的DP

### 树形DP

### 状压DP

### 数位DP

### 插头DP

### 计数DP

### 动态DP

### 概率DP

### DP优化

### 其他DP方法



## 树

### 1.线段树

#### 模型1

给定包括n个数的数组$a_1,a_2,a_3,...,a_n$，有两种操作：

1. 查询区间[l, r]最小的数
2. 修改$a_i$为$x$

对于一个节点，如果其表示的区间为[l, r]。 如果l=r，那么这个是一个叶子节点。否则令$mid=(l + r) /2$, 左儿子对应的区间为[l, mid]，右儿子对应的区间为[mid + 1, r]，这一思想有点类似二分。线段树总共有2 * n节点， 但数组一定是数组大小的四倍。

比如要维护区间最小值问题，我们用一个额外的数组minv记录每个节点对应区间的最小值。对于叶子节点，最小值就是一个数。而对于非叶子节点，区间的最小值就是左儿子的最小值和右儿子最小值中的最小值。

1.线段树的构建：构建线段树的过程是一个递归的过程，父节点的信息需要用子节点去更新，所以我们需要先递归地构建好左右子树，如下:

```C++
const int maxn = 10010; // maxn表示数的个数
int minv[4 * maxn], a[maxn]; // 4 * maxn表示需要节点编号数
// id表示节点编号，l,r表示左右区间，建树的时间复杂度为O(n)
void build(int id, int l, int r){
	if(l == r){
		minv[id] = a[l];
	}
	int mid = (l + r) >> 1;
	build(id << 1, l, mid);
	build(id << 1 | 1, mid + 1, r);
	minv[id] = min(minv[id << 1], minv[id << 1 | 1]);
}
```

 2. 单点更新：一般我们可以认为线段树的最大深度为$\log n$，所以这条链的最大长度也是$\log n$，所以一次更新的时间复杂度是$O(\log n)$

```C++
// 把x位置的值更改为v
void update(int id, int l, int r, int x, int v){
	if(l == r){
		minv[id] = v;
		return;
	}
	int mid = (l + r) >> 1;
	if(x <= mid){
		update(id << 1, l, mid, x, v);
	}else{
		update(id << 1 | 1, mid, r, x, v);
	}
	minv[id] = min(minv[id << 1], minv[id << 1 | 1]);
}
```

1. 单点查询：和单点更新一样，一直沿着链走到叶子节点就可以了，时间复杂度为

```C++
int query(int id, int l, int r, int x){
	if(l == r){
		return minv[id];
	}	
	int mid = (l + r) >> 1;
	if(x <= mid) return query(id << 1, l, mid, x);
    else 
	return query(id << 1 | 1, mid + 1, r, x);
}
```

4. 区间查询：对于查询的区间[x,y]我们可以划分为线段树上的节点，这些节点的区间合并起来就可以得到所需的信息。一次区间查询的复杂度也是$O(\log n)$

```C++
int query(int id, int l, int r, int x, int y){
	if(x <= l && r <= y){
		return minv[id];
	}	
	int mid = (l + r) >> 1;
	int ans = INT_MAX;
	if(x <= mid){
		ans = min(ans, query(id << 1, l, mid, x, y));
	}
	if(y > mid){
		ans = min(ans, query(id << 1 | 1, mid + 1, r, x, y));
	}
	return ans;
}
```

5. 完整程序代码

```C++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 110;
int minv[4 * maxn], a[maxn];

void pushup(int id){
	minv[id] = min(minv[id << 1], minv[id << 1 | 1]);
}

void build(int id, int l, int r){
	if(l == r){
		minv[id] = a[l];
		return;
	}
	int mid = (l + r) >> 1;
	build(id << 1, l, mid);
	build(id << 1 | 1, mid + 1, r);
	pushup(id);
}

void update(int id, int l, int r, int x, int v){
	if(l == r){
		minv[id] = v;
	}
	int mid = (l + r) >> 1;
	if(x <= mid){
		update(id << 1, l, mid, x, v);
	}else{
		update(id << 1 | 1, mid + 1, r, x, v);
	}
	pushup(id);
}

int query(int id, int l, int r, int x){
	if(l == r){
		return minv[id];
	}	
	int mid = (l + r) >> 1;
	if(x <= mid){
		return query(id << 1, l, mid, x);
		return query(id << 1 | 1, mid + 1, r, x);
	}
}

int query(int id, int l, int r, int x, int y){
	if(x <= l && r <= y){
		return minv[id];
	}	
	int mid = (l + r) >> 1;
	int ans = INT_MAX;
	if(x <= mid){
		ans = min(ans, query(id << 1, l, mid, x, y));
	}
	if(y > mid){
		ans = min(ans, query(id << 1 | 1, mid + 1, r, x, y));
	}
	return ans;
}

int main(){
	int n; scanf("%d", &n);
	for(int i = 1; i <= n; i++){
		scanf("%d", &a[i]);
	}
	build(1, 1, n);
	int q; scanf("%d", &q);
	for(int i = 0; i < q; i++){
		int x, v;
		scanf("%d%d", &x, &v);
		update(1, 1, n, x, v);
	}
	int p; scanf("%d", &p);
	for(int i = 0; i < p; i++){
		int l, r;
		scanf("%d%d", &l, &r);
		printf("%d\n", query(1, 1, n, l, r));
	}
	return 0;
}
```

#### 模型2

已知一个数列，你需要进行下面两种操作：

1. 将某区间每一个数加上 k。
2. 求出某区间每一个数的和。

```C++
#include <iostream>
using namespace std;
typedef long long ll;
const int maxn = 1e6 + 1;
// 懒标记的作用是记录每次、每个节点要更新的值
// 整个区间都被操作时，记录在公共祖先节点上
ll ans[maxn << 2], a[maxn], tag[maxn << 2]; // tag是懒标记

inline ll ls(int p) {return p << 1;}       // 求左儿子
inline ll rs(int p) {return p << 1 | 1;}   // 右儿子

inline void push_up(ll p){ // 自下而上
    ans[p] = ans[ls(p)] + ans[rs(p)];
}

void build(ll p, ll l, ll r){   // 建树
    tag[p] = 0;   
    if(l == r){ans[p] = a[l]; return;}
    ll mid = (l + r) >> 1;
    build(ls(p), l, mid);
    build(rs(p), mid + 1, r);
    push_up(p);
}

// 记录当前节点所代表的区间 
inline void f(ll p, ll l, ll r, ll k){
    tag[p] = tag[p] + k;
    ans[p] = ans[p] + k * (r - l + 1);
    //由于是这个区间统一改变，所以ans数组要加元素个数次
    //如果是乘法的话
    // ans[p] = ans[p] * k;
}

inline void push_down(ll p, ll l, ll r){
    ll mid = (l + r) >> 1;
    f(ls(p), l, mid, tag[p]);
    f(rs(p), mid + 1, r, tag[p]);
    tag[p] = 0;
}

inline void update(ll nl, ll nr, ll l, ll r, ll p, ll k){
    //nl,nr为要修改的区间
    //l,r,p为当前节点所存储的区间以及节点的编号 
    if(nl <= l && r <= nr){
        ans[p] += k * (r - l + 1);
        tag[p] += k;
        return;
    }
    push_down(p, l, r);
    ll mid = (l + r) >> 1;
    if(nl <= mid) update(nl, nr, l, mid, ls(p), k);
    if(nr > mid) update(nl, nr, mid + 1, r, rs(p), k);
    push_up(p);
}

ll query(ll q_x, ll q_y, ll l, ll r, ll p){ // 区间查询
    ll res = 0;
    if(q_x <= l && r <= q_y) return ans[p];
    ll mid = (l + r) >> 1;
    push_down(p, l, r);
    if(q_x <= mid) res += query(q_x, q_y, l, mid, ls(p));
    if(q_y > mid) res += query(q_x, q_y, mid + 1, r, rs(p));
    return res;
}

int main() {
    int n, m; scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++) scanf("%lld", &a[i]);
    build(1, 1, n);
    ll a1, b, c, d, e, f;
    while(m--){
        scanf("%lld", &a1);
        if(a1 == 1){
            scanf("%lld%lld%lld", &b, &c, &d);
            update(b, c, 1, n, 1, d);
        }else if(a1 == 2){
            scanf("%lld%lld", &e, &f);
            printf("%lld\n", query(e, f, 1, n, 1));
        }
    }
    system("pause");
    return 0;
}
```

#### 模板3

已知一个数列，你需要进行下面三种操作：

- 将某区间每一个数乘上 x
- 将某区间每一个数加上 x
- 求出某区间每一个数的和

```C++
#include <iostream>
#include <cstdio>
using namespace std;
int p; // 表示取模的模数
long long a[100007];    // 暂存数列的数组
struct node {
    //v表示此时的答案，mul表示乘法意义上的lazytag，add是加法意义上的
    long long v, mul, add;
}st[400007];

inline void pushup(int root){
    st[root].v = (st[root << 1].v + st[root << 1 | 1].v) % p;
}

// buildTree
void bt(int root, int l, int r) { // root表示编号
    st[root].mul = 1; st[root].add = 0;
    if (r == l) {
        st[root].v = a[l] % p;
        return;
    }
    int mid = (l + r) >> 1;
    bt(root << 1, l, mid);
    bt(root << 1 | 1, mid + 1, r);
    pushup(root);
}

//核心代码，维护lazytag
inline void pushdown(int root, int l, int r){
    int mid = (l + r) >> 1;
    // 乘法优先, 没有精度损失
    // 儿子的值=此刻儿子的值*爸爸的乘法lazytag+儿子的区间长度*爸爸的加法lazytag
    st[root << 1].v = (st[root << 1].v * st[root].mul + st[root].add * (mid - l + 1)) % p;
    st[root << 1 | 1].v = (st[root << 1 | 1].v * st[root].mul + st[root].add * (r - mid)) % p;

    // 更新儿子的lazytag
    st[root << 1].mul = st[root << 1].mul * st[root].mul % p;
    st[root << 1 | 1].mul = st[root << 1 | 1].mul * st[root].mul % p;
    st[root << 1].add = (st[root << 1].add * st[root].mul + st[root].add) % p;
    st[root << 1 | 1].add = (st[root << 1 | 1].add * st[root].mul + st[root].add) % p;

    // 初始化父亲的lazytag
    st[root].add = 0; st[root].mul = 1;
}

//update1，乘法
inline void update1(int root, int nl, int nr, int l, int r, long long k){
    if(nr < l || r < nl) return;
    //假如给出的区间包含本区间
    if(nl <= l && r <= nr){
        st[root].v = st[root].v * k % p;
        st[root].mul = st[root].mul * k % p;
        st[root].add = st[root].add * k % p;
        return;
    }
    //假如给出的区间和本区间有交集，但是也有不交叉的部分,需要先传递lazytag
    pushdown(root, l, r);
    int mid = (l + r) >> 1;
    if(nl <= mid) update1(root << 1, nl, nr, l, mid, k);
    if(nr > mid) update1(root << 1 | 1, nl, nr, mid + 1, r, k);
    pushup(root);
}

//update2，加法
inline void update2(int root, int nl, int nr, int l, int r, long long k){
    if(nr < l || r < nl) return;
    //假如给出的区间包含本区间
    if(nl <= l && r <= nr){
        st[root].add = (st[root].add + k) % p;
        st[root].v = (st[root].v + k * (r - l + 1)) % p;
        return;
    }
    //假如给出的区间和本区间有交集，但是也有不交叉的部分,需要先传递lazytag
    pushdown(root, l, r);
    int mid = (l + r) >> 1;
    if(nl <= mid) update2(root << 1, nl, nr, l, mid, k);
    if(nr > mid) update2(root << 1 | 1, nl, nr, mid + 1, r, k);
    pushup(root);
}

long long query(int root, int nl, int nr, int l, int r){
    if(nr < l || r < nl) return 0;
    long long res = 0;
    if(nl <= l && r <= nr) return st[root].v;
    pushdown(root, l, r);
    int mid = (l + r) >> 1;
    if(nl <= mid) res += query(root << 1, nl, nr, l, mid) % p;
    if(nr > mid) res += query(root << 1 | 1, nl, nr, mid + 1, r) % p;
    return res % p;
}

int main(){
    int n, m;
    scanf("%d%d%d", &n, &m, &p);
    for(int i = 1; i <= n; i++){
        scanf("%lld", &a[i]);
    }
    bt(1, 1, n);
    while(m--){
        int chk;
        scanf("%d", &chk);
        int x, y;
        long long k;
        if(chk == 1){
            scanf("%d%d%lld", &x, &y, &k);
            update1(1, x, y, 1, n, k);
        }
        else if(chk == 2){
            scanf("%d%d%lld", &x, &y, &k);
            update2(1, x, y, 1, n, k);
        }
        else{
            scanf("%d%d", &x, &y);
            printf("%lld\n", query(1, x, y, 1, n));
        }
    }
    system("pause");
    return 0;
}
```

#### 模板4

给出一个长度为 n的数列 A，同时定义一个辅助数组 B，B开始与 A完全相同。接下来进行了 m次操作，操作有五种类型，按以下格式给出：

- `1 l r k`：对于所有的 $i\in[l,r]$，将 $A_i$加上$ k$（k可以为负数）。
- `2 l r v`：对于所有的$ i\in[l,r]$，将$ A_i$变成$ \min(A_i,v)$。
- `3 l r`：求$ \sum_{i=l}^{r}$。
- `4 l r`：对于所有的 $i\in[l,r]$，求$ A_i$的最大值。
- `5 l r`：对于所有的$ i\in[l,r]$，求$ B_i$的最大值。

在每一次操作后，我们都进行一次更新，让 $B_i\gets\max(B_i,A_i)$。



- 区间最小值操作：给定 l, r和 k，将 $a_i$变为 $min(a_{i},k)$。（统称区间最值操作）
- 区间最大值操作：给定 l, r和 k，将 $a_{i} $变为$ max(a_{i},k)$。（统称区间最值操作）
- 历史最小值：$a_{i}$曾经存放的最小的数。
- 历史最大值：$a_{i}$曾经存放的最大的数。
- 历史版本和：一个区间历史最大值（或历史最小值）的和。

对于操作二的详解：

由于把$ a_{i}$变成的 $min(a_{i},k)$时候，只有在$a_i$小于 k的时候才会把值更新。所以每个节点要多维护三个信息：

- 该节点表示区间的最大值 maxn。
- 该节点表示区间的最严格次大值 se。（严格次大值是指比最大值小的最大值，可以理解为最大值的前驱。）
- 该节点表示区间的最大值的个数 cnt。

那么我们可以发现，当该节点进行操作 2时，可以被分为以下三种情况：

- 当 $maxn\le k$ 的时候，说明这个区间的最大值小于等于 k**，不能被更新，就可以直接返回。
- 当 $se<k<maxn$的时候，这个区间的最大值会全部被修改成 k**，**但是最大值的个数不变**。这个时候，将区间和减去 $cnt\times(maxn-k)$，即加上$ cnt\times(k-maxn)$，打上懒标记，返回即可。
- 当$ k\le se$的时候，需继续左右递归。

```C++
#include<iostream>
#define ll long long
using namespace std;
int n,m,op,l,r,k;
struct tree{
    // sum ：该区间的的和。
	ll sum;
    // add_a ：该区间最大值的加法的懒标记。
    // add_a1 ：该区间非最大值的加法的懒标记。
    // add_b ：该区间最大的历史最大值的加法的懒标记。
    // add_b1 ：该区间非最大的历史最大值的加法的懒标记。
	int add_a,add_a1,add_b,add_b1;
    // l：该区间的左端点。
    // r：该区间的右端点。
    // maxa：该区间的最大值。
    // se：该区间的严格次大值。
    // cnt：该区间最大值的个数。
    // maxb：该区间的历史最大值。
	int l,r,maxa,se,maxb,cnt;
}s[2000005];

inline void push_up(int p) {
	s[p].maxa = max(s[p*2].maxa, s[p*2+1].maxa);
	s[p].maxb=max(s[p*2].maxb,s[p*2+1].maxb);
	s[p].sum=s[p*2].sum+s[p*2+1].sum;
	if(s[p*2].maxa==s[p*2+1].maxa)
	{
		s[p].se=max(s[p*2].se,s[p*2+1].se);
		s[p].cnt=s[p*2].cnt+s[p*2+1].cnt;
	}
	if(s[p*2].maxa>s[p*2+1].maxa)
	{
		s[p].se=max(s[p*2].se,s[p*2+1].maxa);
		s[p].cnt=s[p*2].cnt;
	}
	if(s[p*2].maxa<s[p*2+1].maxa)
	{
		s[p].se=max(s[p*2].maxa,s[p*2+1].se);
		s[p].cnt=s[p*2+1].cnt;
	}
}
// k1：最大值要加的数。
// k2：最大的历史最大值要加的数。
// k3：非最大值要加的数。
// k4：非最大的历史最大值要加的数。
inline void update(int k1,int k2,int k3,int k4,int p)
{
	s[p].sum+=1ll*k1*s[p].cnt+1ll*k3*(s[p].r-s[p].l+1-s[p].cnt);
	s[p].maxb=max(s[p].maxb,s[p].maxa+k2);
	s[p].add_b=max(s[p].add_b,s[p].add_a+k2);
	s[p].add_b1=max(s[p].add_b1,s[p].add_a1+k4);
	s[p].maxa+=k1,s[p].add_a+=k1;
	s[p].add_a1+=k3;
	if(s[p].se!=-1e18)s[p].se+=k3;
}

inline void push_down(int p)
{
	int maxn=max(s[p*2].maxa,s[p*2+1].maxa);
	if(s[p*2].maxa==maxn)
	    update(s[p].add_a,s[p].add_b,s[p].add_a1,s[p].add_b1,p*2);
	else update(s[p].add_a1,s[p].add_b1,s[p].add_a1,s[p].add_b1,p*2);
	if(s[p*2+1].maxa==maxn)
		update(s[p].add_a,s[p].add_b,s[p].add_a1,s[p].add_b1,p*2+1);
	else update(s[p].add_a1,s[p].add_b1,s[p].add_a1,s[p].add_b1,p*2+1);
	s[p].add_a=s[p].add_b=s[p].add_a1=s[p].add_b1=0;
}

void build(int l,int r,int p)
{
	s[p].l=l,s[p].r=r;
	if(l==r)
	{
		s[p].sum=s[p].maxa=s[p].maxb;
		s[p].se=-1e9;
		s[p].cnt=1;
		return;
	}
	int mid=(l+r)/2;
	build(l,mid,p*2);
	build(mid+1,r,p*2+1);
	push_up(p);
}

void update_add(int p)
{
	if(s[p].l>r||s[p].r<l)return;
	if(l<=s[p].l&&s[p].r<=r)
	    return update(k,k,k,k,p);
	push_down(p);
	update_add(p*2),update_add(p*2+1);
	push_up(p);
}

void update_min(int p)
{
	if(s[p].l>r||s[p].r<l||k>=s[p].maxa)return;
	if(l<=s[p].l&&s[p].r<=r&&k>s[p].se)
	    return update(k-s[p].maxa,k-s[p].maxa,0,0,p);
	push_down(p);
	update_min(p*2),update_min(p*2+1);
	push_up(p);
}

ll query_add(int p)
{
	if(s[p].l>r||s[p].r<l)return 0;
	if(l<=s[p].l&&s[p].r<=r)return s[p].sum;
	push_down(p);
	return query_add(p*2)+query_add(p*2+1);
}

int query_maxa(int p)
{
	if(s[p].l>r||s[p].r<l)return -1e9;
	if(l<=s[p].l&&s[p].r<=r)return s[p].maxa;
	push_down(p);
	return max(query_maxa(p*2),query_maxa(p*2+1));
}

int query_maxb(int p)
{
	if(s[p].l>r||s[p].r<l)return -1e9;
	if(l<=s[p].l&&s[p].r<=r)return s[p].maxb;
	push_down(p);
	return max(query_maxb(p*2),query_maxb(p*2+1));
}

int main() {
	return 0;
}
```

#### 模板5

您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：

1. 查询 k在区间内的排名
2. 查询区间内排名为 k的值
3. 修改某一位值上的数值
4. 查询 k在区间内的前驱（前驱定义为严格小于 x，且最大的数，**若不存在输出 `-2147483647`**）
5. 查询 k在区间内的后继（后继定义为严格大于 x，且最小的数，**若不存在输出 `2147483647`**）

```C++
#include<stdio.h>
#define fa 4800000
#define fa2 1600000
#define LL long long
typedef struct Splay
{
    typedef struct Ts
    {
        int size,x;
        Ts*f,*l,*r;
    }Ts;
    static Ts mem[fa],*stk[fa],**top;
    Ts*root;
    inline Ts*New(int x,Ts*f)
    {
        Ts*p=*--top;
        p->size=1;
        p->x=x;
        p->f=f;
        p->l=p->r=0;
        return p;
    }
    inline void Del(Ts*&t)
    {
        *top++=t;
        t=0;
    }
    void init()
    {
        root=New(999999,0);
        root->l=New(-1,root);
        root->size=2;
    }
    void del(Ts*t)
    {
        if(t)
        {
            del(t->l);
            del(t->r);
            Del(t);
        }
    }
    inline void updata(Ts*t)
    {
        t->size=1;
        if(t->l)t->size+=t->l->size;
        if(t->r)t->size+=t->r->size;
    }
    inline void zuoxuan(Ts*t)
    {
        Ts*p=t->f;
        p->r=t->l;
        if(t->l)t->l->f=p;
        t->l=p;
        if(p->f)
        {
            if(p->f->l==p)p->f->l=t;
            else p->f->r=t;
        }
        t->f=p->f;
        p->f=t;
        updata(p);
        updata(t);
    }
    inline void youxuan(Ts*t)
    {
        Ts*p=t->f;
        p->l=t->r;
        if(t->r)t->r->f=p;
        t->r=p;
        if(p->f)
        {
            if(p->f->l==p)p->f->l=t;
            else p->f->r=t;
        }
        t->f=p->f;
        p->f=t;
        updata(p);
        updata(t);
    }
    void danxuan(Ts*t)
    {
        if(t->f->l==t)youxuan(t);
        else zuoxuan(t);
    }
    void splay(Ts*t,Ts*f=0)
    {
        Ts*tt;
        while((tt=t->f)!=f)
        {
            if(tt->f!=f)
            {
                if((tt->f->l==tt)==(t->f->l==t))danxuan(tt);
                else danxuan(t);
            }
            danxuan(t);
        }
        if(!f)root=t;
    }
    void insert(int x)
    {
        Ts*t=root;
        while(1)
        {
            t->size++;
            if(x<t->x)
            {
                if(t->l)t=t->l;
                else
                {
                    t->l=New(x,t);
                    t=t->l;
                    break;
                }
            }
            else
            {
                if(t->r)t=t->r;
                else
                {
                    t->r=New(x,t);
                    t=t->r;
                    break;
                }
            }
        }
        splay(t);
    }
    void erase(int x)
    {
        Ts*t=root;
        while(t->x!=x)
        {
            if(x<t->x)t=t->l;
            else t=t->r;
        }
        splay(t);
        Ts*l=t->l,*r=t->r;
        while(l->r)l=l->r;
        while(r->l)r=r->l;
        splay(l);splay(r,l);
        Del(r->l);
        l->size--;r->size--;
    }
    
    Ts*qianqu(int x)
    {
        Ts*q,*t=root;
        int min=9999999;
        while(t)
        {
            if(t->x>=x)t=t->l;
            else
            {
                if(x-t->x<min)
                {
                    q=t;
                    min=x-t->x;
                }
                t=t->r;
            }
        }
        return q;
    }
    Ts*houji(int x)
    {
        Ts*q,*t=root;
        int min=9999999;
        while(t)
        {
            if(t->x<=x)t=t->r;
            else
            {
                if(t->x-x<min)
                {
                    q=t;
                    min=t->x-x;
                }
                t=t->l;
            }
        }
        return q;
    }
    int num(int l_,int r_)
    {
        Ts*l=qianqu(l_),*r=houji(r_);
        splay(l);splay(r,l);
        return r->l?r->l->size:0;
    }
}Splay;
Splay::Ts Splay::mem[fa],*Splay::stk[fa],**Splay::top=Splay::stk+fa;
typedef struct Ts
{
    Splay t;
    Ts*l,*r;
}Ts;
Ts*root,mem[fa2],*stk[fa2],**top=stk+fa2;
inline Ts*New()
{
    Ts*p=*--top;
    p->l=p->r=0;
    p->t.init();
    return p;
}
inline void Del(Ts*&t)
{
    *top++=t;
    t->t.del(t->t.root);
    t=0;
}
void insert(Ts*&t,int x,int y,int L=0,int R=100000000)
{
    if(!t)t=New();
    t->t.insert(y);
    if(L^R)
    {
        int mid=L+R>>1;
        if(x<=mid)insert(t->l,x,y,L,mid);
        else insert(t->r,x,y,mid+1u,R);
    }
}
void erase(Ts*&t,int x,int y,int L=0,int R=100000000)
{
    t->t.erase(y);
    if(L^R)
    {
        int mid=L+R>>1;
        if(x<=mid)erase(t->l,x,y,L,mid);
        else erase(t->r,x,y,mid+1u,R);
    }
    if(t->t.root->size==2)Del(t);
}
int kth(Ts*t,int l,int r,int l_,int r_,int L=0,int R=100000000)
{
    if(!t)return 0;
    if(l==L&&r==R)return t->t.num(l_,r_);
    else
    {
        int mid=L+R>>1;
        if(r<=mid)return kth(t->l,l,r,l_,r_,L,mid);
        else if(l>mid)return kth(t->r,l,r,l_,r_,mid+1,R);
        else return kth(t->l,l,mid,l_,r_,L,mid)+kth(t->r,mid+1,r,l_,r_,mid+1,R);
    }
}
int num(Ts*t,int k,int l_,int r_,int L=0,int R=100000000)
{
    if(L==R)return L;
    int ls=t->l?t->l->t.num(l_,r_):0;
    int mid=L+R>>1;
    if(ls<k)return num(t->r,k-ls,l_,r_,mid+1,R);
    else return num(t->l,k,l_,r_,L,mid);
}
int a[50000];
int main()
{
    for(int i=0;i<fa;i++)Splay::stk[i]=Splay::mem+i;
    for(int i=0;i<fa2;i++)stk[i]=mem+i;
    int N,M,ls,l,r,k;
    scanf("%d%d",&N,&M);
    for(int i=0;i<N;i++)
    {
        scanf("%d",a+i);
        insert(root,a[i],i);
    }
    while(M--)
    {
        scanf("%d",&ls);
        if(ls==1)
        {
            scanf("%d%d%d",&l,&r,&k);
            if(k==0)puts("1");
            else printf("%d\n",kth(root,0,k-1,l-1,r-1)+1);
        }
        else if(ls==2)
        {
            scanf("%d%d%d",&l,&r,&k);
            printf("%d\n",num(root,k,l-1,r-1));
        }
        else if(ls==3)
        {
            scanf("%d%d",&l,&k);--l;
            erase(root,a[l],l);
            insert(root,a[l]=k,l);
        }
        else if(ls==4)
        {
            scanf("%d%d%d",&l,&r,&k);
            int no=kth(root,0,k-1,l-1,r-1);
            if(no==0)puts("-2147483647");
            else printf("%d\n",num(root,no,l-1,r-1));
        }
        else
        {
            scanf("%d%d%d",&l,&r,&k);
            int no=kth(root,0,k,l-1,r-1);
            if(no>r-l)puts("2147483647");
            else printf("%d\n",num(root,no+1,l-1,r-1));
        }
    }
}
```

#### 模板6

给出一个可重集 a（编号为 1），它支持以下操作：

`0 p x y`：将可重集 p中大于等于 x且小于等于 y的值移动到一个新的可重集中（新可重集编号为从 2开始的正整数，是上一次产生的新可重集的编号+1）。

`1 p t`：将可重集 t中的数放入可重集 p，且清空可重集 t（数据保证在此后的操作中不会出现可重集 t）。

`2 p x q`：在 p这个可重集中加入 x个数字 q。

`3 p x y`：查询可重集 p中大于等于 x且小于等于 y的值的个数。

`4 p k`：查询在 p 这个可重集中第 k小的数，不存在时输出 `-1`。

```C++

```



### 2.树状数组

对原始的问题进行修改，改成求和：

给定包括n个数的数组$a_1,a_2,a_3,...,a_n$，有两种操作：

1. 查询区间[l, r]数的和
2. 把$a_i$增加x

树状数组的一个节点表示的区间可以根据节点标号计算出来，对于节点i，其表示的区间为[i - lowbit(i) + 1, i],然后我们再用一个数组C表示每个节点对应的区间内的数的和：

$C_i=a_{i-lowbit(i)+1}+a_{i-lowbit(i)+2}+...+a_i$

1. 查询：要查询区间[l, r]的和值，我们可以先求出[1, r]的和值，然后减去[1, l - 1]的和值。
   1.1 令sum = 0
   1.2 加上区间[x - lowbit(x) + 1, x]的和值
   1.3 然后令x = x - lowbit(x)
   1.4 如果x = 0则退出，否则重复步骤1.1
   1.5 x = x - lowbit(x) 等价于将x的二进制的最后一个1减去。而x的二进制里最多有$\log x$个1

```C++
int C[maxn], n;

int lowerbit(x){
	return x & (-x);
}

int getSum(int x){
	int res = 0;
	for(int i = x; i > 0; i -= lowerbit(x)){
		res += C[i];
	}
	return res;
}
```

2. 更新:如果让$a_x$增加v，那么只有对于包含位置x的区间的和值才会收到影响。而求出哪些区间受影响有一个巧妙的操作，那就是令$x=x+lowerbit(x)$，直到x > n。

```C++
void update(int x, int v){
	for(int i = x; i <= n; i += lowerbit(x)){
		C[i] += v;
	}
}
```



## 单调栈和单调队列

#### 单调栈

常用模型：找出每个数左边离它最近的比它大/小的数

```C++
int tt = 0;
for (int i = 1; i <= n; i ++ ){
    while(tt && check(stk[tt])) tt--;
    stk[++tt] = a[i];
}
```

#### 单调队列

常用模型：有N个数，每次从左到右选取M个数，选取每个区间中的最小值/最大值输出

```C++
#include <iostream>
using namespace std;
const int N = 5e5 + 5;
const int INF = 1e9 + 5;
int value[N];	// 存储值
typedef struct{
	int value, index;
}QUE;
QUE min_que[N];
int front, rear, n, m;

int delete_rear_inc(int l, int r, int data){ // 二分法加速
	int mid;
	while(l <= r){
		mid = (l + r) >> 1;
		if(min_que[mid].value == data) return mid;
		if(min_que[mid].value > data) r = mid - 1;
		else l = mid + 1;
	}
	return l;
}

int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++) scanf("%d", &value[i]);
	min_que[1].value = value[1];
	min_que[1].index = 1;
	front = 1, rear = 1;
	for(int i = 2; i <= n; i++){
		rear = delete_rear_inc(front, rear, value[i]);
		min_que[rear].value = value[i];
		min_que[rear].index = i;
		if(i - min_que[front].index >= m) front++;
		if(i >= m) printf("%d\n", min_que[front].value);
	}
	system("pause");
	return 0;
}
```



## 数论

### 素数筛法

#### 1.埃式筛法

```C++
#include <iostream>
#include <vector>
using namespace std;
const int N = 1005;
vector<int> prime;
bool isPrime[N];
int main(){
	int n; scanf("%d", &n);
	for(int i = 0; i <= n; i++) isPrime[i] = true;
	isPrime[0] = isPrime[1] = false;
     for(int i = 2; i <= n; i++){
        if(isPrime[i]){
            for(int j = 2; j * i <= n; j++){
                isPrime[i * j] = false;
            }
            prime.push_back(i);
        }
    }
    return 0;
}
```

#### 2.==欧式筛法==

```C++
#include <iostream>
#include <vector>
using namespace std;
const int N = 1005;
vector<int> prime;
bool isPrime[N];
int main() {
	int n; scanf("%d", &n);
	for(int i = 0; i <= n; i++) isPrime[i] = true;
	isPrime[0] = isPrime[1] = false;
	// 欧式筛法，时间复杂度为O(n)
	for(int i = 2; i <= n; i++){
		if(isPrime[i]) prime.push_back(i);	
		for(int j = 0; j < prime.size() && i * prime[j] <= n; j++){
			isPrime[i * prime[j]] = false; //把p数组中记录的素数，升序依次作为需消去的合数的最小质因子
			// 若i为p[j]的倍数，则i=a*p[j]（a为常数），如果直接进入下一轮循环，j=j+1，i*p[j+1]=a*p[j]*p[j+1]，
			// 这里p[j]是最小的质因子，当i=a*p[j+1]时会重复，所以应该跳出循环
			if(i % prime[j] == 0) break;
		}
	}
    return 0;
}
```

### ==整数唯一分解定理==

给一个正整数n，将n分解为质因数。

```C++
#include <iostream>
#include <vector>
using namespace std;
vector<int> prime;
int main() {
    int n; scanf("%d", &n);
    for(int i = 2; i * i <= n; i++){
		while(n % i == 0){
            prime.push_back(i);
            n /= i;
        }
    }
    if(n > 1) prime.push_back(n);
    return 0;
}
```

