# 图论

### 1. P3758 [TJOI2017]可乐

#### 思路详解

现在有一个邻接矩阵$A$，从$floyd$算法的角度考虑，$A^k$的第$i$行第$j$列的数字含义是从$i$到$j$经过$k$步的路径方案总数。

原地停留：认为每个点都有一个从自己到自己的自环即可。

自爆：将自爆这个**状态**也看成一个**城市**，就设它为编号$0$,我们在邻接矩阵上从每个点都向这个点连一条边，这个点除了自己外不连其他出边。这样就满足了任何一个点随时可以自爆，且无法恢复到其他状态。

首先将这个图的邻接矩阵建出来，然后直接算这个矩阵的$k$次方，最后统计$\sum^n_{i=1}A[1][i]$就是答案。

#### 代码

```C++
#include <iostream>
#include <string.h>
using namespace std;
const int MOD = 2017;
typedef long long ll;
int N, M; 
struct matrix{
	ll A[35][35];
	matrix(){memset(A, 0, sizeof A);}
	inline matrix operator* (const matrix &m) const{
		matrix res;
		for(int i = 0; i <= N; i++){
			for(int j = 0; j <= N; j++){
				for(int k = 0; k <= N; k++){
					res.A[i][j] = (res.A[i][j] + A[i][k] * m.A[k][j] % MOD) % MOD;
				}
			}
		}
		return res;
	}
}m;

matrix pow(matrix& m, ll b){
	matrix res;
	for(int i = 0; i <= N; i++) res.A[i][i] = 1;
	while(b){
		if(b & 1) res = res * m;
		m = m * m;
		b >>= 1;
	}
	return res;
}

int main() {
	scanf("%d%d", &N, &M);
	for(int i = 0; i <= N; i++) m.A[i][i] = 1; 
	for(int i = 1; i <= N; i++) m.A[i][0] = 1;
	for(int i = 1; i <= M; i++){
		int u, v; scanf("%d%d", &u, &v);
		m.A[u][v] = 1; m.A[v][u] = 1;
	}
	ll t, res = 0; 
	scanf("%lld", &t);
	matrix ans = pow(m, t);
	for(int i = 0; i <= N; i++) res += ans.A[1][i] % MOD;
	printf("%lld", res % MOD);
	system("pause");
	return 0;
}
```

#### 知识点

快速幂、$floyd$算法



### 2.P1111 修复公路

#### 思路详解

一开始时各个村庄都是不连通的，需要我们加边。模仿$kruskal$算法的思路，每次选取$t$最小的边，合并端点集合，如果最后所有村庄都在一个集合，就退出程序，否则，无法通车。

#### 代码

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int maxm = 1e5 + 5, maxn = 1e3 + 5;
struct edge{
	int x, y, t;
	bool operator<(const edge &e) const{
		return t < e.t;
	}
}es[maxm];
int father[maxn];

int Find(int x){
	if(x == father[x]) return x;
	return father[x] = Find(father[x]);
}

int main() {
	int N, M, i; 
	scanf("%d%d", &N, &M);
	for(i = 1; i <= M; i++){
		scanf("%d%d%d", &es[i].x, &es[i].y, &es[i].t);
	}
	sort(es + 1, es + M + 1);
	for(i = 1; i <= N; i++) father[i] = i;
	for(i = 1; i <= M; i++){
		int fx = Find(es[i].x), fy = Find(es[i].y);
		if(fx != fy){
			father[fx] = fy;
			N--;
		}
		if(N == 1) break;
	}
	if(i <= M) printf("%d", es[i].t); 
	else printf("-1");
	system("pause");
	return 0;
}
```

#### 知识点

并查集，图的连通性



### 3.P1113 杂务

#### 思想

$f_i$为为从最开始到进行完第$ i$项任务所需的时间，$pre_i$为$ i$号结点的前驱数组，$a_i$为做第$ i$件事所需的时间。
$$
f_i=max\{pre_i\}+a_i
$$
然后进行拓扑排序。

#### 代码1

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;
const int maxn = 1e4 + 5;
int n, indeg[maxn], T[maxn], dp[maxn], outdeg[maxn]; 
vector<int> G[maxn];

void topoloy(){
	queue<int> que;
	for(int i = 1; i <= n; i++){
		if(!indeg[i]) que.push(i);
	}
	while(!que.empty()){
		int i = que.front(); que.pop();
		for(int j = 0; j < G[i].size(); j++){
			int v = G[i][j];
			dp[v] = max(dp[v], T[v] + dp[i]);
			if(--indeg[v] == 0) que.push(v);
		}
	}
}

int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; i++){
		int u, v; scanf("%d", &u);
		scanf("%d", &T[u]);
		while(scanf("%d", &v) && v){
			G[v].push_back(u);
			indeg[u]++; outdeg[v]++;
		}
	}
	dp[1] = T[1];
	topoloy();
	int res = 0;
	for(int i = 1; i <= n; i++){
		if(!outdeg[i]) res = max(res, dp[i]);
	}
	printf("%d", res);
	system("pause");
	return 0;
}
```

#### 代码2

```C++
#include<iostream>
using namespace std;
int n, l, t, ans[10005], maxans;
int main(){
    scanf("%d", &n);
    for(int i = 1;i <= n; ++i){
        scanf("%d %d",&i, &l);
        int tmp = 0;
        while(scanf("%d", &t) && t) tmp = max(ans[t], tmp);
        ans[i] = tmp + l;
        maxans = max(ans[i], maxans);
    } 
    printf("%d\n", maxans);
    return 0;
 } 
```

#### 知识点

拓扑排序、$DAG$动态规划



### 4.P2330 [SCOI2005]繁忙的都市

同P1111 修复公路

```C++
#include <iostream>
#include <algorithm>
using namespace std;
const int maxn = 305;
const int maxm = 1e5 + 5;
struct edge{
	int from, to, w;
	bool operator<(const edge &e) const{
		return w < e.w;
	}
}es[maxm];
int father[maxn], s, res;

int Find(int x){
	if(x == father[x]) return x;
	return father[x] = Find(father[x]);
}

int main() {
	int n, m; scanf("%d%d", &n, &m);
	for(int i = 1; i <= m; i++){
		int u, v, c; scanf("%d%d%d", &u, &v, &c);
		es[i] = edge{u, v, c};
	}
	sort(es + 1, es + m + 1);
	for(int i = 1; i <= n; i++) father[i] = i;
	for(int i = 1; i <= m; i++){
		int fx = Find(es[i].from), fy = Find(es[i].to);
		if(fx != fy){
			s++; res = es[i].w;
			father[fx] = fy;
		}
		if(s == n - 1) break;
	}
	printf("%d %d", s, res);
	system("pause");
	return 0;
}
```



### 5.P1546 [USACO3.1]最短网络 Agri-Net

#### 思想

最小生成树模板题

#### 代码

```C++
#include <iostream>
#include <queue>
#include <vector>
using namespace std;
typedef pair<int, int> P;
const int maxm = 20005, maxn = 105, INF = 0x7fffffff;
struct edge{
	int v, nxt, w;
}es[maxm];
int head[maxn], dis[maxn], vis[maxn];
int cnt, res, n;

void insert(int u, int v, int w){
	es[++cnt].v = v;
	es[cnt].w = w;
	es[cnt].nxt = head[u];
	head[u] = cnt;
}

void prim(int v){
	for(int i = 1; i <= n; i++) dis[i] = INF;
	dis[v] = 0;
	priority_queue<P, vector<P>, greater<P> > que;
	que.push(P(0, v));
	int num = 0;

	while (!que.empty()) {
		P p = que.top(); que.pop();
		int v = p.second;
		if(vis[v]) continue;
		vis[v] = 1;
		res += dis[v];
		if(++num == n) break;
		for(int e = head[v]; e; e = es[e].nxt){
			int to = es[e].v, w = es[e].w;
			if(!vis[to] && w < dis[to]){
				dis[to] = w;
				que.push(P(dis[to], to));
			}
		}
	}
	
}

int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= n; j++){
			int w; scanf("%d", &w);
			if(i != j) insert(i, j, w);	
		}
	}
	prim(1);
	printf("%d", res);
	system("pause");
	return 0;
}
```

#### 知识点

堆优化Prim算法、最小生成树



### 6.P1346 电车

#### 思想

可以把一个路口看作一张图中的一个点，轨道是图中的边（注意：这是有向图），每一条边的权值就是这个边所联通的点是否需要按按钮（需要按按钮就是1，不需要按按钮就是0）然后就用求最短路径的算法算出最少需要按的开关数。

#### 代码

```C++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;
typedef pair<int, int> P;
const int maxn = 105, maxm = 20005, INF = 0x7fffffff;
struct edge{
	int v, w, nxt;
}es[maxm];
int head[maxn], dis[maxn], vis[maxn];
int cnt, N, A, B;

void insert(int u, int v, int w){
	es[++cnt].v = v;
	es[cnt].w = w;
	es[cnt].nxt = head[u];
	head[u] = cnt;
}

void dijkstra(){
	for(int i = 1; i <= N; i++) dis[i] = INF;
	dis[A] = 0;
	priority_queue<P, vector<P>, greater<P> > que;
	que.push(P(0, A));

	while(!que.empty()){
		P p = que.top(); que.pop();
		int v = p.second;
		if(vis[v]) continue;
		vis[v] = 1;
		for(int e = head[v]; e; e = es[e].nxt){
			int to = es[e].v, w = es[e].w;
			if(!vis[to] && dis[to] > w + dis[v]){
				dis[to] = w + dis[v];
				que.push(P(dis[to], to));
			}
		}
	}
}

int main() {
	scanf("%d%d%d", &N, &A, &B);
	for(int i = 1; i <= N; i++){
		int k, v; scanf("%d", &k);
		for(int j = 1; j <= k; j++){
			scanf("%d", &v);
			if(j == 1) insert(i, v, 0);
			else insert(i, v, 1);
		}
	}
	dijkstra();
	if(dis[B] == INF) printf("-1");
	else printf("%d", dis[B]);
	system("pause");
	return 0;
}
```

#### 知识点

单源最短路，堆优化$Dijsktra$算法



### 7.P4017 最大食物链计数

#### 代码

```C++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;
typedef long long ll;
const ll mod = 80112002, maxn = 5005;
ll n, m, res;
ll dp[maxn], indeg[maxn], outdeg[maxn];
vector<int> G[maxn];

void topology(){
	queue<int> que;
	for(int i = 1; i <= n; i++){
		if(!indeg[i]) {
			que.push(i); dp[i]++;
		}
	}
	while(!que.empty()){
		int u = que.front(); que.pop();
		for(int i = 0; i < G[u].size(); i++){
			int v = G[u][i];
			dp[v] = (dp[v] + dp[u] % mod) % mod;
			if(--indeg[v] == 0) que.push(v);
		}
	}
}

int main() {
	scanf("%lld%lld", &n, &m);
	for(int i = 1; i <= m; i++){
		int u, v; scanf("%d%d", &u, &v);
		G[u].push_back(v);
		indeg[v]++; outdeg[u]++;
	}
	topology();
	for(int i = 1; i <= n; i++){
		if(!outdeg[i]) res += dp[i] % mod;
	}
	printf("%lld", res % mod);
	system("pause");
	return 0;
}
```

#### 知识点

拓扑排序，$DAG$上的$DP$



### 8.P3387 【模板】缩点

#### 思路

首先通过$Tarjan$算法求出所有的强连通分量，强连通分量的点权$=$强连通分量内部所有点权之和，缩点，转化为求$DAG$的最大点权问题。

#### 代码

```C++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;
const int maxn = 1e4 + 5, maxm = 1e5 + 5;
int n, m, S[maxn], S2[maxn];

vector<int> G[maxn];	// 原图
vector<int> G1[maxn];	// 缩点之后的图
int dfn[maxn], low[maxn], id[maxn], scc, timeStamp;
int outdeg[maxn], dp[maxn];
bool inStack[maxn];
stack<int> s;

void tarjan(int u){
	dfn[u] = low[u] = ++timeStamp;
	s.push(u), inStack[u] = true;
	for(auto nxt : G[u]){
		if(!dfn[nxt]){
			tarjan(nxt);
			low[u] = min(low[u], low[nxt]);
		}else if(inStack[nxt]){
			low[u] = min(low[u], dfn[nxt]);
		}
	}
	if(dfn[u] == low[u]){
		int now; scc++;
		do{
			now = s.top(); s.pop();
			inStack[now] = false;
			id[now] = scc;
		}while(now != u);
	}
}

void shrinkPoint(){
	for(int i = 1; i <= n; i++){
		S2[id[i]] += S[i];
		for(auto nxt : G[i]){
			if(id[i] != id[nxt]){
				G1[id[i]].push_back(id[nxt]);
				outdeg[id[i]]++;
			}
		}
	}
}

int topology(){
	for(int i = scc; i; i--){
		dp[i] += S2[i];
		for(auto nxt : G1[i]){
			dp[nxt] = max(dp[i], dp[nxt]);
		}
	}
	int ans = 0;
	for(int i = scc; i; i--){
		if(!outdeg[i]) ans = max(ans, dp[i]);
	}
	return ans;
}

int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++) scanf("%d", &S[i]);
	for(int i = 1; i <= m; i++){
		int u, v; scanf("%d%d", &u, &v);
		G[u].push_back(v);
	}
	for(int i = 1; i <= n; i++){
		if(!dfn[i]) tarjan(i);
	}
	shrinkPoint();
	printf("%d", topology());
	system("pause");
	return 0;
}
```

#### 知识点：

$Tarjan$算法、缩点、$DAG$上的$DP$



### 9.P3388 【模板】割点（割顶）

#### 思想

首先选定一个根节点，从该根节点开始遍历整个图（使用$DFS$）。

对于根节点，判断是不是割点很简单——计算其子树数量，如果有$2$棵即以上的子树，就是割点。因为如果去掉这个点，这两棵子树就不能互相到达。

对于非根节点，判断是不是割点就有些麻烦了。我们维护两个数组$dfn[]$和$low[]$，$dfn[u]$表示顶点$u$第几个被（首次）访问，$low[u]$表示顶点$u$及其子树中的点，通过非父子边（回边），能够回溯到的最早的点（$dfn$最小）的$dfn$值（但不能通过连接$u$与其父节点的边）。对于边$(u, v)$，如果$low[v]\ge dfn[u]$，此时$u$就是割点。

但这里也出现一个问题：怎么计算$low[u]$。

假设当前顶点为$u$，则默认$low[u]=dfn[u]$，即最早只能回溯到自身。

有一条边$(u, v)$，如果$v$未访问过，继续$DFS$，$DFS$完之后，$low[u]=\min(low[u], low[v])$；

如果v访问过（且u不是v的父亲），就不需要继续DFS了，一定有dfn[v]<dfn[u]，low[u]=min(low[u], dfn[v])。

#### 代码

```C++
#include <iostream>
#include <vector>
using namespace std;
const int maxn = 2e4 + 5;
int n, m;
vector<int> G[maxn];
bool isCut[maxn];
int timeStamp, dfn[maxn], low[maxn], num;

void tarjan(int u, int fa){
	dfn[u] = low[u] = ++timeStamp;
	int child = 0;
	for(auto nxt : G[u]){
		if(!dfn[nxt]){
			tarjan(nxt, fa);
			low[u] = min(low[u], low[nxt]);
			if(low[nxt] >= dfn[u] && u != fa) isCut[u] = true;
			if(u == fa) child++;
		}else low[u] = min(low[u], dfn[nxt]);
	}
	if(u == fa && child >= 2) isCut[u] = true;
}

int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= m; i++){
		int u, v; scanf("%d%d", &u, &v);
		G[u].push_back(v);
		G[v].push_back(u);	// 无向图要加两条边
	}
	for(int i = 1; i <= n; i++){
		if(!dfn[i]) tarjan(i, i);
	}
    // 这里要最后更新num，不要一开始写到函数中
	for(int i = 1; i <= n; i++) {
		if(isCut[i]) num++;
	}
	printf("%d\n", num);
	for(int i = 1; i <= n; i++) {
		if(isCut[i]) printf("%d ", i);
	}
	system("pause");
	return 0;
}
```

#### 知识点

无向图割点、Tarjan



### 10.==P2341 [USACO03FALL / HAOI2006] 受欢迎的牛 G==

#### 思想

首先通过Tarjan算法求出强连通分量，强连通分量内的奶牛是互相喜欢的。缩点，计算每个强连通分量的出度。如果说出度为0的SCC不止一个，哪个这两个SCC中的奶牛不可能相互喜欢，结果为0。否则，输出拓扑序最大的强连通分量中奶牛的数目。

#### 代码

```C++
#include <iostream>
#include <stack>
using namespace std;
const int maxn = 1e4 + 5, maxm = 5e4 + 5;
struct edge {
	int v, nxt;
}es[maxm];
int head[maxn], dfn[maxn], low[maxn], id[maxn], outdeg[maxn];
int cnt, scc, timeStamp;//scc表示有多少个强连通分量数目
int N, M; 
bool inStack[maxn];
stack<int> s;

void insert(int u, int v){
	es[++cnt].v = v;
	es[cnt].nxt = head[u];
	head[u] = cnt;
}

void tarjan(int u){
	dfn[u] = low[u] = ++timeStamp;
	s.push(u); inStack[u] = true;
	for(int e = head[u]; e; e = es[e].nxt){
		int v = es[e].v;
		if(!dfn[v]) {
			tarjan(v);
			low[u] = min(low[u], low[v]);
		}
		else if(inStack[v]) low[u] = min(low[u], dfn[v]);
	}
	if(low[u] == dfn[u]){
		int now; scc++;
		do{
			now = s.top(); s.pop();
			inStack[now] = false;
			id[now] = scc;
		}while(now != u);
	}
}

void shrinkPoint(){
	for(int i = 1; i <= N; i++){
		for(int e = head[i]; e; e = es[e].nxt){
			int to = es[e].v;
			if(id[i] != id[to]){
				outdeg[id[i]]++;
			}
		}
	}
}

int main() {
	scanf("%d%d", &N, &M);
	while(M--){
		int u, v; scanf("%d%d", &u, &v);
		insert(u, v);
	}
	for(int i = 1; i <= N; i++){
		if(!dfn[i]) tarjan(i);
	}
	shrinkPoint();
	int num = 0;
	for(int i = 1; i <= scc; i++){
		if(!outdeg[i]) num++;
	}
	if(num != 1) printf("0");
	else{
		int res = 0;
		for(int i = 1; i <= N; i++){
			if(id[i] == 1) res++;
		}
		printf("%d", res);
	}
	system("pause");
	return 0;
}
```

#### 知识点

SCC，Tarjan



### 11.P1726 上白泽慧音

```C++
#include <iostream>
#include <stack>
using namespace std;
const int maxn = 5e3 + 5, maxm = 5e4 + 5;
struct edge {
	int v, nxt;
}es[maxm << 1];
int head[maxn], dfn[maxn], low[maxn], id[maxn], S[maxn];
int cnt, scc, timeStamp;
int N, M; 
bool inStack[maxn];
stack<int> s;

void insert(int u, int v){
	es[++cnt].v = v;
	es[cnt].nxt = head[u];
	head[u] = cnt;
}

void tarjan(int u){
	dfn[u] = low[u] = ++timeStamp;
	s.push(u); inStack[u] = true;
	for(int e = head[u]; e; e = es[e].nxt){
		int v = es[e].v;
		if(!dfn[v]) {
			tarjan(v);
			low[u] = min(low[u], low[v]);
		}
		else if(inStack[v]) low[u] = min(low[u], dfn[v]);
	}
	if(low[u] == dfn[u]){
		int now; scc++;
		do{
			now = s.top(); s.pop();
			inStack[now] = false;
			id[now] = scc;
			S[scc]++;
		}while(now != u);
	}
}

int main() {
	scanf("%d%d", &N, &M);
	while(M--){
		int u, v, p; scanf("%d%d%d", &u, &v, &p);
		insert(u, v);
		if(p == 2) insert(v, u);
	}
	for(int i = 1; i <= N; i++){
		if(!dfn[i]) tarjan(i);
	}
	int maxSize = 0;
	for(int i = 1; i <= scc; i++){
		maxSize = max(maxSize, S[i]);
	}
	printf("%d\n", maxSize);
	for(int i = 1; i <= N; i++){
		if(S[id[i]] == maxSize) {
			for(int j = i; j <= N; j++){
				if(id[j] == id[i]) printf("%d ", j);
			}
			break;
		}
	}
	system("pause");
	return 0;
}
```

#### 知识点

SCC，Tarjan



### 12.P5022 [NOIP2018 提高组] 旅行



#### 知识点

基环树，dfs，贪心算法



### 13.P1262 间谍网络

#### 思想

一是有的罪犯既不能贿赂他也没有罪犯能揭发他，那么此题无解，我们在遍历时打上标记，然后从小到大枚举，只要遇见没有标记的就输出然后退出即可

二是所有的罪犯都能直接或间接地被能贿赂的罪犯揭发。很明显，也有两种情况，一是没有环，那么资金就是贿赂那个没有入度的罪犯，二是有环，那么资金就是那个环里罪犯所需资金最小的。我们想，如果我们把环里的罪犯缩成一个点，那么全都是前者的情况了

```C++
#include <iostream>
#include <vector>
#include <stack>
#include <string.h>
using namespace std;
const int maxn = 3005, maxm = 8005, INF = 0x3f3f3f3f;
vector<int> G[maxn];
int n, timeStamp, p, r, scc;
int Price[maxn], dfn[maxn], low[maxn], id[maxn], indeg[maxn], minP[maxn];
bool inStack[maxn];
stack<int> s;

void tarjan(int u){
	dfn[u] = low[u] = ++timeStamp;
	inStack[u] = true; s.push(u);
	for(auto nxt : G[u]){
		if(!dfn[nxt]){
			tarjan(nxt);
			low[u] = min(low[u], low[nxt]);
		}else if(inStack[nxt]) low[u] = min(low[u], dfn[nxt]);
	}
	if(dfn[u] == low[u]){
		int now; scc++;
		do{
			now = s.top(); s.pop();
			inStack[now] = false;
			id[now] = scc;
			minP[scc] = min(minP[scc], Price[now]);
		}while(now != u);
	}
}

void shrinkPoint(){
	for(register int i = 1; i <= n; i++){
		for(auto nxt : G[i]){
			if(id[i] != id[nxt]) indeg[id[nxt]]++;
		}
	}
}

int main() {
	memset(minP, 0x3f, sizeof minP);
	memset(Price, 0x3f, sizeof Price);
	scanf("%d%d", &n, &p);
	while(p--){
		int u, w; scanf("%d%d", &u, &w);
		Price[u] = w;
	}
	scanf("%d", &r);
	while(r--){
		int u, v; scanf("%d%d", &u, &v);
		G[u].push_back(v);
	}
	for(register int i = 1; i <= n; i++){
		if(!dfn[i]) tarjan(i);
	}
	shrinkPoint();

	int res = 0;
	bool flag = true;
	for(register int i = scc; i; i--){
		if(!indeg[i]) {
			if(minP[i] < INF) res += minP[i];
			else {
				flag = false;
				break;
			}
		} 
	}
	if(flag) printf("YES\n%d", res);
	else{
		printf("NO\n");
		for(register int i = 1; i <= n; i++){
			if(!indeg[id[i]] && minP[id[i]] == INF) {
				printf("%d", i); break;
			}
		}
	}
	system("pause");
	return 0;
}
```

#### 知识点

Tarjan，SCC，缩点



### [P1339 [USACO09OCT\]Heat Wave G](https://www.luogu.com.cn/problem/P1339)

#### 堆优化Dijkstra

```C++
#include <iostream>
#include <queue>
#include <vector>
#include <cstring>
#define P pair<int, int>
using namespace std;
struct edge{
	int v, w, nxt;
}es[6250 << 1];
int h[2550], vis[2550], dis[2550];
int n, m, s, t, cnt;

inline void insert(int u, int v, int w){
	es[++cnt].v = v;
	es[cnt].w = w;
	es[cnt].nxt = h[u];
	h[u] = cnt;
}

void Dijsktra(){
	priority_queue<P, vector<P>, greater<P> > que;
	memset(dis, 0x3f, sizeof dis);
	dis[s] = 0; que.push(P(0, s));
	while(!que.empty()){
		P p = que.top(); que.pop();
		int u = p.second;
		if(vis[u]) continue;
		vis[u] = 1;
		for(register int e = h[u]; e; e = es[e].nxt){
			int v = es[e].v;
			if(!vis[v] && dis[v] > dis[u] + es[e].w) {
				dis[v] = dis[u] + es[e].w;
				que.push(P(dis[v], v));
			}
		}
	}
}

int main(){
	scanf("%d%d%d%d", &n, &m, &s, &t);
	register int i, u, v, w;
	for(i = 1; i <= m; ++i){
		scanf("%d%d%d", &u, &v, &w);
		insert(u, v, w), insert(v, u, w);
	}
	Dijsktra();
	printf("%d", dis[t]);
	return 0;
}
```

#### 线段树优化Dijkstra

每次“出队”时将当前点赋值为INF，线段树在判断“队列为空”的边界时直接判断全局最小值是否等于INF即可。

```C++
#include <cstdio>
#include <cstring>
#include <queue>
#define INF 0x3f3f3f3f
#define N 2550
using namespace std;
struct edge{
	int v, w, nxt;
}es[6250 << 1];
int h[N], dis[N], mn[N << 2];
int n, m, s, t, cnt;

inline int min(int a, int b) {return a > b ? b : a;}
inline void insert(int u, int v, int w){
	es[++cnt].v = v;
	es[cnt].w = w;
	es[cnt].nxt = h[u];
	h[u] = cnt;
}
inline void pushup(int rt){
	mn[rt] = min(mn[rt << 1], mn[rt << 1 | 1]);
}
void modify(int rt, int l, int r, int pos, int val){ // 单点修改
	if(l == r){
		mn[rt] = val;
		return;
	}
	int mid = (l + r) >> 1;
	if(pos <= mid) modify(rt << 1, l, mid, pos, val);
	else modify(rt << 1 | 1, mid + 1, r, pos, val);
	pushup(rt);
}
int query(int rt, int l, int r){
	if(l == r) return l;
	int mid = (l + r) >> 1;
	if(mn[rt << 1] < mn[rt << 1 | 1]) return query(rt << 1, l, mid);
	else return query(rt << 1 | 1, mid + 1, r);
}
inline void Dijkstra(){
	memset(dis, 0x3f, sizeof dis);
	dis[s] = 0;
	modify(1, 1, n, s, 0);
	while(mn[1] ^ INF){
		int p = query(1, 1, n);
		modify(1, 1, n, p, INF);
		for(register int e = h[p]; e; e = es[e].nxt){
			int v = es[e].v;
			if(dis[v] > dis[p] + es[e].w){
				dis[v] = dis[p] + es[e].w;
				modify(1, 1, n, v, dis[v]);
			}
		}
	}
}
int main() {
	memset(mn, 0x3f, sizeof mn);
	scanf("%d%d%d%d", &n, &m, &s, &t);
	register int i, u, v, w;
	for(i = 1; i <= m; ++i){
		scanf("%d%d%d", &u, &v, &w);
		insert(u, v, w), insert(v, u, w);
	}
	Dijkstra();
	printf("%d", dis[t]);
	return 0;
}
```



### P1144 最短路计数

#### 堆优化$Dijkstra$+$DP$

如果是第一次更新这个节点，$dp[v]=dp[u]$

如果是再次更新这个节点，$dp[v]+=dp[u]$

```C++
#include <bits/stdc++.h>
#define P pair<int, int>
#define N 1000005
#define M 2000005
#define MOD 100003
using namespace std;
struct edge{
	int v,nxt;
}es[M << 1];
int h[N], vis[N], dis[N], ans[N];
int n, m, cnt;

inline void insert(int u, int v){
	es[++cnt].v = v;
	es[cnt].nxt = h[u];
	h[u] = cnt;
}

void Dijkstra(){
	priority_queue<P, vector<P>, greater<P> > que;
	memset(dis, 0x3f, sizeof dis);
	dis[1] = 0, ans[1] = 1; que.push(P(0, 1));
	while(!que.empty()){
		P p = que.top(); que.pop();
		int u = p.second;
		if(vis[u]) continue;
		vis[u] = 1;
		for(register int e = h[u]; e; e = es[e].nxt){
			int v = es[e].v;
			if(!vis[v] && dis[v] > dis[u] + 1) {
				dis[v] = dis[u] + 1;
				ans[v] = ans[u];
				que.push(P(dis[v], v));
			}else if(dis[v] == dis[u] + 1){
				ans[v] = (ans[v] + ans[u]) % MOD;
			}	
		}
	}
}

int main(){
	scanf("%d%d", &n, &m);
	register int i, u, v;
	for(i = 1; i <= m; ++i){
		scanf("%d%d", &u, &v);
		insert(u, v), insert(v, u);
	}
	Dijsktra();
	for(i = 1; i <= n; ++i) printf("%d\n", ans[i]);
	return 0;
}
```

#### BFS

```C++
#include <bits/stdc++.h>
#define P pair<int, int>
#define N 1000005
#define M 2000005
#define MOD 100003
using namespace std;
struct edge{
	int v,nxt;
}es[M << 1];
int h[N], vis[N], dis[N], ans[N];
int n, m, cnt;

inline void insert(int u, int v){
	es[++cnt].v = v;
	es[cnt].nxt = h[u];
	h[u] = cnt;
}

void BFS(){
	queue<int> que;
	ans[1] = 1; que.push(1); vis[1] = 1;
	while(!que.empty()){
		int x = que.front(); que.pop();
		for(register int e = h[x]; e; e = es[e].nxt){
			int v = es[e].v;
			if(!vis[v]) {
				vis[v] = 1, dis[v] = dis[x] + 1, ans[v] = ans[x];
				que.push(v);
			}else if(dis[v] == dis[x] + 1){
				ans[v] = (ans[v] + ans[x]) % MOD;
			}
		}
	}
}

int main(){
	scanf("%d%d", &n, &m);
	register int i, u, v;
	for(i = 1; i <= m; ++i){
		scanf("%d%d", &u, &v);
		insert(u, v), insert(v, u);
	}
	BFS();
	for(i = 1; i <= n; ++i) printf("%d\n", ans[i]);
	return 0;
}
```



### P2661 [NOIP2015 提高组] 信息传递

##### 转换为求图上最小环问题

#### 思路：

图上的最小环就是点个数大于等于$2$的强连通分量，所以可以直接用$Tarjan$算法。

```C++
#include <iostream>
#include <stack>
#define maxn 200005
using namespace std;
int E[maxn], dfn[maxn], low[maxn], inStack[maxn], timeStamp, res = 0x3f3f3f3f;
stack<int> s;

void tarjan(int x){
    dfn[x] = low[x] = ++timeStamp;
    s.push(x); inStack[x] = 1;
    if(!dfn[E[x]]) {
        tarjan(E[x]);
        low[x] = min(low[x], low[E[x]]);
    }else if(inStack[E[x]]) low[x] = min(low[x], dfn[E[x]]);
    if(low[x] == dfn[x]){
        int now, temp = 0;
        do{
            now = s.top(); s.pop();
            inStack[now] = 0;
            ++temp;
        }while(now != x);
        if(temp >= 2) res = min(res, temp);
    }
}

int main() {
    int n; scanf("%d", &n);
    register int i;
    for(i = 1; i <= n; ++i) scanf("%d", &E[i]);
    for(i = 1; i <= n; ++i)
        if(!dfn[i]) tarjan(i);
    printf("%d", res);
    system("pause");
    return 0;
}
```

#### 思路2(并查集)

假如说信息由$A$传递给$B$，那么就连一条由$A$指向$B$的边，同时更新$A$的父节点，$A$到它的父节点的路径长也就是B到它的父节点的路径长$+1$。

这样我们就建立好了一个图，之后信息传递的所有环节都按照这些路径。游戏结束的轮数，也就是这个图里最小环的长度。

如果有两个点祖先节点相同，那么就可以构成一个环，长度为两个点到祖先节点长度之和$+1$。

```C++
#include <iostream>
using namespace std;
const int N = 200010;
int n, fa[N], ans = 0x3f3f3f3f;
int get(int x, int &cnt) { //cnt记录环的长度 
    ++cnt;
    if (fa[x] == x) return x;
    else return get(fa[x], cnt);
}
int main () {
    scanf("%d", &n);
    for (register int i = 1; i <= n; ++i) fa[i] = i;
    for (register int i = 1; i <= n; ++i) {
        int cnt = 0, f;
        scanf("%d", &f);
        if (get(f, cnt) == i) ans = min(ans, cnt); //维护最小的环 
        else fa[i] = f;
    }
    printf("%d", ans);
    return 0;
}
```



### P1330 封锁阳光大学

#### 思路1：染色

```C++
#include<bits/stdc++.h>
using namespace std;
vector<int> g[10010];
int n,m,c[10010],x,f[10010];
void dfs(int k,int t){
    if(c[k]!=-1&&c[k]!=t){puts("Impossible");exit(0);}	//冲突，无解
    if(c[k]==t) return;	//记忆化
    c[k]=t;	//染色
    f[k]=1;	//标记
    x++;
    for(int i=0;i<g[k].size();i++) dfs(g[k][i],t^1);	//搜吧，要换颜色
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){	//建图
        int x,y;
        scanf("%d%d",&x,&y);
        g[x].push_back(y);
        g[y].push_back(x);
    }
    int ans=0;
    memset(f,0,sizeof(f));
    for(int i=1;i<=n;i++) 
        if(f[i]==0){	//没搜过的就搜
            x=0;
            memset(c,-1,sizeof(c));
            dfs(i,0);
            int t=0;
            for(int i=1;i<=n;i++) t+=c[i]==1;
            ans+=min(t,x-t);	//累加答案时要注意比较最优解
    	}
    printf("%d",ans);
    return 0;
}
```

#### 思路2：并查集

```C++
#include<bits/stdc++.h>
using namespace std;
int f[10001],a,b,n,m,t[10001],bj[10001],h[10001],ans;
int find(int x)//模板函数；
{
    if(f[x]!=x) f[x]=find(f[x]);
    return f[x];
}
void xx(int x,int y)//判断函数；
{
    int qq=find(x);
    if(qq!=y)//如果他们父亲不相等将他们合并；
    {
        f[y]=qq;
        t[qq]+=t[y];
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        f[i]=i;
        t[i]=1;
    }
    for(int i=1;i<=m;i++){
        scanf("%d%d",&a,&b);
        int x1=find(a), x2=find(b);
        if(x1!=x2)//相邻两点一定异色；
        {
            if(h[a]) xx(h[a],x2);/*a的父亲节点一定
            和a异色，一定和a的异色点同色，所以将他们
            合并；*/
            if(h[b]) xx(h[b],x1);//同上；
            h[a]=x2;//h数组存a点异色点；
            h[b]=x1;//同上；
        }
        else//如果他们同色，表示不行；
        {
            cout<<"Impossible";
            return 0;
        }
    }
    for(int i=1;i<=n;i++){
        int q=find(i);
        if(!bj[q])//表示这个集合的答案还没被选过；
        {
            int q1=find(h[i]);
            bj[q]=1;
            bj[q1]=1;
            ans+=min(t[q],t[q1]);//两种情况最小值；
        }
    }
    cout<<ans;
    return 0;
}
```

